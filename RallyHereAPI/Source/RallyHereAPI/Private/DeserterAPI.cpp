// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#include "DeserterAPI.h"
#include "RallyHereAPIModule.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHttpRequester.h"
#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace RallyHereAPI
{

FDeserterAPI::FDeserterAPI() : FAPI()
{
	Url = TEXT("https://demo.rally-here.io");
	Name = FName(TEXT("Deserter"));
}

FDeserterAPI::~FDeserterAPI() {}

FHttpRequestPtr FDeserterAPI::ClearAllDeserter(const FRequest_ClearAllDeserter& Request, const FDelegate_ClearAllDeserter& Delegate /*= FDelegate_ClearAllDeserter()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnClearAllDeserterResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnClearAllDeserterResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ClearAllDeserter Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnClearAllDeserterResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_ClearAllDeserter Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_ClearAllDeserter::FRequest_ClearAllDeserter()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ClearAllDeserter::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/deserter:clear"));
	return Path;
}

FName FRequest_ClearAllDeserter::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ClearAllDeserter::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_ClearAllDeserter::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ClearAllDeserter - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ClearAllDeserter - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ClearAllDeserter - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ClearAllDeserter::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ClearAllDeserter::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ClearAllDeserter::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ClearAllDeserter::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_ClearAllDeserter::FResponse_ClearAllDeserter(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ClearAllDeserter::Name = TEXT("ClearAllDeserter");

FHttpRequestPtr Traits_ClearAllDeserter::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ClearAllDeserter(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::ClearSpecificDeserter(const FRequest_ClearSpecificDeserter& Request, const FDelegate_ClearSpecificDeserter& Delegate /*= FDelegate_ClearSpecificDeserter()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnClearSpecificDeserterResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnClearSpecificDeserterResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ClearSpecificDeserter Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnClearSpecificDeserterResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_ClearSpecificDeserter Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_ClearSpecificDeserter::FRequest_ClearSpecificDeserter()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ClearSpecificDeserter::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/deserter/{deserter_id}:clear"));
	return Path;
}

FName FRequest_ClearSpecificDeserter::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ClearSpecificDeserter::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("deserter_id"), ToStringFormatArg(DeserterId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/deserter/{deserter_id}:clear"), PathParams);

	return Path;
}

bool FRequest_ClearSpecificDeserter::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ClearSpecificDeserter - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ClearSpecificDeserter - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ClearSpecificDeserter - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ClearSpecificDeserter::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ClearSpecificDeserter::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ClearSpecificDeserter::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ClearSpecificDeserter::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ClearSpecificDeserter::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_ClearSpecificDeserter::FResponse_ClearSpecificDeserter(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ClearSpecificDeserter::Name = TEXT("ClearSpecificDeserter");

FHttpRequestPtr Traits_ClearSpecificDeserter::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ClearSpecificDeserter(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::DeleteAllPlayerDeserter(const FRequest_DeleteAllPlayerDeserter& Request, const FDelegate_DeleteAllPlayerDeserter& Delegate /*= FDelegate_DeleteAllPlayerDeserter()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnDeleteAllPlayerDeserterResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnDeleteAllPlayerDeserterResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeleteAllPlayerDeserter Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnDeleteAllPlayerDeserterResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_DeleteAllPlayerDeserter Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_DeleteAllPlayerDeserter::FRequest_DeleteAllPlayerDeserter()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeleteAllPlayerDeserter::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/{player_uuid}/deserter"));
	return Path;
}

FName FRequest_DeleteAllPlayerDeserter::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeleteAllPlayerDeserter::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/{player_uuid}/deserter"), PathParams);

	return Path;
}

bool FRequest_DeleteAllPlayerDeserter::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteAllPlayerDeserter - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteAllPlayerDeserter - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteAllPlayerDeserter - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeleteAllPlayerDeserter::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeleteAllPlayerDeserter::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_DeleteAllPlayerDeserter::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteAllPlayerDeserter::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteAllPlayerDeserter::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeleteAllPlayerDeserter::FResponse_DeleteAllPlayerDeserter(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_DeleteAllPlayerDeserter::Name = TEXT("DeleteAllPlayerDeserter");

FHttpRequestPtr Traits_DeleteAllPlayerDeserter::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->DeleteAllPlayerDeserter(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::DeletePlayerDeserter(const FRequest_DeletePlayerDeserter& Request, const FDelegate_DeletePlayerDeserter& Delegate /*= FDelegate_DeletePlayerDeserter()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnDeletePlayerDeserterResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnDeletePlayerDeserterResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeletePlayerDeserter Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnDeletePlayerDeserterResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_DeletePlayerDeserter Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_DeletePlayerDeserter::FRequest_DeletePlayerDeserter()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeletePlayerDeserter::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/{player_uuid}/deserter/{deserter_id}"));
	return Path;
}

FName FRequest_DeletePlayerDeserter::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeletePlayerDeserter::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("deserter_id"), ToStringFormatArg(DeserterId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/{player_uuid}/deserter/{deserter_id}"), PathParams);

	return Path;
}

bool FRequest_DeletePlayerDeserter::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeletePlayerDeserter - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeletePlayerDeserter - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeletePlayerDeserter - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeletePlayerDeserter::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeletePlayerDeserter::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_DeletePlayerDeserter::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeletePlayerDeserter::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeletePlayerDeserter::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeletePlayerDeserter::FResponse_DeletePlayerDeserter(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_DeletePlayerDeserter::Name = TEXT("DeletePlayerDeserter");

FHttpRequestPtr Traits_DeletePlayerDeserter::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->DeletePlayerDeserter(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::GetAllDeserterConfigs(const FRequest_GetAllDeserterConfigs& Request, const FDelegate_GetAllDeserterConfigs& Delegate /*= FDelegate_GetAllDeserterConfigs()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetAllDeserterConfigsResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnGetAllDeserterConfigsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllDeserterConfigs Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetAllDeserterConfigsResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetAllDeserterConfigs Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetAllDeserterConfigs::FRequest_GetAllDeserterConfigs()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllDeserterConfigs::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/deserter"));
	return Path;
}

FName FRequest_GetAllDeserterConfigs::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllDeserterConfigs::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetAllDeserterConfigs::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllDeserterConfigs - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllDeserterConfigs - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllDeserterConfigs - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllDeserterConfigs::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllDeserterConfigs::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllDeserterConfigs::TryGetContentFor200(FRHAPI_DeserterConfigResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllDeserterConfigs::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllDeserterConfigs::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_DeserterConfigResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_DeserterConfigResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllDeserterConfigs::FResponse_GetAllDeserterConfigs(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllDeserterConfigs::Name = TEXT("GetAllDeserterConfigs");

FHttpRequestPtr Traits_GetAllDeserterConfigs::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllDeserterConfigs(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::GetAllPlayerDeserters(const FRequest_GetAllPlayerDeserters& Request, const FDelegate_GetAllPlayerDeserters& Delegate /*= FDelegate_GetAllPlayerDeserters()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetAllPlayerDesertersResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnGetAllPlayerDesertersResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllPlayerDeserters Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetAllPlayerDesertersResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetAllPlayerDeserters Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetAllPlayerDeserters::FRequest_GetAllPlayerDeserters()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllPlayerDeserters::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/{player_uuid}/deserter"));
	return Path;
}

FName FRequest_GetAllPlayerDeserters::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllPlayerDeserters::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/{player_uuid}/deserter"), PathParams);

	return Path;
}

bool FRequest_GetAllPlayerDeserters::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllPlayerDeserters - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllPlayerDeserters - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllPlayerDeserters - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllPlayerDeserters::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllPlayerDeserters::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllPlayerDeserters::TryGetContentFor200(FRHAPI_AllPlayerDeserterStatuses& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllPlayerDeserters::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllPlayerDeserters::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllPlayerDeserters::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_AllPlayerDeserterStatuses Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_AllPlayerDeserterStatuses>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllPlayerDeserters::FResponse_GetAllPlayerDeserters(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllPlayerDeserters::Name = TEXT("GetAllPlayerDeserters");

FHttpRequestPtr Traits_GetAllPlayerDeserters::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllPlayerDeserters(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::GetPlayerDeserter(const FRequest_GetPlayerDeserter& Request, const FDelegate_GetPlayerDeserter& Delegate /*= FDelegate_GetPlayerDeserter()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetPlayerDeserterResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnGetPlayerDeserterResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerDeserter Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetPlayerDeserterResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetPlayerDeserter Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetPlayerDeserter::FRequest_GetPlayerDeserter()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerDeserter::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/{player_uuid}/deserter/{deserter_id}"));
	return Path;
}

FName FRequest_GetPlayerDeserter::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerDeserter::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("deserter_id"), ToStringFormatArg(DeserterId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/{player_uuid}/deserter/{deserter_id}"), PathParams);

	return Path;
}

bool FRequest_GetPlayerDeserter::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerDeserter - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerDeserter - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerDeserter - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerDeserter::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerDeserter::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerDeserter::TryGetContentFor200(FRHAPI_PlayerDeserterStatus& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerDeserter::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerDeserter::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerDeserter::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerDeserterStatus Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerDeserterStatus>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerDeserter::FResponse_GetPlayerDeserter(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerDeserter::Name = TEXT("GetPlayerDeserter");

FHttpRequestPtr Traits_GetPlayerDeserter::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerDeserter(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::GetPlayerDeserterSelf(const FRequest_GetPlayerDeserterSelf& Request, const FDelegate_GetPlayerDeserterSelf& Delegate /*= FDelegate_GetPlayerDeserterSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetPlayerDeserterSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnGetPlayerDeserterSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerDeserterSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetPlayerDeserterSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetPlayerDeserterSelf Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetPlayerDeserterSelf::FRequest_GetPlayerDeserterSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerDeserterSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/me/deserter/{deserter_id}"));
	return Path;
}

FName FRequest_GetPlayerDeserterSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerDeserterSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("deserter_id"), ToStringFormatArg(DeserterId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/me/deserter/{deserter_id}"), PathParams);

	return Path;
}

bool FRequest_GetPlayerDeserterSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerDeserterSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerDeserterSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerDeserterSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerDeserterSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerDeserterSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerDeserterSelf::TryGetContentFor200(FRHAPI_PlayerDeserterStatus& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerDeserterSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerDeserterSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerDeserterSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerDeserterStatus Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerDeserterStatus>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerDeserterSelf::FResponse_GetPlayerDeserterSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerDeserterSelf::Name = TEXT("GetPlayerDeserterSelf");

FHttpRequestPtr Traits_GetPlayerDeserterSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerDeserterSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::GetSpecificDeserterConfig(const FRequest_GetSpecificDeserterConfig& Request, const FDelegate_GetSpecificDeserterConfig& Delegate /*= FDelegate_GetSpecificDeserterConfig()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetSpecificDeserterConfigResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnGetSpecificDeserterConfigResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetSpecificDeserterConfig Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnGetSpecificDeserterConfigResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetSpecificDeserterConfig Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetSpecificDeserterConfig::FRequest_GetSpecificDeserterConfig()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetSpecificDeserterConfig::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/deserter/{deserter_id}"));
	return Path;
}

FName FRequest_GetSpecificDeserterConfig::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetSpecificDeserterConfig::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("deserter_id"), ToStringFormatArg(DeserterId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/deserter/{deserter_id}"), PathParams);

	return Path;
}

bool FRequest_GetSpecificDeserterConfig::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSpecificDeserterConfig - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSpecificDeserterConfig - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSpecificDeserterConfig - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetSpecificDeserterConfig::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetSpecificDeserterConfig::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetSpecificDeserterConfig::TryGetContentFor200(FRHAPI_DeserterConfig& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSpecificDeserterConfig::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSpecificDeserterConfig::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSpecificDeserterConfig::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_DeserterConfig Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_DeserterConfig>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetSpecificDeserterConfig::FResponse_GetSpecificDeserterConfig(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetSpecificDeserterConfig::Name = TEXT("GetSpecificDeserterConfig");

FHttpRequestPtr Traits_GetSpecificDeserterConfig::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetSpecificDeserterConfig(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FDeserterAPI::PutPlayerDeserter(const FRequest_PutPlayerDeserter& Request, const FDelegate_PutPlayerDeserter& Delegate /*= FDelegate_PutPlayerDeserter()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FDeserterAPI::OnPutPlayerDeserterResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FDeserterAPI::OnPutPlayerDeserterResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PutPlayerDeserter Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FDeserterAPI::OnPutPlayerDeserterResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_PutPlayerDeserter Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_PutPlayerDeserter::FRequest_PutPlayerDeserter()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_PutPlayerDeserter::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/{player_uuid}/deserter/{deserter_id}"));
	return Path;
}

FName FRequest_PutPlayerDeserter::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_PutPlayerDeserter::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("deserter_id"), ToStringFormatArg(DeserterId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/{player_uuid}/deserter/{deserter_id}"), PathParams);

	return Path;
}

bool FRequest_PutPlayerDeserter::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PutPlayerDeserter - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PutPlayerDeserter - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, DeserterUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PutPlayerDeserter - Body parameter (FRHAPI_DeserterUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PutPlayerDeserter - Body parameter (FRHAPI_DeserterUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PutPlayerDeserter - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_PutPlayerDeserter::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_PutPlayerDeserter::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_PutPlayerDeserter::TryGetContentFor200(FRHAPI_PlayerDeserterStatus& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_PutPlayerDeserter::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_PutPlayerDeserter::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_PutPlayerDeserter::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerDeserterStatus Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerDeserterStatus>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_PutPlayerDeserter::FResponse_PutPlayerDeserter(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_PutPlayerDeserter::Name = TEXT("PutPlayerDeserter");

FHttpRequestPtr Traits_PutPlayerDeserter::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->PutPlayerDeserter(InRequest, InDelegate, InPriority);
}


}
