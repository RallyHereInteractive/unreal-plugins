// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#include "RemoteFileAPI.h"
#include "RallyHereAPIModule.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHttpRequester.h"
#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace RallyHereAPI
{

FRemoteFileAPI::FRemoteFileAPI() : FAPI()
{
	Url = TEXT("https://demo.rally-here.io");
	Name = FName(TEXT("File"));
}

FRemoteFileAPI::~FRemoteFileAPI() {}

FHttpRequestPtr FRemoteFileAPI::CreateEntityDirectoryFile(const FRequest_CreateEntityDirectoryFile& Request, const FDelegate_CreateEntityDirectoryFile& Delegate /*= FDelegate_CreateEntityDirectoryFile()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnCreateEntityDirectoryFileResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FRemoteFileAPI::OnCreateEntityDirectoryFileResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateEntityDirectoryFile Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnCreateEntityDirectoryFileResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_CreateEntityDirectoryFile Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_CreateEntityDirectoryFile::FRequest_CreateEntityDirectoryFile()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateEntityDirectoryFile::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}/{file_name}"));
	return Path;
}

FName FRequest_CreateEntityDirectoryFile::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateEntityDirectoryFile::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("file_type"), ToStringFormatArg(FileType) },
		{ TEXT("file_name"), ToStringFormatArg(FileName) },
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) }
	};

	FString Path = FString::Format(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}/{file_name}"), PathParams);

	return Path;
}

bool FRequest_CreateEntityDirectoryFile::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("multipart/form-data") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateEntityDirectoryFile - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateEntityDirectoryFile - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateEntityDirectoryFile - Form parameter (file) was ignored, not supported in json"));
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		FHttpMultipartFormData FormData;
		FormData.AddFilePart(TEXT("file"), File);

		FormData.SetupHttpRequest(HttpRequest);
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		TArray<FString> FormParams;
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateEntityDirectoryFile - Form parameter (file) was ignored, Files are not supported in urlencoded requests"));

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/x-www-form-urlencoded; charset=utf-8"));
		HttpRequest->SetContentAsString(FString::Join(FormParams, TEXT("&")));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateEntityDirectoryFile - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateEntityDirectoryFile::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateEntityDirectoryFile::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateEntityDirectoryFile::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateEntityDirectoryFile::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_CreateEntityDirectoryFile::FResponse_CreateEntityDirectoryFile(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_CreateEntityDirectoryFile::Name = TEXT("CreateEntityDirectoryFile");

FHttpRequestPtr FRemoteFileAPI::DeleteEntityDirectory(const FRequest_DeleteEntityDirectory& Request, const FDelegate_DeleteEntityDirectory& Delegate /*= FDelegate_DeleteEntityDirectory()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnDeleteEntityDirectoryResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FRemoteFileAPI::OnDeleteEntityDirectoryResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeleteEntityDirectory Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnDeleteEntityDirectoryResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_DeleteEntityDirectory Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_DeleteEntityDirectory::FRequest_DeleteEntityDirectory()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeleteEntityDirectory::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/file/v1/{file_type}/{entity_type}"));
	return Path;
}

FName FRequest_DeleteEntityDirectory::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeleteEntityDirectory::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("file_type"), ToStringFormatArg(FileType) },
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) }
	};

	FString Path = FString::Format(TEXT("/file/v1/{file_type}/{entity_type}"), PathParams);

	return Path;
}

bool FRequest_DeleteEntityDirectory::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteEntityDirectory - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteEntityDirectory - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteEntityDirectory - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeleteEntityDirectory::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeleteEntityDirectory::TryGetContentFor200(FRHAPI_JsonValue& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteEntityDirectory::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteEntityDirectory::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteEntityDirectory::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_JsonValue Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_JsonValue>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_DeleteEntityDirectory::FResponse_DeleteEntityDirectory(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_DeleteEntityDirectory::Name = TEXT("DeleteEntityDirectory");

FHttpRequestPtr FRemoteFileAPI::DeleteEntityDirectoryFile(const FRequest_DeleteEntityDirectoryFile& Request, const FDelegate_DeleteEntityDirectoryFile& Delegate /*= FDelegate_DeleteEntityDirectoryFile()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnDeleteEntityDirectoryFileResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FRemoteFileAPI::OnDeleteEntityDirectoryFileResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeleteEntityDirectoryFile Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnDeleteEntityDirectoryFileResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_DeleteEntityDirectoryFile Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_DeleteEntityDirectoryFile::FRequest_DeleteEntityDirectoryFile()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeleteEntityDirectoryFile::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}/{file_name}"));
	return Path;
}

FName FRequest_DeleteEntityDirectoryFile::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeleteEntityDirectoryFile::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) },
		{ TEXT("file_name"), ToStringFormatArg(FileName) },
		{ TEXT("file_type"), ToStringFormatArg(FileType) }
	};

	FString Path = FString::Format(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}/{file_name}"), PathParams);

	return Path;
}

bool FRequest_DeleteEntityDirectoryFile::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteEntityDirectoryFile - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteEntityDirectoryFile - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteEntityDirectoryFile - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeleteEntityDirectoryFile::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeleteEntityDirectoryFile::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteEntityDirectoryFile::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteEntityDirectoryFile::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeleteEntityDirectoryFile::FResponse_DeleteEntityDirectoryFile(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_DeleteEntityDirectoryFile::Name = TEXT("DeleteEntityDirectoryFile");

FHttpRequestPtr FRemoteFileAPI::DownloadEntityDirectoryFile(const FRequest_DownloadEntityDirectoryFile& Request, const FDelegate_DownloadEntityDirectoryFile& Delegate /*= FDelegate_DownloadEntityDirectoryFile()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnDownloadEntityDirectoryFileResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FRemoteFileAPI::OnDownloadEntityDirectoryFileResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DownloadEntityDirectoryFile Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnDownloadEntityDirectoryFileResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_DownloadEntityDirectoryFile Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_DownloadEntityDirectoryFile::FRequest_DownloadEntityDirectoryFile()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DownloadEntityDirectoryFile::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}/{file_name}"));
	return Path;
}

FName FRequest_DownloadEntityDirectoryFile::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DownloadEntityDirectoryFile::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) },
		{ TEXT("file_name"), ToStringFormatArg(FileName) },
		{ TEXT("file_type"), ToStringFormatArg(FileType) }
	};

	FString Path = FString::Format(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}/{file_name}"), PathParams);

	return Path;
}

bool FRequest_DownloadEntityDirectoryFile::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/octet-stream"), TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DownloadEntityDirectoryFile - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DownloadEntityDirectoryFile - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DownloadEntityDirectoryFile - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DownloadEntityDirectoryFile::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 404:
		return TEXT(" Error Codes: - &#x60;file_not_found&#x60; - File not found. ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DownloadEntityDirectoryFile::TryGetContentFor200(FString& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DownloadEntityDirectoryFile::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DownloadEntityDirectoryFile::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DownloadEntityDirectoryFile::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DownloadEntityDirectoryFile::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FString Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FString>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 404:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_DownloadEntityDirectoryFile::FResponse_DownloadEntityDirectoryFile(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_DownloadEntityDirectoryFile::Name = TEXT("DownloadEntityDirectoryFile");

FHttpRequestPtr FRemoteFileAPI::GetEntityDirectoryInformation(const FRequest_GetEntityDirectoryInformation& Request, const FDelegate_GetEntityDirectoryInformation& Delegate /*= FDelegate_GetEntityDirectoryInformation()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnGetEntityDirectoryInformationResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FRemoteFileAPI::OnGetEntityDirectoryInformationResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetEntityDirectoryInformation Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnGetEntityDirectoryInformationResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetEntityDirectoryInformation Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetEntityDirectoryInformation::FRequest_GetEntityDirectoryInformation()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetEntityDirectoryInformation::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/file/v1/{file_type}/{entity_type}"));
	return Path;
}

FName FRequest_GetEntityDirectoryInformation::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetEntityDirectoryInformation::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("file_type"), ToStringFormatArg(FileType) },
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) }
	};

	FString Path = FString::Format(TEXT("/file/v1/{file_type}/{entity_type}"), PathParams);

	return Path;
}

bool FRequest_GetEntityDirectoryInformation::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityDirectoryInformation - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityDirectoryInformation - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityDirectoryInformation - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetEntityDirectoryInformation::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetEntityDirectoryInformation::TryGetContentFor200(FRHAPI_StorageInformation& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityDirectoryInformation::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityDirectoryInformation::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityDirectoryInformation::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_StorageInformation Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_StorageInformation>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetEntityDirectoryInformation::FResponse_GetEntityDirectoryInformation(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_GetEntityDirectoryInformation::Name = TEXT("GetEntityDirectoryInformation");

FHttpRequestPtr FRemoteFileAPI::ListEntityDirectoryFiles(const FRequest_ListEntityDirectoryFiles& Request, const FDelegate_ListEntityDirectoryFiles& Delegate /*= FDelegate_ListEntityDirectoryFiles()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnListEntityDirectoryFilesResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FRemoteFileAPI::OnListEntityDirectoryFilesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ListEntityDirectoryFiles Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FRemoteFileAPI::OnListEntityDirectoryFilesResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_ListEntityDirectoryFiles Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_ListEntityDirectoryFiles::FRequest_ListEntityDirectoryFiles()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ListEntityDirectoryFiles::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}"));
	return Path;
}

FName FRequest_ListEntityDirectoryFiles::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ListEntityDirectoryFiles::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) },
		{ TEXT("file_type"), ToStringFormatArg(FileType) }
	};

	FString Path = FString::Format(TEXT("/file/v1/{file_type}/{entity_type}/{entity_id}"), PathParams);

	return Path;
}

bool FRequest_ListEntityDirectoryFiles::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ListEntityDirectoryFiles - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ListEntityDirectoryFiles - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ListEntityDirectoryFiles - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ListEntityDirectoryFiles::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ListEntityDirectoryFiles::TryGetContentFor200(FRHAPI_FileListResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ListEntityDirectoryFiles::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ListEntityDirectoryFiles::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ListEntityDirectoryFiles::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_FileListResponse Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_FileListResponse>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ListEntityDirectoryFiles::FResponse_ListEntityDirectoryFiles(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_ListEntityDirectoryFiles::Name = TEXT("ListEntityDirectoryFiles");


}
