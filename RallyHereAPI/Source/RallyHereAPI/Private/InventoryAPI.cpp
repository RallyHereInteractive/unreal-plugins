// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#include "InventoryAPI.h"
#include "RallyHereAPIModule.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHttpRequester.h"
#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace RallyHereAPI
{

FInventoryAPI::FInventoryAPI() : FAPI()
{
	Url = TEXT("https://demo.rally-here.io");
	Name = FName(TEXT("Inventory"));
}

FInventoryAPI::~FInventoryAPI() {}

FHttpRequestPtr FInventoryAPI::CreateNewInventorySession(const FRequest_CreateNewInventorySession& Request, const FDelegate_CreateNewInventorySession& Delegate /*= FDelegate_CreateNewInventorySession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewInventorySessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewInventorySession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewInventorySession> Response = MakeShared<FResponse_CreateNewInventorySession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewInventorySession::FRequest_CreateNewInventorySession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewInventorySession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/session"));
	return Path;
}

FName FRequest_CreateNewInventorySession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewInventorySession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/session"), PathParams);

	return Path;
}

bool FRequest_CreateNewInventorySession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InventorySessionCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySession - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySession - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewInventorySession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 202:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewInventorySession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewInventorySession::TryGetContentFor202(FRHAPI_InventorySessionCreateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySessionCreateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySessionCreateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewInventorySession::FResponse_CreateNewInventorySession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewInventorySession::Name = TEXT("CreateNewInventorySession");

FHttpRequestPtr Traits_CreateNewInventorySession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewInventorySession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewInventorySessionByPlayerUuid(const FRequest_CreateNewInventorySessionByPlayerUuid& Request, const FDelegate_CreateNewInventorySessionByPlayerUuid& Delegate /*= FDelegate_CreateNewInventorySessionByPlayerUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionByPlayerUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewInventorySessionByPlayerUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewInventorySessionByPlayerUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionByPlayerUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewInventorySessionByPlayerUuid> Response = MakeShared<FResponse_CreateNewInventorySessionByPlayerUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewInventorySessionByPlayerUuid::FRequest_CreateNewInventorySessionByPlayerUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewInventorySessionByPlayerUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/session"));
	return Path;
}

FName FRequest_CreateNewInventorySessionByPlayerUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewInventorySessionByPlayerUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/session"), PathParams);

	return Path;
}

bool FRequest_CreateNewInventorySessionByPlayerUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InventorySessionCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuid - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuid - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewInventorySessionByPlayerUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 202:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewInventorySessionByPlayerUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewInventorySessionByPlayerUuid::TryGetContentFor202(FRHAPI_InventorySessionCreateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionByPlayerUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionByPlayerUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionByPlayerUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySessionCreateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySessionCreateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewInventorySessionByPlayerUuid::FResponse_CreateNewInventorySessionByPlayerUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewInventorySessionByPlayerUuid::Name = TEXT("CreateNewInventorySessionByPlayerUuid");

FHttpRequestPtr Traits_CreateNewInventorySessionByPlayerUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewInventorySessionByPlayerUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewInventorySessionByPlayerUuidSelf(const FRequest_CreateNewInventorySessionByPlayerUuidSelf& Request, const FDelegate_CreateNewInventorySessionByPlayerUuidSelf& Delegate /*= FDelegate_CreateNewInventorySessionByPlayerUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionByPlayerUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewInventorySessionByPlayerUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewInventorySessionByPlayerUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionByPlayerUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewInventorySessionByPlayerUuidSelf> Response = MakeShared<FResponse_CreateNewInventorySessionByPlayerUuidSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewInventorySessionByPlayerUuidSelf::FRequest_CreateNewInventorySessionByPlayerUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewInventorySessionByPlayerUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/session"));
	return Path;
}

FName FRequest_CreateNewInventorySessionByPlayerUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewInventorySessionByPlayerUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateNewInventorySessionByPlayerUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InventorySessionCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuidSelf - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuidSelf - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionByPlayerUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewInventorySessionByPlayerUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 202:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewInventorySessionByPlayerUuidSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewInventorySessionByPlayerUuidSelf::TryGetContentFor202(FRHAPI_InventorySessionCreateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionByPlayerUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionByPlayerUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionByPlayerUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySessionCreateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySessionCreateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewInventorySessionByPlayerUuidSelf::FResponse_CreateNewInventorySessionByPlayerUuidSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewInventorySessionByPlayerUuidSelf::Name = TEXT("CreateNewInventorySessionByPlayerUuidSelf");

FHttpRequestPtr Traits_CreateNewInventorySessionByPlayerUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewInventorySessionByPlayerUuidSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewInventorySessionSelf(const FRequest_CreateNewInventorySessionSelf& Request, const FDelegate_CreateNewInventorySessionSelf& Delegate /*= FDelegate_CreateNewInventorySessionSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewInventorySessionSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewInventorySessionSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewInventorySessionSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewInventorySessionSelf> Response = MakeShared<FResponse_CreateNewInventorySessionSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewInventorySessionSelf::FRequest_CreateNewInventorySessionSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewInventorySessionSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/session"));
	return Path;
}

FName FRequest_CreateNewInventorySessionSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewInventorySessionSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateNewInventorySessionSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InventorySessionCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionSelf - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionSelf - Body parameter (FRHAPI_InventorySessionCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewInventorySessionSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewInventorySessionSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 202:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewInventorySessionSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewInventorySessionSelf::TryGetContentFor202(FRHAPI_InventorySessionCreateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewInventorySessionSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySessionCreateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySessionCreateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewInventorySessionSelf::FResponse_CreateNewInventorySessionSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewInventorySessionSelf::Name = TEXT("CreateNewInventorySessionSelf");

FHttpRequestPtr Traits_CreateNewInventorySessionSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewInventorySessionSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewPlayerOrder(const FRequest_CreateNewPlayerOrder& Request, const FDelegate_CreateNewPlayerOrder& Delegate /*= FDelegate_CreateNewPlayerOrder()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerOrderResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewPlayerOrderResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewPlayerOrder Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerOrderResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewPlayerOrder> Response = MakeShared<FResponse_CreateNewPlayerOrder>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewPlayerOrder::FRequest_CreateNewPlayerOrder()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewPlayerOrder::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/order"));
	return Path;
}

FName FRequest_CreateNewPlayerOrder::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewPlayerOrder::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/order"), PathParams);

	return Path;
}

bool FRequest_CreateNewPlayerOrder::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrder - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrder - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, PlayerOrderCreate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrder - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrder - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrder - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewPlayerOrder::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewPlayerOrder::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewPlayerOrder::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrder::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrder::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrder::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrder::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewPlayerOrder::FResponse_CreateNewPlayerOrder(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewPlayerOrder::Name = TEXT("CreateNewPlayerOrder");

FHttpRequestPtr Traits_CreateNewPlayerOrder::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewPlayerOrder(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewPlayerOrderSelf(const FRequest_CreateNewPlayerOrderSelf& Request, const FDelegate_CreateNewPlayerOrderSelf& Delegate /*= FDelegate_CreateNewPlayerOrderSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerOrderSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewPlayerOrderSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewPlayerOrderSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerOrderSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewPlayerOrderSelf> Response = MakeShared<FResponse_CreateNewPlayerOrderSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewPlayerOrderSelf::FRequest_CreateNewPlayerOrderSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewPlayerOrderSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/order"));
	return Path;
}

FName FRequest_CreateNewPlayerOrderSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewPlayerOrderSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateNewPlayerOrderSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrderSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrderSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, PlayerOrderCreate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrderSelf - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrderSelf - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerOrderSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewPlayerOrderSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewPlayerOrderSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewPlayerOrderSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrderSelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrderSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrderSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerOrderSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewPlayerOrderSelf::FResponse_CreateNewPlayerOrderSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewPlayerOrderSelf::Name = TEXT("CreateNewPlayerOrderSelf");

FHttpRequestPtr Traits_CreateNewPlayerOrderSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewPlayerOrderSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewPlayerUuidOrder(const FRequest_CreateNewPlayerUuidOrder& Request, const FDelegate_CreateNewPlayerUuidOrder& Delegate /*= FDelegate_CreateNewPlayerUuidOrder()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerUuidOrderResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewPlayerUuidOrderResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewPlayerUuidOrder Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerUuidOrderResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewPlayerUuidOrder> Response = MakeShared<FResponse_CreateNewPlayerUuidOrder>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewPlayerUuidOrder::FRequest_CreateNewPlayerUuidOrder()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewPlayerUuidOrder::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/order"));
	return Path;
}

FName FRequest_CreateNewPlayerUuidOrder::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewPlayerUuidOrder::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/order"), PathParams);

	return Path;
}

bool FRequest_CreateNewPlayerUuidOrder::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrder - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrder - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, PlayerOrderCreate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrder - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrder - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrder - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewPlayerUuidOrder::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewPlayerUuidOrder::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewPlayerUuidOrder::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrder::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrder::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrder::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrder::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewPlayerUuidOrder::FResponse_CreateNewPlayerUuidOrder(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewPlayerUuidOrder::Name = TEXT("CreateNewPlayerUuidOrder");

FHttpRequestPtr Traits_CreateNewPlayerUuidOrder::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewPlayerUuidOrder(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreateNewPlayerUuidOrderSelf(const FRequest_CreateNewPlayerUuidOrderSelf& Request, const FDelegate_CreateNewPlayerUuidOrderSelf& Delegate /*= FDelegate_CreateNewPlayerUuidOrderSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerUuidOrderSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreateNewPlayerUuidOrderSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateNewPlayerUuidOrderSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreateNewPlayerUuidOrderSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateNewPlayerUuidOrderSelf> Response = MakeShared<FResponse_CreateNewPlayerUuidOrderSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateNewPlayerUuidOrderSelf::FRequest_CreateNewPlayerUuidOrderSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateNewPlayerUuidOrderSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/order"));
	return Path;
}

FName FRequest_CreateNewPlayerUuidOrderSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateNewPlayerUuidOrderSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateNewPlayerUuidOrderSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrderSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrderSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, PlayerOrderCreate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrderSelf - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrderSelf - Body parameter (FRHAPI_PlayerOrderCreate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateNewPlayerUuidOrderSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateNewPlayerUuidOrderSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateNewPlayerUuidOrderSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateNewPlayerUuidOrderSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrderSelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrderSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrderSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateNewPlayerUuidOrderSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateNewPlayerUuidOrderSelf::FResponse_CreateNewPlayerUuidOrderSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateNewPlayerUuidOrderSelf::Name = TEXT("CreateNewPlayerUuidOrderSelf");

FHttpRequestPtr Traits_CreateNewPlayerUuidOrderSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateNewPlayerUuidOrderSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreatePlayerInventory(const FRequest_CreatePlayerInventory& Request, const FDelegate_CreatePlayerInventory& Delegate /*= FDelegate_CreatePlayerInventory()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventoryResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreatePlayerInventoryResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreatePlayerInventory Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventoryResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreatePlayerInventory> Response = MakeShared<FResponse_CreatePlayerInventory>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreatePlayerInventory::FRequest_CreatePlayerInventory()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreatePlayerInventory::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/inventory"));
	return Path;
}

FName FRequest_CreatePlayerInventory::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreatePlayerInventory::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/inventory"), PathParams);

	return Path;
}

bool FRequest_CreatePlayerInventory::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventory - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventory - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, CreateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventory - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventory - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventory - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreatePlayerInventory::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreatePlayerInventory::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreatePlayerInventory::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventory::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventory::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventory::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventory::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreatePlayerInventory::FResponse_CreatePlayerInventory(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreatePlayerInventory::Name = TEXT("CreatePlayerInventory");

FHttpRequestPtr Traits_CreatePlayerInventory::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreatePlayerInventory(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreatePlayerInventorySelf(const FRequest_CreatePlayerInventorySelf& Request, const FDelegate_CreatePlayerInventorySelf& Delegate /*= FDelegate_CreatePlayerInventorySelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventorySelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreatePlayerInventorySelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreatePlayerInventorySelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventorySelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreatePlayerInventorySelf> Response = MakeShared<FResponse_CreatePlayerInventorySelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreatePlayerInventorySelf::FRequest_CreatePlayerInventorySelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreatePlayerInventorySelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/inventory"));
	return Path;
}

FName FRequest_CreatePlayerInventorySelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreatePlayerInventorySelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreatePlayerInventorySelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventorySelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventorySelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, CreateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventorySelf - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventorySelf - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventorySelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreatePlayerInventorySelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreatePlayerInventorySelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreatePlayerInventorySelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventorySelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventorySelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventorySelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventorySelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreatePlayerInventorySelf::FResponse_CreatePlayerInventorySelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreatePlayerInventorySelf::Name = TEXT("CreatePlayerInventorySelf");

FHttpRequestPtr Traits_CreatePlayerInventorySelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreatePlayerInventorySelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreatePlayerInventoryUuid(const FRequest_CreatePlayerInventoryUuid& Request, const FDelegate_CreatePlayerInventoryUuid& Delegate /*= FDelegate_CreatePlayerInventoryUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventoryUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreatePlayerInventoryUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreatePlayerInventoryUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventoryUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreatePlayerInventoryUuid> Response = MakeShared<FResponse_CreatePlayerInventoryUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreatePlayerInventoryUuid::FRequest_CreatePlayerInventoryUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreatePlayerInventoryUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/inventory"));
	return Path;
}

FName FRequest_CreatePlayerInventoryUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreatePlayerInventoryUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/inventory"), PathParams);

	return Path;
}

bool FRequest_CreatePlayerInventoryUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, CreateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuid - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuid - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreatePlayerInventoryUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreatePlayerInventoryUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreatePlayerInventoryUuid::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuid::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreatePlayerInventoryUuid::FResponse_CreatePlayerInventoryUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreatePlayerInventoryUuid::Name = TEXT("CreatePlayerInventoryUuid");

FHttpRequestPtr Traits_CreatePlayerInventoryUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreatePlayerInventoryUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::CreatePlayerInventoryUuidSelf(const FRequest_CreatePlayerInventoryUuidSelf& Request, const FDelegate_CreatePlayerInventoryUuidSelf& Delegate /*= FDelegate_CreatePlayerInventoryUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventoryUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnCreatePlayerInventoryUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreatePlayerInventoryUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnCreatePlayerInventoryUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreatePlayerInventoryUuidSelf> Response = MakeShared<FResponse_CreatePlayerInventoryUuidSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreatePlayerInventoryUuidSelf::FRequest_CreatePlayerInventoryUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreatePlayerInventoryUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/inventory"));
	return Path;
}

FName FRequest_CreatePlayerInventoryUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreatePlayerInventoryUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreatePlayerInventoryUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, CreateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuidSelf - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuidSelf - Body parameter (FRHAPI_CreateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreatePlayerInventoryUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreatePlayerInventoryUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreatePlayerInventoryUuidSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreatePlayerInventoryUuidSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuidSelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreatePlayerInventoryUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreatePlayerInventoryUuidSelf::FResponse_CreatePlayerInventoryUuidSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreatePlayerInventoryUuidSelf::Name = TEXT("CreatePlayerInventoryUuidSelf");

FHttpRequestPtr Traits_CreatePlayerInventoryUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreatePlayerInventoryUuidSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetInventorySessionInfo(const FRequest_GetInventorySessionInfo& Request, const FDelegate_GetInventorySessionInfo& Delegate /*= FDelegate_GetInventorySessionInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetInventorySessionInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetInventorySessionInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetInventorySessionInfo> Response = MakeShared<FResponse_GetInventorySessionInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetInventorySessionInfo::FRequest_GetInventorySessionInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetInventorySessionInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/session"));
	return Path;
}

FName FRequest_GetInventorySessionInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetInventorySessionInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/session"), PathParams);

	return Path;
}

bool FRequest_GetInventorySessionInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetInventorySessionInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetInventorySessionInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetInventorySessionInfo::TryGetContentFor200(FRHAPI_InventorySession& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySession Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySession>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetInventorySessionInfo::FResponse_GetInventorySessionInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetInventorySessionInfo::Name = TEXT("GetInventorySessionInfo");

FHttpRequestPtr Traits_GetInventorySessionInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetInventorySessionInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetInventorySessionInfoByPlayerUuid(const FRequest_GetInventorySessionInfoByPlayerUuid& Request, const FDelegate_GetInventorySessionInfoByPlayerUuid& Delegate /*= FDelegate_GetInventorySessionInfoByPlayerUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoByPlayerUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetInventorySessionInfoByPlayerUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetInventorySessionInfoByPlayerUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoByPlayerUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetInventorySessionInfoByPlayerUuid> Response = MakeShared<FResponse_GetInventorySessionInfoByPlayerUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetInventorySessionInfoByPlayerUuid::FRequest_GetInventorySessionInfoByPlayerUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetInventorySessionInfoByPlayerUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/session"));
	return Path;
}

FName FRequest_GetInventorySessionInfoByPlayerUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetInventorySessionInfoByPlayerUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/session"), PathParams);

	return Path;
}

bool FRequest_GetInventorySessionInfoByPlayerUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoByPlayerUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoByPlayerUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoByPlayerUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetInventorySessionInfoByPlayerUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetInventorySessionInfoByPlayerUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetInventorySessionInfoByPlayerUuid::TryGetContentFor200(FRHAPI_InventorySession& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoByPlayerUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoByPlayerUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoByPlayerUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySession Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySession>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetInventorySessionInfoByPlayerUuid::FResponse_GetInventorySessionInfoByPlayerUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetInventorySessionInfoByPlayerUuid::Name = TEXT("GetInventorySessionInfoByPlayerUuid");

FHttpRequestPtr Traits_GetInventorySessionInfoByPlayerUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetInventorySessionInfoByPlayerUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetInventorySessionInfoByPlayerUuidSelf(const FRequest_GetInventorySessionInfoByPlayerUuidSelf& Request, const FDelegate_GetInventorySessionInfoByPlayerUuidSelf& Delegate /*= FDelegate_GetInventorySessionInfoByPlayerUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoByPlayerUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetInventorySessionInfoByPlayerUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetInventorySessionInfoByPlayerUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoByPlayerUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetInventorySessionInfoByPlayerUuidSelf> Response = MakeShared<FResponse_GetInventorySessionInfoByPlayerUuidSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetInventorySessionInfoByPlayerUuidSelf::FRequest_GetInventorySessionInfoByPlayerUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetInventorySessionInfoByPlayerUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/session"));
	return Path;
}

FName FRequest_GetInventorySessionInfoByPlayerUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetInventorySessionInfoByPlayerUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetInventorySessionInfoByPlayerUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoByPlayerUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoByPlayerUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoByPlayerUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetInventorySessionInfoByPlayerUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetInventorySessionInfoByPlayerUuidSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetInventorySessionInfoByPlayerUuidSelf::TryGetContentFor200(FRHAPI_InventorySession& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoByPlayerUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoByPlayerUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySession Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySession>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetInventorySessionInfoByPlayerUuidSelf::FResponse_GetInventorySessionInfoByPlayerUuidSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetInventorySessionInfoByPlayerUuidSelf::Name = TEXT("GetInventorySessionInfoByPlayerUuidSelf");

FHttpRequestPtr Traits_GetInventorySessionInfoByPlayerUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetInventorySessionInfoByPlayerUuidSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetInventorySessionInfoSelf(const FRequest_GetInventorySessionInfoSelf& Request, const FDelegate_GetInventorySessionInfoSelf& Delegate /*= FDelegate_GetInventorySessionInfoSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetInventorySessionInfoSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetInventorySessionInfoSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetInventorySessionInfoSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetInventorySessionInfoSelf> Response = MakeShared<FResponse_GetInventorySessionInfoSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetInventorySessionInfoSelf::FRequest_GetInventorySessionInfoSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetInventorySessionInfoSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/session"));
	return Path;
}

FName FRequest_GetInventorySessionInfoSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetInventorySessionInfoSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetInventorySessionInfoSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInventorySessionInfoSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetInventorySessionInfoSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetInventorySessionInfoSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetInventorySessionInfoSelf::TryGetContentFor200(FRHAPI_InventorySession& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInventorySessionInfoSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventorySession Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventorySession>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetInventorySessionInfoSelf::FResponse_GetInventorySessionInfoSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetInventorySessionInfoSelf::Name = TEXT("GetInventorySessionInfoSelf");

FHttpRequestPtr Traits_GetInventorySessionInfoSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetInventorySessionInfoSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerInventory(const FRequest_GetPlayerInventory& Request, const FDelegate_GetPlayerInventory& Delegate /*= FDelegate_GetPlayerInventory()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventoryResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerInventoryResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerInventory Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventoryResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerInventory> Response = MakeShared<FResponse_GetPlayerInventory>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerInventory::FRequest_GetPlayerInventory()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerInventory::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/inventory"));
	return Path;
}

FName FRequest_GetPlayerInventory::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerInventory::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/inventory"), PathParams);

	TArray<FString> QueryParams;
	if(ItemIds.IsSet())
	{
		QueryParams.Add(FString(TEXT("item_ids=")) + CollectionToUrlString_multi(ItemIds.GetValue(), TEXT("item_ids")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerInventory::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventory - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventory - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventory - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerInventory::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	case 503:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerInventory::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	case 503:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerInventory::TryGetContentFor200(FRHAPI_InventoryContextResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventory::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventory::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventory::TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 503)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_GetPlayerInventory::GetHeader503_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_GetPlayerInventory::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventoryContextResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventoryContextResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			} 
		case 503:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerInventory::FResponse_GetPlayerInventory(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerInventory::Name = TEXT("GetPlayerInventory");

FHttpRequestPtr Traits_GetPlayerInventory::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerInventory(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerInventorySelf(const FRequest_GetPlayerInventorySelf& Request, const FDelegate_GetPlayerInventorySelf& Delegate /*= FDelegate_GetPlayerInventorySelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventorySelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerInventorySelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerInventorySelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventorySelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerInventorySelf> Response = MakeShared<FResponse_GetPlayerInventorySelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerInventorySelf::FRequest_GetPlayerInventorySelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerInventorySelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/inventory"));
	return Path;
}

FName FRequest_GetPlayerInventorySelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerInventorySelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(ItemIds.IsSet())
	{
		QueryParams.Add(FString(TEXT("item_ids=")) + CollectionToUrlString_multi(ItemIds.GetValue(), TEXT("item_ids")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerInventorySelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventorySelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventorySelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventorySelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerInventorySelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	case 503:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerInventorySelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	case 503:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerInventorySelf::TryGetContentFor200(FRHAPI_InventoryContextResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventorySelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventorySelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventorySelf::TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 503)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_GetPlayerInventorySelf::GetHeader503_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_GetPlayerInventorySelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventoryContextResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventoryContextResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			} 
		case 503:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerInventorySelf::FResponse_GetPlayerInventorySelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerInventorySelf::Name = TEXT("GetPlayerInventorySelf");

FHttpRequestPtr Traits_GetPlayerInventorySelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerInventorySelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerInventoryUuid(const FRequest_GetPlayerInventoryUuid& Request, const FDelegate_GetPlayerInventoryUuid& Delegate /*= FDelegate_GetPlayerInventoryUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventoryUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerInventoryUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerInventoryUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventoryUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerInventoryUuid> Response = MakeShared<FResponse_GetPlayerInventoryUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerInventoryUuid::FRequest_GetPlayerInventoryUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerInventoryUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/inventory"));
	return Path;
}

FName FRequest_GetPlayerInventoryUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerInventoryUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/inventory"), PathParams);

	TArray<FString> QueryParams;
	if(ItemIds.IsSet())
	{
		QueryParams.Add(FString(TEXT("item_ids=")) + CollectionToUrlString_multi(ItemIds.GetValue(), TEXT("item_ids")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerInventoryUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventoryUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventoryUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventoryUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerInventoryUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	case 503:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerInventoryUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	case 503:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerInventoryUuid::TryGetContentFor200(FRHAPI_InventoryContextResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventoryUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventoryUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventoryUuid::TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 503)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_GetPlayerInventoryUuid::GetHeader503_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_GetPlayerInventoryUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventoryContextResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventoryContextResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			} 
		case 503:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerInventoryUuid::FResponse_GetPlayerInventoryUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerInventoryUuid::Name = TEXT("GetPlayerInventoryUuid");

FHttpRequestPtr Traits_GetPlayerInventoryUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerInventoryUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerInventoryUuidSelf(const FRequest_GetPlayerInventoryUuidSelf& Request, const FDelegate_GetPlayerInventoryUuidSelf& Delegate /*= FDelegate_GetPlayerInventoryUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventoryUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerInventoryUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerInventoryUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerInventoryUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerInventoryUuidSelf> Response = MakeShared<FResponse_GetPlayerInventoryUuidSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerInventoryUuidSelf::FRequest_GetPlayerInventoryUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerInventoryUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/inventory"));
	return Path;
}

FName FRequest_GetPlayerInventoryUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerInventoryUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(ItemIds.IsSet())
	{
		QueryParams.Add(FString(TEXT("item_ids=")) + CollectionToUrlString_multi(ItemIds.GetValue(), TEXT("item_ids")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerInventoryUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventoryUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventoryUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInventoryUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerInventoryUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	case 503:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerInventoryUuidSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	case 503:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerInventoryUuidSelf::TryGetContentFor200(FRHAPI_InventoryContextResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventoryUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventoryUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInventoryUuidSelf::TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 503)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_GetPlayerInventoryUuidSelf::GetHeader503_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_GetPlayerInventoryUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InventoryContextResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InventoryContextResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			} 
		case 503:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerInventoryUuidSelf::FResponse_GetPlayerInventoryUuidSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerInventoryUuidSelf::Name = TEXT("GetPlayerInventoryUuidSelf");

FHttpRequestPtr Traits_GetPlayerInventoryUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerInventoryUuidSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerOrderById(const FRequest_GetPlayerOrderById& Request, const FDelegate_GetPlayerOrderById& Delegate /*= FDelegate_GetPlayerOrderById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrderByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerOrderByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerOrderById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrderByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerOrderById> Response = MakeShared<FResponse_GetPlayerOrderById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerOrderById::FRequest_GetPlayerOrderById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerOrderById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/order/{order_id}"));
	return Path;
}

FName FRequest_GetPlayerOrderById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerOrderById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) },
		{ TEXT("order_id"), ToStringFormatArg(OrderId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/order/{order_id}"), PathParams);

	return Path;
}

bool FRequest_GetPlayerOrderById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrderById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrderById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrderById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerOrderById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Order was not found for player");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerOrderById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerOrderById::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderById::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerOrderById::FResponse_GetPlayerOrderById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerOrderById::Name = TEXT("GetPlayerOrderById");

FHttpRequestPtr Traits_GetPlayerOrderById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerOrderById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerOrderByIdSelf(const FRequest_GetPlayerOrderByIdSelf& Request, const FDelegate_GetPlayerOrderByIdSelf& Delegate /*= FDelegate_GetPlayerOrderByIdSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrderByIdSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerOrderByIdSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerOrderByIdSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrderByIdSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerOrderByIdSelf> Response = MakeShared<FResponse_GetPlayerOrderByIdSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerOrderByIdSelf::FRequest_GetPlayerOrderByIdSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerOrderByIdSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/order/{order_id}"));
	return Path;
}

FName FRequest_GetPlayerOrderByIdSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerOrderByIdSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("order_id"), ToStringFormatArg(OrderId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/me/order/{order_id}"), PathParams);

	return Path;
}

bool FRequest_GetPlayerOrderByIdSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrderByIdSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrderByIdSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrderByIdSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerOrderByIdSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Order was not found for player");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerOrderByIdSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerOrderByIdSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderByIdSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderByIdSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderByIdSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrderByIdSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerOrderByIdSelf::FResponse_GetPlayerOrderByIdSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerOrderByIdSelf::Name = TEXT("GetPlayerOrderByIdSelf");

FHttpRequestPtr Traits_GetPlayerOrderByIdSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerOrderByIdSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerOrders(const FRequest_GetPlayerOrders& Request, const FDelegate_GetPlayerOrders& Delegate /*= FDelegate_GetPlayerOrders()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrdersResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerOrdersResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerOrders Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrdersResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerOrders> Response = MakeShared<FResponse_GetPlayerOrders>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerOrders::FRequest_GetPlayerOrders()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerOrders::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/order"));
	return Path;
}

FName FRequest_GetPlayerOrders::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerOrders::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/order"), PathParams);

	TArray<FString> QueryParams;
	if(StartingPosition.IsSet())
	{
		QueryParams.Add(FString(TEXT("starting_position=")) + ToUrlString(StartingPosition.GetValue()));
	}
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + ToUrlString(Sort.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerOrders::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrders - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrders - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrders - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerOrders::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerOrders::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerOrders::TryGetContentFor200(FRHAPI_PlayerOrdersResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrders::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrders::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrders::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrdersResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrdersResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerOrders::FResponse_GetPlayerOrders(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerOrders::Name = TEXT("GetPlayerOrders");

FHttpRequestPtr Traits_GetPlayerOrders::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerOrders(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerOrdersSelf(const FRequest_GetPlayerOrdersSelf& Request, const FDelegate_GetPlayerOrdersSelf& Delegate /*= FDelegate_GetPlayerOrdersSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrdersSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerOrdersSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerOrdersSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerOrdersSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerOrdersSelf> Response = MakeShared<FResponse_GetPlayerOrdersSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerOrdersSelf::FRequest_GetPlayerOrdersSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerOrdersSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/order"));
	return Path;
}

FName FRequest_GetPlayerOrdersSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerOrdersSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(StartingPosition.IsSet())
	{
		QueryParams.Add(FString(TEXT("starting_position=")) + ToUrlString(StartingPosition.GetValue()));
	}
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + ToUrlString(Sort.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerOrdersSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrdersSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrdersSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerOrdersSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerOrdersSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerOrdersSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerOrdersSelf::TryGetContentFor200(FRHAPI_PlayerOrdersResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrdersSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrdersSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerOrdersSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrdersResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrdersResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerOrdersSelf::FResponse_GetPlayerOrdersSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerOrdersSelf::Name = TEXT("GetPlayerOrdersSelf");

FHttpRequestPtr Traits_GetPlayerOrdersSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerOrdersSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerUuidOrderById(const FRequest_GetPlayerUuidOrderById& Request, const FDelegate_GetPlayerUuidOrderById& Delegate /*= FDelegate_GetPlayerUuidOrderById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrderByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerUuidOrderByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerUuidOrderById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrderByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerUuidOrderById> Response = MakeShared<FResponse_GetPlayerUuidOrderById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerUuidOrderById::FRequest_GetPlayerUuidOrderById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerUuidOrderById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/order/{order_id}"));
	return Path;
}

FName FRequest_GetPlayerUuidOrderById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerUuidOrderById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) },
		{ TEXT("order_id"), ToStringFormatArg(OrderId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/order/{order_id}"), PathParams);

	return Path;
}

bool FRequest_GetPlayerUuidOrderById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrderById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrderById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrderById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerUuidOrderById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Order was not found for player");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerUuidOrderById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerUuidOrderById::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderById::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerUuidOrderById::FResponse_GetPlayerUuidOrderById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerUuidOrderById::Name = TEXT("GetPlayerUuidOrderById");

FHttpRequestPtr Traits_GetPlayerUuidOrderById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerUuidOrderById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerUuidOrderByIdSelf(const FRequest_GetPlayerUuidOrderByIdSelf& Request, const FDelegate_GetPlayerUuidOrderByIdSelf& Delegate /*= FDelegate_GetPlayerUuidOrderByIdSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrderByIdSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerUuidOrderByIdSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerUuidOrderByIdSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrderByIdSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerUuidOrderByIdSelf> Response = MakeShared<FResponse_GetPlayerUuidOrderByIdSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerUuidOrderByIdSelf::FRequest_GetPlayerUuidOrderByIdSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerUuidOrderByIdSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/order/{order_id}"));
	return Path;
}

FName FRequest_GetPlayerUuidOrderByIdSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerUuidOrderByIdSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("order_id"), ToStringFormatArg(OrderId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/me/order/{order_id}"), PathParams);

	return Path;
}

bool FRequest_GetPlayerUuidOrderByIdSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrderByIdSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrderByIdSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrderByIdSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerUuidOrderByIdSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Order was not found for player");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerUuidOrderByIdSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerUuidOrderByIdSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderByIdSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderByIdSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderByIdSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrderByIdSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerUuidOrderByIdSelf::FResponse_GetPlayerUuidOrderByIdSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerUuidOrderByIdSelf::Name = TEXT("GetPlayerUuidOrderByIdSelf");

FHttpRequestPtr Traits_GetPlayerUuidOrderByIdSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerUuidOrderByIdSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerUuidOrders(const FRequest_GetPlayerUuidOrders& Request, const FDelegate_GetPlayerUuidOrders& Delegate /*= FDelegate_GetPlayerUuidOrders()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrdersResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerUuidOrdersResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerUuidOrders Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrdersResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerUuidOrders> Response = MakeShared<FResponse_GetPlayerUuidOrders>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerUuidOrders::FRequest_GetPlayerUuidOrders()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerUuidOrders::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/order"));
	return Path;
}

FName FRequest_GetPlayerUuidOrders::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerUuidOrders::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/order"), PathParams);

	TArray<FString> QueryParams;
	if(StartingPosition.IsSet())
	{
		QueryParams.Add(FString(TEXT("starting_position=")) + ToUrlString(StartingPosition.GetValue()));
	}
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + ToUrlString(Sort.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerUuidOrders::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrders - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrders - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrders - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerUuidOrders::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerUuidOrders::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerUuidOrders::TryGetContentFor200(FRHAPI_PlayerOrdersResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrders::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrders::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrders::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrdersResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrdersResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerUuidOrders::FResponse_GetPlayerUuidOrders(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerUuidOrders::Name = TEXT("GetPlayerUuidOrders");

FHttpRequestPtr Traits_GetPlayerUuidOrders::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerUuidOrders(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::GetPlayerUuidOrdersSelf(const FRequest_GetPlayerUuidOrdersSelf& Request, const FDelegate_GetPlayerUuidOrdersSelf& Delegate /*= FDelegate_GetPlayerUuidOrdersSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrdersSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnGetPlayerUuidOrdersSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerUuidOrdersSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnGetPlayerUuidOrdersSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerUuidOrdersSelf> Response = MakeShared<FResponse_GetPlayerUuidOrdersSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerUuidOrdersSelf::FRequest_GetPlayerUuidOrdersSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerUuidOrdersSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/order"));
	return Path;
}

FName FRequest_GetPlayerUuidOrdersSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerUuidOrdersSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(StartingPosition.IsSet())
	{
		QueryParams.Add(FString(TEXT("starting_position=")) + ToUrlString(StartingPosition.GetValue()));
	}
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + ToUrlString(Sort.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerUuidOrdersSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrdersSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrdersSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerUuidOrdersSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerUuidOrdersSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerUuidOrdersSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerUuidOrdersSelf::TryGetContentFor200(FRHAPI_PlayerOrdersResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrdersSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrdersSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerUuidOrdersSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrdersResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrdersResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerUuidOrdersSelf::FResponse_GetPlayerUuidOrdersSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerUuidOrdersSelf::Name = TEXT("GetPlayerUuidOrdersSelf");

FHttpRequestPtr Traits_GetPlayerUuidOrdersSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerUuidOrdersSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyManyPlayerInventory(const FRequest_ModifyManyPlayerInventory& Request, const FDelegate_ModifyManyPlayerInventory& Delegate /*= FDelegate_ModifyManyPlayerInventory()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventoryResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyManyPlayerInventoryResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyManyPlayerInventory Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventoryResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyManyPlayerInventory> Response = MakeShared<FResponse_ModifyManyPlayerInventory>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyManyPlayerInventory::FRequest_ModifyManyPlayerInventory()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyManyPlayerInventory::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/inventory"));
	return Path;
}

FName FRequest_ModifyManyPlayerInventory::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyManyPlayerInventory::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/inventory"), PathParams);

	return Path;
}

bool FRequest_ModifyManyPlayerInventory::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventory - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventory - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventory - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventory - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventory - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyManyPlayerInventory::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyManyPlayerInventory::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyManyPlayerInventory::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventory::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventory::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventory::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventory::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyManyPlayerInventory::FResponse_ModifyManyPlayerInventory(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyManyPlayerInventory::Name = TEXT("ModifyManyPlayerInventory");

FHttpRequestPtr Traits_ModifyManyPlayerInventory::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyManyPlayerInventory(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyManyPlayerInventorySelf(const FRequest_ModifyManyPlayerInventorySelf& Request, const FDelegate_ModifyManyPlayerInventorySelf& Delegate /*= FDelegate_ModifyManyPlayerInventorySelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventorySelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyManyPlayerInventorySelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyManyPlayerInventorySelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventorySelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyManyPlayerInventorySelf> Response = MakeShared<FResponse_ModifyManyPlayerInventorySelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyManyPlayerInventorySelf::FRequest_ModifyManyPlayerInventorySelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyManyPlayerInventorySelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/inventory"));
	return Path;
}

FName FRequest_ModifyManyPlayerInventorySelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyManyPlayerInventorySelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_ModifyManyPlayerInventorySelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventorySelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventorySelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventorySelf - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventorySelf - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventorySelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyManyPlayerInventorySelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyManyPlayerInventorySelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyManyPlayerInventorySelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventorySelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventorySelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventorySelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventorySelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyManyPlayerInventorySelf::FResponse_ModifyManyPlayerInventorySelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyManyPlayerInventorySelf::Name = TEXT("ModifyManyPlayerInventorySelf");

FHttpRequestPtr Traits_ModifyManyPlayerInventorySelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyManyPlayerInventorySelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyManyPlayerInventoryUuid(const FRequest_ModifyManyPlayerInventoryUuid& Request, const FDelegate_ModifyManyPlayerInventoryUuid& Delegate /*= FDelegate_ModifyManyPlayerInventoryUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventoryUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyManyPlayerInventoryUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyManyPlayerInventoryUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventoryUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyManyPlayerInventoryUuid> Response = MakeShared<FResponse_ModifyManyPlayerInventoryUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyManyPlayerInventoryUuid::FRequest_ModifyManyPlayerInventoryUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyManyPlayerInventoryUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/inventory"));
	return Path;
}

FName FRequest_ModifyManyPlayerInventoryUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyManyPlayerInventoryUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/inventory"), PathParams);

	return Path;
}

bool FRequest_ModifyManyPlayerInventoryUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuid - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuid - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyManyPlayerInventoryUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyManyPlayerInventoryUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyManyPlayerInventoryUuid::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuid::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyManyPlayerInventoryUuid::FResponse_ModifyManyPlayerInventoryUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyManyPlayerInventoryUuid::Name = TEXT("ModifyManyPlayerInventoryUuid");

FHttpRequestPtr Traits_ModifyManyPlayerInventoryUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyManyPlayerInventoryUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyManyPlayerInventoryUuidSelf(const FRequest_ModifyManyPlayerInventoryUuidSelf& Request, const FDelegate_ModifyManyPlayerInventoryUuidSelf& Delegate /*= FDelegate_ModifyManyPlayerInventoryUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventoryUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyManyPlayerInventoryUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyManyPlayerInventoryUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyManyPlayerInventoryUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyManyPlayerInventoryUuidSelf> Response = MakeShared<FResponse_ModifyManyPlayerInventoryUuidSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyManyPlayerInventoryUuidSelf::FRequest_ModifyManyPlayerInventoryUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyManyPlayerInventoryUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/inventory"));
	return Path;
}

FName FRequest_ModifyManyPlayerInventoryUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyManyPlayerInventoryUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_ModifyManyPlayerInventoryUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequests);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuidSelf - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuidSelf - Body parameter (FRHAPI_UpdateInventoryRequests) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyManyPlayerInventoryUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyManyPlayerInventoryUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyManyPlayerInventoryUuidSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyManyPlayerInventoryUuidSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuidSelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyManyPlayerInventoryUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyManyPlayerInventoryUuidSelf::FResponse_ModifyManyPlayerInventoryUuidSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyManyPlayerInventoryUuidSelf::Name = TEXT("ModifyManyPlayerInventoryUuidSelf");

FHttpRequestPtr Traits_ModifyManyPlayerInventoryUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyManyPlayerInventoryUuidSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyPlayerInventory(const FRequest_ModifyPlayerInventory& Request, const FDelegate_ModifyPlayerInventory& Delegate /*= FDelegate_ModifyPlayerInventory()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventoryResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyPlayerInventoryResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyPlayerInventory Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventoryResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyPlayerInventory> Response = MakeShared<FResponse_ModifyPlayerInventory>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyPlayerInventory::FRequest_ModifyPlayerInventory()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyPlayerInventory::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/{player_id}/inventory/{inventory_id}"));
	return Path;
}

FName FRequest_ModifyPlayerInventory::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyPlayerInventory::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) },
		{ TEXT("inventory_id"), ToStringFormatArg(InventoryId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/{player_id}/inventory/{inventory_id}"), PathParams);

	return Path;
}

bool FRequest_ModifyPlayerInventory::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventory - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventory - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventory - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventory - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventory - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyPlayerInventory::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyPlayerInventory::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyPlayerInventory::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventory::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventory::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventory::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventory::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyPlayerInventory::FResponse_ModifyPlayerInventory(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyPlayerInventory::Name = TEXT("ModifyPlayerInventory");

FHttpRequestPtr Traits_ModifyPlayerInventory::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyPlayerInventory(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyPlayerInventorySelf(const FRequest_ModifyPlayerInventorySelf& Request, const FDelegate_ModifyPlayerInventorySelf& Delegate /*= FDelegate_ModifyPlayerInventorySelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventorySelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyPlayerInventorySelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyPlayerInventorySelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventorySelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyPlayerInventorySelf> Response = MakeShared<FResponse_ModifyPlayerInventorySelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyPlayerInventorySelf::FRequest_ModifyPlayerInventorySelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyPlayerInventorySelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v1/player/me/inventory/{inventory_id}"));
	return Path;
}

FName FRequest_ModifyPlayerInventorySelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyPlayerInventorySelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("inventory_id"), ToStringFormatArg(InventoryId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v1/player/me/inventory/{inventory_id}"), PathParams);

	return Path;
}

bool FRequest_ModifyPlayerInventorySelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventorySelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventorySelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventorySelf - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventorySelf - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventorySelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyPlayerInventorySelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyPlayerInventorySelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyPlayerInventorySelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventorySelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventorySelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventorySelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventorySelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyPlayerInventorySelf::FResponse_ModifyPlayerInventorySelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyPlayerInventorySelf::Name = TEXT("ModifyPlayerInventorySelf");

FHttpRequestPtr Traits_ModifyPlayerInventorySelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyPlayerInventorySelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyPlayerInventoryUuid(const FRequest_ModifyPlayerInventoryUuid& Request, const FDelegate_ModifyPlayerInventoryUuid& Delegate /*= FDelegate_ModifyPlayerInventoryUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventoryUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyPlayerInventoryUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyPlayerInventoryUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventoryUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyPlayerInventoryUuid> Response = MakeShared<FResponse_ModifyPlayerInventoryUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyPlayerInventoryUuid::FRequest_ModifyPlayerInventoryUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyPlayerInventoryUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/{player_uuid}/inventory/{inventory_id}"));
	return Path;
}

FName FRequest_ModifyPlayerInventoryUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyPlayerInventoryUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) },
		{ TEXT("inventory_id"), ToStringFormatArg(InventoryId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/{player_uuid}/inventory/{inventory_id}"), PathParams);

	return Path;
}

bool FRequest_ModifyPlayerInventoryUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuid - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuid - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyPlayerInventoryUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyPlayerInventoryUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyPlayerInventoryUuid::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuid::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyPlayerInventoryUuid::FResponse_ModifyPlayerInventoryUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyPlayerInventoryUuid::Name = TEXT("ModifyPlayerInventoryUuid");

FHttpRequestPtr Traits_ModifyPlayerInventoryUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyPlayerInventoryUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FInventoryAPI::ModifyPlayerInventoryUuidSelf(const FRequest_ModifyPlayerInventoryUuidSelf& Request, const FDelegate_ModifyPlayerInventoryUuidSelf& Delegate /*= FDelegate_ModifyPlayerInventoryUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventoryUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FInventoryAPI::OnModifyPlayerInventoryUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_ModifyPlayerInventoryUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FInventoryAPI::OnModifyPlayerInventoryUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_ModifyPlayerInventoryUuidSelf> Response = MakeShared<FResponse_ModifyPlayerInventoryUuidSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_ModifyPlayerInventoryUuidSelf::FRequest_ModifyPlayerInventoryUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_ModifyPlayerInventoryUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/inventory/v2/player/me/inventory/{inventory_id}"));
	return Path;
}

FName FRequest_ModifyPlayerInventoryUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_ModifyPlayerInventoryUuidSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("inventory_id"), ToStringFormatArg(InventoryId) }
	};

	FString Path = FString::Format(TEXT("/inventory/v2/player/me/inventory/{inventory_id}"), PathParams);

	return Path;
}

bool FRequest_ModifyPlayerInventoryUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateInventoryRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuidSelf - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuidSelf - Body parameter (FRHAPI_UpdateInventoryRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_ModifyPlayerInventoryUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_ModifyPlayerInventoryUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 202:
		return TEXT("Accepted");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_ModifyPlayerInventoryUuidSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 202:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_ModifyPlayerInventoryUuidSelf::TryGetContentFor200(FRHAPI_PlayerOrder& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuidSelf::TryGetContentFor202(FRHAPI_PlayerOrderCreate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 202)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_ModifyPlayerInventoryUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrder Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrder>(Object);
				break;
			} 
		case 202:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerOrderCreate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerOrderCreate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_ModifyPlayerInventoryUuidSelf::FResponse_ModifyPlayerInventoryUuidSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_ModifyPlayerInventoryUuidSelf::Name = TEXT("ModifyPlayerInventoryUuidSelf");

FHttpRequestPtr Traits_ModifyPlayerInventoryUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->ModifyPlayerInventoryUuidSelf(InRequest, InDelegate, InPriority);
}


}
