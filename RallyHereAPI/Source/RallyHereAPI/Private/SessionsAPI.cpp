// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#include "SessionsAPI.h"
#include "RallyHereAPIModule.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHttpRequester.h"
#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace RallyHereAPI
{

FSessionsAPI::FSessionsAPI() : FAPI()
{
	Url = TEXT("https://demo.rally-here.io");
	Name = FName(TEXT("Sessions"));
}

FSessionsAPI::~FSessionsAPI() {}

FHttpRequestPtr FSessionsAPI::AcknowledgeBackfillRequest(const FRequest_AcknowledgeBackfillRequest& Request, const FDelegate_AcknowledgeBackfillRequest& Delegate /*= FDelegate_AcknowledgeBackfillRequest()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnAcknowledgeBackfillRequestResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnAcknowledgeBackfillRequestResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_AcknowledgeBackfillRequest Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnAcknowledgeBackfillRequestResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_AcknowledgeBackfillRequest> Response = MakeShared<FResponse_AcknowledgeBackfillRequest>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_AcknowledgeBackfillRequest::FRequest_AcknowledgeBackfillRequest()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_AcknowledgeBackfillRequest::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/backfill/session/{session_id}"));
	return Path;
}

FName FRequest_AcknowledgeBackfillRequest::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_AcknowledgeBackfillRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/backfill/session/{session_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_AcknowledgeBackfillRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AcknowledgeBackfillRequest - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AcknowledgeBackfillRequest - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, AcknowledgeBackfillRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AcknowledgeBackfillRequest - Body parameter (FRHAPI_AcknowledgeBackfillRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AcknowledgeBackfillRequest - Body parameter (FRHAPI_AcknowledgeBackfillRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AcknowledgeBackfillRequest - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_AcknowledgeBackfillRequest::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Backfill resource could not be found on the session, or in the open-match system");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_AcknowledgeBackfillRequest::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_AcknowledgeBackfillRequest::TryGetContentFor200(FRHAPI_AcknowledgeBackfillResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AcknowledgeBackfillRequest::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AcknowledgeBackfillRequest::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AcknowledgeBackfillRequest::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AcknowledgeBackfillRequest::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_AcknowledgeBackfillResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_AcknowledgeBackfillResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_AcknowledgeBackfillRequest::FResponse_AcknowledgeBackfillRequest(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_AcknowledgeBackfillRequest::Name = TEXT("AcknowledgeBackfillRequest");

FHttpRequestPtr Traits_AcknowledgeBackfillRequest::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->AcknowledgeBackfillRequest(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::AddPlatformSessionToRallyHereSession(const FRequest_AddPlatformSessionToRallyHereSession& Request, const FDelegate_AddPlatformSessionToRallyHereSession& Delegate /*= FDelegate_AddPlatformSessionToRallyHereSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnAddPlatformSessionToRallyHereSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnAddPlatformSessionToRallyHereSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_AddPlatformSessionToRallyHereSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnAddPlatformSessionToRallyHereSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_AddPlatformSessionToRallyHereSession> Response = MakeShared<FResponse_AddPlatformSessionToRallyHereSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_AddPlatformSessionToRallyHereSession::FRequest_AddPlatformSessionToRallyHereSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_AddPlatformSessionToRallyHereSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/session/{session_id}"));
	return Path;
}

FName FRequest_AddPlatformSessionToRallyHereSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_AddPlatformSessionToRallyHereSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform"), ToStringFormatArg(Platform) },
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) },
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/session/{session_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_AddPlatformSessionToRallyHereSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddPlatformSessionToRallyHereSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddPlatformSessionToRallyHereSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddPlatformSessionToRallyHereSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_AddPlatformSessionToRallyHereSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 409:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_AddPlatformSessionToRallyHereSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 409:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_AddPlatformSessionToRallyHereSession::TryGetContentFor200(FRHAPI_PlatformSession& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_AddPlatformSessionToRallyHereSession::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_AddPlatformSessionToRallyHereSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddPlatformSessionToRallyHereSession::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddPlatformSessionToRallyHereSession::TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 409)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_AddPlatformSessionToRallyHereSession::GetHeader409_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_AddPlatformSessionToRallyHereSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddPlatformSessionToRallyHereSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlatformSession Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlatformSession>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 409:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_AddPlatformSessionToRallyHereSession::FResponse_AddPlatformSessionToRallyHereSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_AddPlatformSessionToRallyHereSession::Name = TEXT("AddPlatformSessionToRallyHereSession");

FHttpRequestPtr Traits_AddPlatformSessionToRallyHereSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->AddPlatformSessionToRallyHereSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::BackfillConfig(const FRequest_BackfillConfig& Request, const FDelegate_BackfillConfig& Delegate /*= FDelegate_BackfillConfig()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnBackfillConfigResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnBackfillConfigResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_BackfillConfig Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnBackfillConfigResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_BackfillConfig> Response = MakeShared<FResponse_BackfillConfig>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_BackfillConfig::FRequest_BackfillConfig()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_BackfillConfig::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/backfill/config"));
	return Path;
}

FName FRequest_BackfillConfig::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_BackfillConfig::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_BackfillConfig::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_BackfillConfig - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_BackfillConfig - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_BackfillConfig - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_BackfillConfig::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_BackfillConfig::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_BackfillConfig::TryGetContentFor200(FRHAPI_BackfillSettingsResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_BackfillConfig::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_BackfillConfig::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_BackfillSettingsResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_BackfillSettingsResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_BackfillConfig::FResponse_BackfillConfig(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_BackfillConfig::Name = TEXT("BackfillConfig");

FHttpRequestPtr Traits_BackfillConfig::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->BackfillConfig(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::CreateInstanceRequest(const FRequest_CreateInstanceRequest& Request, const FDelegate_CreateInstanceRequest& Delegate /*= FDelegate_CreateInstanceRequest()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateInstanceRequestResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnCreateInstanceRequestResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateInstanceRequest Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateInstanceRequestResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateInstanceRequest> Response = MakeShared<FResponse_CreateInstanceRequest>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateInstanceRequest::FRequest_CreateInstanceRequest()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateInstanceRequest::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/instance"));
	return Path;
}

FName FRequest_CreateInstanceRequest::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateInstanceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/instance"), PathParams);

	return Path;
}

bool FRequest_CreateInstanceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateInstanceRequest - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateInstanceRequest - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InstanceRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateInstanceRequest - Body parameter (FRHAPI_InstanceRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateInstanceRequest - Body parameter (FRHAPI_InstanceRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateInstanceRequest - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateInstanceRequest::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateInstanceRequest::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateInstanceRequest::TryGetContentFor200(FRHAPI_InstanceInfo& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateInstanceRequest::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateInstanceRequest::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateInstanceRequest::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InstanceInfo Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InstanceInfo>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateInstanceRequest::FResponse_CreateInstanceRequest(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateInstanceRequest::Name = TEXT("CreateInstanceRequest");

FHttpRequestPtr Traits_CreateInstanceRequest::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateInstanceRequest(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::CreateMatchmadeSession(const FRequest_CreateMatchmadeSession& Request, const FDelegate_CreateMatchmadeSession& Delegate /*= FDelegate_CreateMatchmadeSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateMatchmadeSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnCreateMatchmadeSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateMatchmadeSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateMatchmadeSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateMatchmadeSession> Response = MakeShared<FResponse_CreateMatchmadeSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateMatchmadeSession::FRequest_CreateMatchmadeSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateMatchmadeSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/match-made-session"));
	return Path;
}

FName FRequest_CreateMatchmadeSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateMatchmadeSession::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateMatchmadeSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateMatchmadeSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateMatchmadeSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, MatchMakingSessionRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateMatchmadeSession - Body parameter (FRHAPI_MatchMakingSessionRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateMatchmadeSession - Body parameter (FRHAPI_MatchMakingSessionRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateMatchmadeSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateMatchmadeSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateMatchmadeSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateMatchmadeSession::TryGetContentFor200(FRHAPI_JsonValue& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateMatchmadeSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateMatchmadeSession::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateMatchmadeSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateMatchmadeSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_JsonValue Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_JsonValue>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateMatchmadeSession::FResponse_CreateMatchmadeSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateMatchmadeSession::Name = TEXT("CreateMatchmadeSession");

FHttpRequestPtr Traits_CreateMatchmadeSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateMatchmadeSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::CreateOrJoinSession(const FRequest_CreateOrJoinSession& Request, const FDelegate_CreateOrJoinSession& Delegate /*= FDelegate_CreateOrJoinSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateOrJoinSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnCreateOrJoinSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateOrJoinSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateOrJoinSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateOrJoinSession> Response = MakeShared<FResponse_CreateOrJoinSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateOrJoinSession::FRequest_CreateOrJoinSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateOrJoinSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session"));
	return Path;
}

FName FRequest_CreateOrJoinSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateOrJoinSession::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateOrJoinSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateOrJoinSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateOrJoinSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, CreateOrJoinRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateOrJoinSession - Body parameter (FRHAPI_CreateOrJoinRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateOrJoinSession - Body parameter (FRHAPI_CreateOrJoinRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateOrJoinSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateOrJoinSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 400:
		return TEXT("Bad Request");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateOrJoinSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 400:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateOrJoinSession::TryGetContentFor200(FRHAPI_SessionJoinResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateOrJoinSession::TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 400)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateOrJoinSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateOrJoinSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateOrJoinSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionJoinResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionJoinResponse>(Object);
				break;
			} 
		case 400:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateOrJoinSession::FResponse_CreateOrJoinSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateOrJoinSession::Name = TEXT("CreateOrJoinSession");

FHttpRequestPtr Traits_CreateOrJoinSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateOrJoinSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::CreateSessionAudit(const FRequest_CreateSessionAudit& Request, const FDelegate_CreateSessionAudit& Delegate /*= FDelegate_CreateSessionAudit()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateSessionAuditResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnCreateSessionAuditResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateSessionAudit Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnCreateSessionAuditResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateSessionAudit> Response = MakeShared<FResponse_CreateSessionAudit>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateSessionAudit::FRequest_CreateSessionAudit()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateSessionAudit::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/audit"));
	return Path;
}

FName FRequest_CreateSessionAudit::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateSessionAudit::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateSessionAudit::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateSessionAudit - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateSessionAudit - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, CreateAuditRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateSessionAudit - Body parameter (FRHAPI_CreateAuditRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateSessionAudit - Body parameter (FRHAPI_CreateAuditRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateSessionAudit - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateSessionAudit::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateSessionAudit::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateSessionAudit::TryGetContentFor200(FRHAPI_JsonValue& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateSessionAudit::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateSessionAudit::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateSessionAudit::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateSessionAudit::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_JsonValue Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_JsonValue>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateSessionAudit::FResponse_CreateSessionAudit(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateSessionAudit::Name = TEXT("CreateSessionAudit");

FHttpRequestPtr Traits_CreateSessionAudit::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateSessionAudit(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::DeleteBackfillRequest(const FRequest_DeleteBackfillRequest& Request, const FDelegate_DeleteBackfillRequest& Delegate /*= FDelegate_DeleteBackfillRequest()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnDeleteBackfillRequestResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnDeleteBackfillRequestResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeleteBackfillRequest Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnDeleteBackfillRequestResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_DeleteBackfillRequest> Response = MakeShared<FResponse_DeleteBackfillRequest>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_DeleteBackfillRequest::FRequest_DeleteBackfillRequest()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeleteBackfillRequest::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/backfill/session/{session_id}"));
	return Path;
}

FName FRequest_DeleteBackfillRequest::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeleteBackfillRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/backfill/session/{session_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_DeleteBackfillRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBackfillRequest - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBackfillRequest - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, BaseBackfillRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBackfillRequest - Body parameter (FRHAPI_BaseBackfillRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBackfillRequest - Body parameter (FRHAPI_BaseBackfillRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBackfillRequest - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeleteBackfillRequest::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Backfill resource could not be found on the session, or in the open-match system");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeleteBackfillRequest::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_DeleteBackfillRequest::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteBackfillRequest::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteBackfillRequest::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteBackfillRequest::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeleteBackfillRequest::FResponse_DeleteBackfillRequest(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_DeleteBackfillRequest::Name = TEXT("DeleteBackfillRequest");

FHttpRequestPtr Traits_DeleteBackfillRequest::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->DeleteBackfillRequest(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::DeleteBrowserInfo(const FRequest_DeleteBrowserInfo& Request, const FDelegate_DeleteBrowserInfo& Delegate /*= FDelegate_DeleteBrowserInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnDeleteBrowserInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnDeleteBrowserInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeleteBrowserInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnDeleteBrowserInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_DeleteBrowserInfo> Response = MakeShared<FResponse_DeleteBrowserInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_DeleteBrowserInfo::FRequest_DeleteBrowserInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeleteBrowserInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/browser"));
	return Path;
}

FName FRequest_DeleteBrowserInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeleteBrowserInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/browser"), PathParams);

	return Path;
}

bool FRequest_DeleteBrowserInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBrowserInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBrowserInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteBrowserInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeleteBrowserInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeleteBrowserInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_DeleteBrowserInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteBrowserInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteBrowserInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeleteBrowserInfo::FResponse_DeleteBrowserInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_DeleteBrowserInfo::Name = TEXT("DeleteBrowserInfo");

FHttpRequestPtr Traits_DeleteBrowserInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->DeleteBrowserInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::DeletePlatformSessionFromRallyHereSession(const FRequest_DeletePlatformSessionFromRallyHereSession& Request, const FDelegate_DeletePlatformSessionFromRallyHereSession& Delegate /*= FDelegate_DeletePlatformSessionFromRallyHereSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnDeletePlatformSessionFromRallyHereSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnDeletePlatformSessionFromRallyHereSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeletePlatformSessionFromRallyHereSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnDeletePlatformSessionFromRallyHereSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_DeletePlatformSessionFromRallyHereSession> Response = MakeShared<FResponse_DeletePlatformSessionFromRallyHereSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_DeletePlatformSessionFromRallyHereSession::FRequest_DeletePlatformSessionFromRallyHereSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeletePlatformSessionFromRallyHereSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/session/{session_id}"));
	return Path;
}

FName FRequest_DeletePlatformSessionFromRallyHereSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeletePlatformSessionFromRallyHereSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform"), ToStringFormatArg(Platform) },
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) },
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/session/{session_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_DeletePlatformSessionFromRallyHereSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeletePlatformSessionFromRallyHereSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeletePlatformSessionFromRallyHereSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeletePlatformSessionFromRallyHereSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeletePlatformSessionFromRallyHereSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 409:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeletePlatformSessionFromRallyHereSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 409:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_DeletePlatformSessionFromRallyHereSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeletePlatformSessionFromRallyHereSession::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeletePlatformSessionFromRallyHereSession::TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 409)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_DeletePlatformSessionFromRallyHereSession::GetHeader409_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_DeletePlatformSessionFromRallyHereSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeletePlatformSessionFromRallyHereSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeletePlatformSessionFromRallyHereSession::FResponse_DeletePlatformSessionFromRallyHereSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_DeletePlatformSessionFromRallyHereSession::Name = TEXT("DeletePlatformSessionFromRallyHereSession");

FHttpRequestPtr Traits_DeletePlatformSessionFromRallyHereSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->DeletePlatformSessionFromRallyHereSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::EndInstance(const FRequest_EndInstance& Request, const FDelegate_EndInstance& Delegate /*= FDelegate_EndInstance()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnEndInstanceResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnEndInstanceResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_EndInstance Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnEndInstanceResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_EndInstance> Response = MakeShared<FResponse_EndInstance>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_EndInstance::FRequest_EndInstance()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_EndInstance::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/instance"));
	return Path;
}

FName FRequest_EndInstance::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_EndInstance::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/instance"), PathParams);

	return Path;
}

bool FRequest_EndInstance::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_EndInstance - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_EndInstance - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_EndInstance - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_EndInstance::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_EndInstance::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_EndInstance::GetHeader204_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_EndInstance::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_EndInstance::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_EndInstance::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_EndInstance::FResponse_EndInstance(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_EndInstance::Name = TEXT("EndInstance");

FHttpRequestPtr Traits_EndInstance::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->EndInstance(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetAllMapGameInfo(const FRequest_GetAllMapGameInfo& Request, const FDelegate_GetAllMapGameInfo& Delegate /*= FDelegate_GetAllMapGameInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllMapGameInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetAllMapGameInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllMapGameInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllMapGameInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetAllMapGameInfo> Response = MakeShared<FResponse_GetAllMapGameInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetAllMapGameInfo::FRequest_GetAllMapGameInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllMapGameInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/instance-launch-templates/{instance_launch_template_id}"));
	return Path;
}

FName FRequest_GetAllMapGameInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllMapGameInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("instance_launch_template_id"), ToStringFormatArg(InstanceLaunchTemplateId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/instance-launch-templates/{instance_launch_template_id}"), PathParams);

	return Path;
}

bool FRequest_GetAllMapGameInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllMapGameInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllMapGameInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllMapGameInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllMapGameInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllMapGameInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllMapGameInfo::TryGetContentFor200(FRHAPI_InstanceLaunchTemplate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetAllMapGameInfo::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetAllMapGameInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllMapGameInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllMapGameInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InstanceLaunchTemplate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InstanceLaunchTemplate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllMapGameInfo::FResponse_GetAllMapGameInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllMapGameInfo::Name = TEXT("GetAllMapGameInfo");

FHttpRequestPtr Traits_GetAllMapGameInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllMapGameInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetAllQueueInfo(const FRequest_GetAllQueueInfo& Request, const FDelegate_GetAllQueueInfo& Delegate /*= FDelegate_GetAllQueueInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllQueueInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetAllQueueInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllQueueInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllQueueInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetAllQueueInfo> Response = MakeShared<FResponse_GetAllQueueInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetAllQueueInfo::FRequest_GetAllQueueInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllQueueInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/queues"));
	return Path;
}

FName FRequest_GetAllQueueInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllQueueInfo::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetAllQueueInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllQueueInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllQueueInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllQueueInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllQueueInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllQueueInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllQueueInfo::TryGetContentFor200(FRHAPI_QueuesResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetAllQueueInfo::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetAllQueueInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllQueueInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllQueueInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_QueuesResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_QueuesResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllQueueInfo::FResponse_GetAllQueueInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllQueueInfo::Name = TEXT("GetAllQueueInfo");

FHttpRequestPtr Traits_GetAllQueueInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllQueueInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetAllQueueInfoV2(const FRequest_GetAllQueueInfoV2& Request, const FDelegate_GetAllQueueInfoV2& Delegate /*= FDelegate_GetAllQueueInfoV2()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllQueueInfoV2Response, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetAllQueueInfoV2Response(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllQueueInfoV2 Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllQueueInfoV2Response, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetAllQueueInfoV2> Response = MakeShared<FResponse_GetAllQueueInfoV2>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetAllQueueInfoV2::FRequest_GetAllQueueInfoV2()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllQueueInfoV2::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v2/queues"));
	return Path;
}

FName FRequest_GetAllQueueInfoV2::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllQueueInfoV2::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetAllQueueInfoV2::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllQueueInfoV2 - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllQueueInfoV2 - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllQueueInfoV2 - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllQueueInfoV2::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllQueueInfoV2::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllQueueInfoV2::TryGetContentFor200(FRHAPI_QueuesResponseV2& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetAllQueueInfoV2::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetAllQueueInfoV2::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllQueueInfoV2::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllQueueInfoV2::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_QueuesResponseV2 Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_QueuesResponseV2>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllQueueInfoV2::FResponse_GetAllQueueInfoV2(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllQueueInfoV2::Name = TEXT("GetAllQueueInfoV2");

FHttpRequestPtr Traits_GetAllQueueInfoV2::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllQueueInfoV2(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetAllRegions(const FRequest_GetAllRegions& Request, const FDelegate_GetAllRegions& Delegate /*= FDelegate_GetAllRegions()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllRegionsResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetAllRegionsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllRegions Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllRegionsResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetAllRegions> Response = MakeShared<FResponse_GetAllRegions>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetAllRegions::FRequest_GetAllRegions()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllRegions::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/regions"));
	return Path;
}

FName FRequest_GetAllRegions::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllRegions::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetAllRegions::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllRegions - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllRegions - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllRegions - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllRegions::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllRegions::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllRegions::TryGetContentFor200(FRHAPI_RegionsResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllRegions::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllRegions::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllRegions::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_RegionsResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_RegionsResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllRegions::FResponse_GetAllRegions(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllRegions::Name = TEXT("GetAllRegions");

FHttpRequestPtr Traits_GetAllRegions::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllRegions(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetAllSessionTemplates(const FRequest_GetAllSessionTemplates& Request, const FDelegate_GetAllSessionTemplates& Delegate /*= FDelegate_GetAllSessionTemplates()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllSessionTemplatesResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetAllSessionTemplatesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetAllSessionTemplates Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetAllSessionTemplatesResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetAllSessionTemplates> Response = MakeShared<FResponse_GetAllSessionTemplates>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetAllSessionTemplates::FRequest_GetAllSessionTemplates()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetAllSessionTemplates::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/template"));
	return Path;
}

FName FRequest_GetAllSessionTemplates::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetAllSessionTemplates::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetAllSessionTemplates::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllSessionTemplates - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllSessionTemplates - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetAllSessionTemplates - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetAllSessionTemplates::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetAllSessionTemplates::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetAllSessionTemplates::TryGetContentFor200(FRHAPI_SessionTemplates& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetAllSessionTemplates::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetAllSessionTemplates::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllSessionTemplates::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetAllSessionTemplates::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionTemplates Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionTemplates>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetAllSessionTemplates::FResponse_GetAllSessionTemplates(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetAllSessionTemplates::Name = TEXT("GetAllSessionTemplates");

FHttpRequestPtr Traits_GetAllSessionTemplates::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetAllSessionTemplates(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetBrowserSessionsByType(const FRequest_GetBrowserSessionsByType& Request, const FDelegate_GetBrowserSessionsByType& Delegate /*= FDelegate_GetBrowserSessionsByType()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetBrowserSessionsByTypeResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetBrowserSessionsByTypeResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetBrowserSessionsByType Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetBrowserSessionsByTypeResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetBrowserSessionsByType> Response = MakeShared<FResponse_GetBrowserSessionsByType>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetBrowserSessionsByType::FRequest_GetBrowserSessionsByType()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetBrowserSessionsByType::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/browser"));
	return Path;
}

FName FRequest_GetBrowserSessionsByType::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetBrowserSessionsByType::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("session_type=")) + ToUrlString(SessionType));
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(RegionId.IsSet())
	{
		QueryParams.Add(FString(TEXT("region_id=")) + ToUrlString(RegionId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetBrowserSessionsByType::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetBrowserSessionsByType - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetBrowserSessionsByType - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetBrowserSessionsByType - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetBrowserSessionsByType::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetBrowserSessionsByType::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetBrowserSessionsByType::TryGetContentFor200(FRHAPI_BrowserResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetBrowserSessionsByType::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetBrowserSessionsByType::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetBrowserSessionsByType::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetBrowserSessionsByType::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_BrowserResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_BrowserResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetBrowserSessionsByType::FResponse_GetBrowserSessionsByType(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetBrowserSessionsByType::Name = TEXT("GetBrowserSessionsByType");

FHttpRequestPtr Traits_GetBrowserSessionsByType::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetBrowserSessionsByType(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetConnectionInfoSelf(const FRequest_GetConnectionInfoSelf& Request, const FDelegate_GetConnectionInfoSelf& Delegate /*= FDelegate_GetConnectionInfoSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetConnectionInfoSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetConnectionInfoSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetConnectionInfoSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetConnectionInfoSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetConnectionInfoSelf> Response = MakeShared<FResponse_GetConnectionInfoSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetConnectionInfoSelf::FRequest_GetConnectionInfoSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetConnectionInfoSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/connection-info"));
	return Path;
}

FName FRequest_GetConnectionInfoSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetConnectionInfoSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetConnectionInfoSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (XForwardedFor.IsSet())
	{
		HttpRequest->SetHeader(TEXT("x-forwarded-for"), XForwardedFor.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetConnectionInfoSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetConnectionInfoSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetConnectionInfoSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetConnectionInfoSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetConnectionInfoSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetConnectionInfoSelf::TryGetContentFor200(FRHAPI_ConnectionInfo& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetConnectionInfoSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetConnectionInfoSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetConnectionInfoSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_ConnectionInfo Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_ConnectionInfo>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetConnectionInfoSelf::FResponse_GetConnectionInfoSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetConnectionInfoSelf::Name = TEXT("GetConnectionInfoSelf");

FHttpRequestPtr Traits_GetConnectionInfoSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetConnectionInfoSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetInstanceRequestTemplate(const FRequest_GetInstanceRequestTemplate& Request, const FDelegate_GetInstanceRequestTemplate& Delegate /*= FDelegate_GetInstanceRequestTemplate()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetInstanceRequestTemplateResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetInstanceRequestTemplateResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetInstanceRequestTemplate Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetInstanceRequestTemplateResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetInstanceRequestTemplate> Response = MakeShared<FResponse_GetInstanceRequestTemplate>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetInstanceRequestTemplate::FRequest_GetInstanceRequestTemplate()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetInstanceRequestTemplate::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/instance-request-template/{instance_request_template_id}"));
	return Path;
}

FName FRequest_GetInstanceRequestTemplate::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetInstanceRequestTemplate::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("instance_request_template_id"), ToStringFormatArg(InstanceRequestTemplateId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/instance-request-template/{instance_request_template_id}"), PathParams);

	return Path;
}

bool FRequest_GetInstanceRequestTemplate::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInstanceRequestTemplate - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInstanceRequestTemplate - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetInstanceRequestTemplate - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetInstanceRequestTemplate::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetInstanceRequestTemplate::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetInstanceRequestTemplate::TryGetContentFor200(FRHAPI_InstanceRequestTemplate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetInstanceRequestTemplate::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetInstanceRequestTemplate::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInstanceRequestTemplate::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetInstanceRequestTemplate::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InstanceRequestTemplate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InstanceRequestTemplate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetInstanceRequestTemplate::FResponse_GetInstanceRequestTemplate(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetInstanceRequestTemplate::Name = TEXT("GetInstanceRequestTemplate");

FHttpRequestPtr Traits_GetInstanceRequestTemplate::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetInstanceRequestTemplate(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetMatchMakingProfile(const FRequest_GetMatchMakingProfile& Request, const FDelegate_GetMatchMakingProfile& Delegate /*= FDelegate_GetMatchMakingProfile()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingProfileResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetMatchMakingProfileResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetMatchMakingProfile Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingProfileResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetMatchMakingProfile> Response = MakeShared<FResponse_GetMatchMakingProfile>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetMatchMakingProfile::FRequest_GetMatchMakingProfile()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetMatchMakingProfile::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/match-making-profile/{match_making_profile_id}"));
	return Path;
}

FName FRequest_GetMatchMakingProfile::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetMatchMakingProfile::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("match_making_profile_id"), ToStringFormatArg(MatchMakingProfileId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/match-making-profile/{match_making_profile_id}"), PathParams);

	return Path;
}

bool FRequest_GetMatchMakingProfile::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingProfile - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingProfile - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingProfile - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetMatchMakingProfile::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetMatchMakingProfile::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetMatchMakingProfile::TryGetContentFor200(FRHAPI_MatchMakingProfile& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetMatchMakingProfile::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetMatchMakingProfile::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingProfile::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingProfile::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_MatchMakingProfile Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_MatchMakingProfile>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetMatchMakingProfile::FResponse_GetMatchMakingProfile(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetMatchMakingProfile::Name = TEXT("GetMatchMakingProfile");

FHttpRequestPtr Traits_GetMatchMakingProfile::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetMatchMakingProfile(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetMatchMakingProfileV2(const FRequest_GetMatchMakingProfileV2& Request, const FDelegate_GetMatchMakingProfileV2& Delegate /*= FDelegate_GetMatchMakingProfileV2()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingProfileV2Response, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetMatchMakingProfileV2Response(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetMatchMakingProfileV2 Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingProfileV2Response, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetMatchMakingProfileV2> Response = MakeShared<FResponse_GetMatchMakingProfileV2>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetMatchMakingProfileV2::FRequest_GetMatchMakingProfileV2()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetMatchMakingProfileV2::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v2/match-making-profile/{match_making_profile_id}"));
	return Path;
}

FName FRequest_GetMatchMakingProfileV2::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetMatchMakingProfileV2::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("match_making_profile_id"), ToStringFormatArg(MatchMakingProfileId) }
	};

	FString Path = FString::Format(TEXT("/session/v2/match-making-profile/{match_making_profile_id}"), PathParams);

	return Path;
}

bool FRequest_GetMatchMakingProfileV2::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingProfileV2 - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingProfileV2 - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingProfileV2 - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetMatchMakingProfileV2::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetMatchMakingProfileV2::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetMatchMakingProfileV2::TryGetContentFor200(FRHAPI_MatchMakingProfileV2& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetMatchMakingProfileV2::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetMatchMakingProfileV2::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingProfileV2::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingProfileV2::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_MatchMakingProfileV2 Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_MatchMakingProfileV2>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetMatchMakingProfileV2::FResponse_GetMatchMakingProfileV2(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetMatchMakingProfileV2::Name = TEXT("GetMatchMakingProfileV2");

FHttpRequestPtr Traits_GetMatchMakingProfileV2::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetMatchMakingProfileV2(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetMatchMakingTemplates(const FRequest_GetMatchMakingTemplates& Request, const FDelegate_GetMatchMakingTemplates& Delegate /*= FDelegate_GetMatchMakingTemplates()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingTemplatesResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetMatchMakingTemplatesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetMatchMakingTemplates Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingTemplatesResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetMatchMakingTemplates> Response = MakeShared<FResponse_GetMatchMakingTemplates>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetMatchMakingTemplates::FRequest_GetMatchMakingTemplates()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetMatchMakingTemplates::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/match-making-templates/{template_group_id}"));
	return Path;
}

FName FRequest_GetMatchMakingTemplates::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetMatchMakingTemplates::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("template_group_id"), ToStringFormatArg(TemplateGroupId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/match-making-templates/{template_group_id}"), PathParams);

	return Path;
}

bool FRequest_GetMatchMakingTemplates::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingTemplates - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingTemplates - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingTemplates - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetMatchMakingTemplates::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetMatchMakingTemplates::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetMatchMakingTemplates::TryGetContentFor200(FRHAPI_MatchMakingTemplateGroup& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetMatchMakingTemplates::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetMatchMakingTemplates::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingTemplates::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingTemplates::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_MatchMakingTemplateGroup Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_MatchMakingTemplateGroup>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetMatchMakingTemplates::FResponse_GetMatchMakingTemplates(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetMatchMakingTemplates::Name = TEXT("GetMatchMakingTemplates");

FHttpRequestPtr Traits_GetMatchMakingTemplates::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetMatchMakingTemplates(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetMatchMakingTemplatesV2(const FRequest_GetMatchMakingTemplatesV2& Request, const FDelegate_GetMatchMakingTemplatesV2& Delegate /*= FDelegate_GetMatchMakingTemplatesV2()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingTemplatesV2Response, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetMatchMakingTemplatesV2Response(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetMatchMakingTemplatesV2 Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetMatchMakingTemplatesV2Response, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetMatchMakingTemplatesV2> Response = MakeShared<FResponse_GetMatchMakingTemplatesV2>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetMatchMakingTemplatesV2::FRequest_GetMatchMakingTemplatesV2()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetMatchMakingTemplatesV2::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v2/match-making-templates/{template_group_id}"));
	return Path;
}

FName FRequest_GetMatchMakingTemplatesV2::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetMatchMakingTemplatesV2::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("template_group_id"), ToStringFormatArg(TemplateGroupId) }
	};

	FString Path = FString::Format(TEXT("/session/v2/match-making-templates/{template_group_id}"), PathParams);

	return Path;
}

bool FRequest_GetMatchMakingTemplatesV2::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingTemplatesV2 - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingTemplatesV2 - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetMatchMakingTemplatesV2 - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetMatchMakingTemplatesV2::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetMatchMakingTemplatesV2::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetMatchMakingTemplatesV2::TryGetContentFor200(FRHAPI_MatchMakingTemplateGroupV2& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetMatchMakingTemplatesV2::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetMatchMakingTemplatesV2::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingTemplatesV2::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetMatchMakingTemplatesV2::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_MatchMakingTemplateGroupV2 Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_MatchMakingTemplateGroupV2>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetMatchMakingTemplatesV2::FResponse_GetMatchMakingTemplatesV2(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetMatchMakingTemplatesV2::Name = TEXT("GetMatchMakingTemplatesV2");

FHttpRequestPtr Traits_GetMatchMakingTemplatesV2::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetMatchMakingTemplatesV2(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlatformSessionInfo(const FRequest_GetPlatformSessionInfo& Request, const FDelegate_GetPlatformSessionInfo& Delegate /*= FDelegate_GetPlatformSessionInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlatformSessionInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlatformSessionInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlatformSessionInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlatformSessionInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlatformSessionInfo> Response = MakeShared<FResponse_GetPlatformSessionInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlatformSessionInfo::FRequest_GetPlatformSessionInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlatformSessionInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}"));
	return Path;
}

FName FRequest_GetPlatformSessionInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlatformSessionInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform"), ToStringFormatArg(Platform) },
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}"), PathParams);

	return Path;
}

bool FRequest_GetPlatformSessionInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlatformSessionInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlatformSessionInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlatformSessionInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlatformSessionInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlatformSessionInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlatformSessionInfo::TryGetContentFor200(FRHAPI_PlatformSession& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetPlatformSessionInfo::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetPlatformSessionInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlatformSessionInfo::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlatformSessionInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlatformSessionInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlatformSession Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlatformSession>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlatformSessionInfo::FResponse_GetPlatformSessionInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlatformSessionInfo::Name = TEXT("GetPlatformSessionInfo");

FHttpRequestPtr Traits_GetPlatformSessionInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlatformSessionInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlayerInSession(const FRequest_GetPlayerInSession& Request, const FDelegate_GetPlayerInSession& Delegate /*= FDelegate_GetPlayerInSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerInSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlayerInSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerInSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerInSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerInSession> Response = MakeShared<FResponse_GetPlayerInSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerInSession::FRequest_GetPlayerInSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerInSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/{player_uuid}"));
	return Path;
}

FName FRequest_GetPlayerInSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerInSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) },
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/{player_uuid}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayerInSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerInSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerInSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerInSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerInSession::TryGetContentFor200(FRHAPI_SessionPlayer& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetPlayerInSession::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetPlayerInSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerInSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionPlayer Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionPlayer>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerInSession::FResponse_GetPlayerInSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerInSession::Name = TEXT("GetPlayerInSession");

FHttpRequestPtr Traits_GetPlayerInSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerInSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlayerSessions(const FRequest_GetPlayerSessions& Request, const FDelegate_GetPlayerSessions& Delegate /*= FDelegate_GetPlayerSessions()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlayerSessionsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerSessions Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerSessions> Response = MakeShared<FResponse_GetPlayerSessions>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerSessions::FRequest_GetPlayerSessions()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerSessions::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/id/{player_id}/session"));
	return Path;
}

FName FRequest_GetPlayerSessions::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerSessions::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/id/{player_id}/session"), PathParams);

	return Path;
}

bool FRequest_GetPlayerSessions::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessions - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessions - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessions - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerSessions::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerSessions::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerSessions::TryGetContentFor200(FRHAPI_PlayerSessions& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessions::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessions::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessions::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerSessions Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerSessions>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerSessions::FResponse_GetPlayerSessions(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerSessions::Name = TEXT("GetPlayerSessions");

FHttpRequestPtr Traits_GetPlayerSessions::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerSessions(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlayerSessionsByUuid(const FRequest_GetPlayerSessionsByUuid& Request, const FDelegate_GetPlayerSessionsByUuid& Delegate /*= FDelegate_GetPlayerSessionsByUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsByUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlayerSessionsByUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerSessionsByUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsByUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerSessionsByUuid> Response = MakeShared<FResponse_GetPlayerSessionsByUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerSessionsByUuid::FRequest_GetPlayerSessionsByUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerSessionsByUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/uuid/{player_uuid}/session"));
	return Path;
}

FName FRequest_GetPlayerSessionsByUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerSessionsByUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/uuid/{player_uuid}/session"), PathParams);

	return Path;
}

bool FRequest_GetPlayerSessionsByUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsByUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsByUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsByUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerSessionsByUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerSessionsByUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerSessionsByUuid::TryGetContentFor200(FRHAPI_PlayerSessions& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetPlayerSessionsByUuid::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetPlayerSessionsByUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessionsByUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessionsByUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerSessions Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerSessions>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerSessionsByUuid::FResponse_GetPlayerSessionsByUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerSessionsByUuid::Name = TEXT("GetPlayerSessionsByUuid");

FHttpRequestPtr Traits_GetPlayerSessionsByUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerSessionsByUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlayerSessionsByUuidV2(const FRequest_GetPlayerSessionsByUuidV2& Request, const FDelegate_GetPlayerSessionsByUuidV2& Delegate /*= FDelegate_GetPlayerSessionsByUuidV2()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsByUuidV2Response, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlayerSessionsByUuidV2Response(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerSessionsByUuidV2 Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsByUuidV2Response, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerSessionsByUuidV2> Response = MakeShared<FResponse_GetPlayerSessionsByUuidV2>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerSessionsByUuidV2::FRequest_GetPlayerSessionsByUuidV2()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerSessionsByUuidV2::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/{player_uuid}/session"));
	return Path;
}

FName FRequest_GetPlayerSessionsByUuidV2::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerSessionsByUuidV2::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/player/{player_uuid}/session"), PathParams);

	return Path;
}

bool FRequest_GetPlayerSessionsByUuidV2::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsByUuidV2 - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsByUuidV2 - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsByUuidV2 - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerSessionsByUuidV2::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerSessionsByUuidV2::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerSessionsByUuidV2::TryGetContentFor200(FRHAPI_PlayerSessions& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetPlayerSessionsByUuidV2::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetPlayerSessionsByUuidV2::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessionsByUuidV2::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessionsByUuidV2::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerSessions Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerSessions>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerSessionsByUuidV2::FResponse_GetPlayerSessionsByUuidV2(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerSessionsByUuidV2::Name = TEXT("GetPlayerSessionsByUuidV2");

FHttpRequestPtr Traits_GetPlayerSessionsByUuidV2::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerSessionsByUuidV2(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlayerSessionsSelf(const FRequest_GetPlayerSessionsSelf& Request, const FDelegate_GetPlayerSessionsSelf& Delegate /*= FDelegate_GetPlayerSessionsSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlayerSessionsSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayerSessionsSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayerSessionsSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayerSessionsSelf> Response = MakeShared<FResponse_GetPlayerSessionsSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayerSessionsSelf::FRequest_GetPlayerSessionsSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayerSessionsSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/player/me/session"));
	return Path;
}

FName FRequest_GetPlayerSessionsSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayerSessionsSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetPlayerSessionsSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayerSessionsSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayerSessionsSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayerSessionsSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayerSessionsSelf::TryGetContentFor200(FRHAPI_PlayerSessions& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetPlayerSessionsSelf::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetPlayerSessionsSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessionsSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayerSessionsSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PlayerSessions Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PlayerSessions>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayerSessionsSelf::FResponse_GetPlayerSessionsSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayerSessionsSelf::Name = TEXT("GetPlayerSessionsSelf");

FHttpRequestPtr Traits_GetPlayerSessionsSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayerSessionsSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetPlayersInSession(const FRequest_GetPlayersInSession& Request, const FDelegate_GetPlayersInSession& Delegate /*= FDelegate_GetPlayersInSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayersInSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetPlayersInSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetPlayersInSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetPlayersInSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetPlayersInSession> Response = MakeShared<FResponse_GetPlayersInSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetPlayersInSession::FRequest_GetPlayersInSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetPlayersInSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player"));
	return Path;
}

FName FRequest_GetPlayersInSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetPlayersInSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player"), PathParams);

	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetPlayersInSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayersInSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayersInSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetPlayersInSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetPlayersInSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetPlayersInSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetPlayersInSession::TryGetContentFor200(FRHAPI_PagedPlayersResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetPlayersInSession::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetPlayersInSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayersInSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetPlayersInSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_PagedPlayersResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_PagedPlayersResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetPlayersInSession::FResponse_GetPlayersInSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetPlayersInSession::Name = TEXT("GetPlayersInSession");

FHttpRequestPtr Traits_GetPlayersInSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetPlayersInSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetSessionAudit(const FRequest_GetSessionAudit& Request, const FDelegate_GetSessionAudit& Delegate /*= FDelegate_GetSessionAudit()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionAuditResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetSessionAuditResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetSessionAudit Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionAuditResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetSessionAudit> Response = MakeShared<FResponse_GetSessionAudit>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetSessionAudit::FRequest_GetSessionAudit()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetSessionAudit::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/audit"));
	return Path;
}

FName FRequest_GetSessionAudit::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetSessionAudit::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(SessionId.IsSet())
	{
		QueryParams.Add(FString(TEXT("session_id=")) + ToUrlString(SessionId.GetValue()));
	}
	if(PlayerUuid.IsSet())
	{
		QueryParams.Add(FString(TEXT("player_uuid=")) + ToUrlString(PlayerUuid.GetValue()));
	}
	if(PageNum.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_num=")) + ToUrlString(PageNum.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetSessionAudit::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionAudit - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionAudit - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionAudit - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetSessionAudit::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetSessionAudit::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetSessionAudit::TryGetContentFor200(FRHAPI_AuditResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionAudit::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionAudit::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionAudit::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_AuditResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_AuditResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetSessionAudit::FResponse_GetSessionAudit(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetSessionAudit::Name = TEXT("GetSessionAudit");

FHttpRequestPtr Traits_GetSessionAudit::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetSessionAudit(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetSessionByAllocationId(const FRequest_GetSessionByAllocationId& Request, const FDelegate_GetSessionByAllocationId& Delegate /*= FDelegate_GetSessionByAllocationId()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionByAllocationIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetSessionByAllocationIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetSessionByAllocationId Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionByAllocationIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetSessionByAllocationId> Response = MakeShared<FResponse_GetSessionByAllocationId>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetSessionByAllocationId::FRequest_GetSessionByAllocationId()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetSessionByAllocationId::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/allocation/{allocation_id}"));
	return Path;
}

FName FRequest_GetSessionByAllocationId::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetSessionByAllocationId::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("allocation_id"), ToStringFormatArg(AllocationId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/allocation/{allocation_id}"), PathParams);

	return Path;
}

bool FRequest_GetSessionByAllocationId::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionByAllocationId - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionByAllocationId - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionByAllocationId - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetSessionByAllocationId::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetSessionByAllocationId::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetSessionByAllocationId::TryGetContentFor200(FRHAPI_Session& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetSessionByAllocationId::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetSessionByAllocationId::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionByAllocationId::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionByAllocationId::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_Session Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_Session>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetSessionByAllocationId::FResponse_GetSessionByAllocationId(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetSessionByAllocationId::Name = TEXT("GetSessionByAllocationId");

FHttpRequestPtr Traits_GetSessionByAllocationId::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetSessionByAllocationId(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetSessionById(const FRequest_GetSessionById& Request, const FDelegate_GetSessionById& Delegate /*= FDelegate_GetSessionById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetSessionByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetSessionById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetSessionById> Response = MakeShared<FResponse_GetSessionById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetSessionById::FRequest_GetSessionById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetSessionById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}"));
	return Path;
}

FName FRequest_GetSessionById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetSessionById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetSessionById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetSessionById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetSessionById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetSessionById::TryGetContentFor200(FRHAPI_Session& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetSessionById::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetSessionById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_Session Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_Session>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetSessionById::FResponse_GetSessionById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetSessionById::Name = TEXT("GetSessionById");

FHttpRequestPtr Traits_GetSessionById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetSessionById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetSessionTemplateByType(const FRequest_GetSessionTemplateByType& Request, const FDelegate_GetSessionTemplateByType& Delegate /*= FDelegate_GetSessionTemplateByType()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionTemplateByTypeResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetSessionTemplateByTypeResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetSessionTemplateByType Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetSessionTemplateByTypeResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetSessionTemplateByType> Response = MakeShared<FResponse_GetSessionTemplateByType>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetSessionTemplateByType::FRequest_GetSessionTemplateByType()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetSessionTemplateByType::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/template/{session_type}"));
	return Path;
}

FName FRequest_GetSessionTemplateByType::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetSessionTemplateByType::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_type"), ToStringFormatArg(SessionType) }
	};

	FString Path = FString::Format(TEXT("/session/v1/template/{session_type}"), PathParams);

	return Path;
}

bool FRequest_GetSessionTemplateByType::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (IfNoneMatch.IsSet())
	{
		HttpRequest->SetHeader(TEXT("if-none-match"), IfNoneMatch.GetValue());
	}

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionTemplateByType - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionTemplateByType - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetSessionTemplateByType - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetSessionTemplateByType::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetSessionTemplateByType::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetSessionTemplateByType::TryGetContentFor200(FRHAPI_SessionTemplate& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_GetSessionTemplateByType::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_GetSessionTemplateByType::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionTemplateByType::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetSessionTemplateByType::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionTemplate Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionTemplate>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetSessionTemplateByType::FResponse_GetSessionTemplateByType(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetSessionTemplateByType::Name = TEXT("GetSessionTemplateByType");

FHttpRequestPtr Traits_GetSessionTemplateByType::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetSessionTemplateByType(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetVoipActionToken(const FRequest_GetVoipActionToken& Request, const FDelegate_GetVoipActionToken& Delegate /*= FDelegate_GetVoipActionToken()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetVoipActionTokenResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetVoipActionTokenResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetVoipActionToken Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetVoipActionTokenResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetVoipActionToken> Response = MakeShared<FResponse_GetVoipActionToken>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetVoipActionToken::FRequest_GetVoipActionToken()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetVoipActionToken::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/{player_uuid}/voip/vivox:{vivox_action}"));
	return Path;
}

FName FRequest_GetVoipActionToken::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetVoipActionToken::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) },
		{ TEXT("vivox_action"), ToStringFormatArg(VivoxAction) },
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/{player_uuid}/voip/vivox:{vivox_action}"), PathParams);

	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("voip_session_type=")) + ToUrlString(VoipSessionType));
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetVoipActionToken::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipActionToken - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipActionToken - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipActionToken - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetVoipActionToken::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetVoipActionToken::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetVoipActionToken::TryGetContentFor200(FRHAPI_VoipTokenResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipActionToken::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipActionToken::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipActionToken::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_VoipTokenResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_VoipTokenResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetVoipActionToken::FResponse_GetVoipActionToken(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetVoipActionToken::Name = TEXT("GetVoipActionToken");

FHttpRequestPtr Traits_GetVoipActionToken::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetVoipActionToken(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetVoipActionTokenMe(const FRequest_GetVoipActionTokenMe& Request, const FDelegate_GetVoipActionTokenMe& Delegate /*= FDelegate_GetVoipActionTokenMe()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetVoipActionTokenMeResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetVoipActionTokenMeResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetVoipActionTokenMe Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetVoipActionTokenMeResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetVoipActionTokenMe> Response = MakeShared<FResponse_GetVoipActionTokenMe>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetVoipActionTokenMe::FRequest_GetVoipActionTokenMe()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetVoipActionTokenMe::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/me/voip/vivox:{vivox_action}"));
	return Path;
}

FName FRequest_GetVoipActionTokenMe::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetVoipActionTokenMe::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("vivox_action"), ToStringFormatArg(VivoxAction) },
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/me/voip/vivox:{vivox_action}"), PathParams);

	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("voip_session_type=")) + ToUrlString(VoipSessionType));
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetVoipActionTokenMe::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipActionTokenMe - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipActionTokenMe - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipActionTokenMe - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetVoipActionTokenMe::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetVoipActionTokenMe::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetVoipActionTokenMe::TryGetContentFor200(FRHAPI_VoipTokenResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipActionTokenMe::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipActionTokenMe::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipActionTokenMe::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_VoipTokenResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_VoipTokenResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetVoipActionTokenMe::FResponse_GetVoipActionTokenMe(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetVoipActionTokenMe::Name = TEXT("GetVoipActionTokenMe");

FHttpRequestPtr Traits_GetVoipActionTokenMe::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetVoipActionTokenMe(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::GetVoipLoginToken(const FRequest_GetVoipLoginToken& Request, const FDelegate_GetVoipLoginToken& Delegate /*= FDelegate_GetVoipLoginToken()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetVoipLoginTokenResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnGetVoipLoginTokenResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetVoipLoginToken Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnGetVoipLoginTokenResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetVoipLoginToken> Response = MakeShared<FResponse_GetVoipLoginToken>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetVoipLoginToken::FRequest_GetVoipLoginToken()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetVoipLoginToken::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/voip/vivox:login"));
	return Path;
}

FName FRequest_GetVoipLoginToken::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetVoipLoginToken::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_GetVoipLoginToken::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipLoginToken - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipLoginToken - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetVoipLoginToken - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetVoipLoginToken::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetVoipLoginToken::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetVoipLoginToken::TryGetContentFor200(FRHAPI_VoipTokenResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipLoginToken::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetVoipLoginToken::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_VoipTokenResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_VoipTokenResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetVoipLoginToken::FResponse_GetVoipLoginToken(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetVoipLoginToken::Name = TEXT("GetVoipLoginToken");

FHttpRequestPtr Traits_GetVoipLoginToken::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetVoipLoginToken(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::InstanceHealthCheck(const FRequest_InstanceHealthCheck& Request, const FDelegate_InstanceHealthCheck& Delegate /*= FDelegate_InstanceHealthCheck()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnInstanceHealthCheckResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnInstanceHealthCheckResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_InstanceHealthCheck Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnInstanceHealthCheckResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_InstanceHealthCheck> Response = MakeShared<FResponse_InstanceHealthCheck>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_InstanceHealthCheck::FRequest_InstanceHealthCheck()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_InstanceHealthCheck::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/instance/health"));
	return Path;
}

FName FRequest_InstanceHealthCheck::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_InstanceHealthCheck::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/instance/health"), PathParams);

	return Path;
}

bool FRequest_InstanceHealthCheck::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthCheck - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthCheck - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InstanceHealthStatusUpdate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthCheck - Body parameter (FRHAPI_InstanceHealthStatusUpdate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthCheck - Body parameter (FRHAPI_InstanceHealthStatusUpdate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthCheck - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_InstanceHealthCheck::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_InstanceHealthCheck::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_InstanceHealthCheck::TryGetContentFor200(FRHAPI_InstanceHealthStatusResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InstanceHealthCheck::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InstanceHealthCheck::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InstanceHealthCheck::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InstanceHealthStatusResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InstanceHealthStatusResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_InstanceHealthCheck::FResponse_InstanceHealthCheck(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_InstanceHealthCheck::Name = TEXT("InstanceHealthCheck");

FHttpRequestPtr Traits_InstanceHealthCheck::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->InstanceHealthCheck(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::InstanceHealthConfig(const FRequest_InstanceHealthConfig& Request, const FDelegate_InstanceHealthConfig& Delegate /*= FDelegate_InstanceHealthConfig()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnInstanceHealthConfigResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnInstanceHealthConfigResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_InstanceHealthConfig Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnInstanceHealthConfigResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_InstanceHealthConfig> Response = MakeShared<FResponse_InstanceHealthConfig>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_InstanceHealthConfig::FRequest_InstanceHealthConfig()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_InstanceHealthConfig::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/instance/health/config"));
	return Path;
}

FName FRequest_InstanceHealthConfig::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_InstanceHealthConfig::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_InstanceHealthConfig::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthConfig - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthConfig - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InstanceHealthConfig - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_InstanceHealthConfig::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_InstanceHealthConfig::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_InstanceHealthConfig::TryGetContentFor200(FRHAPI_InstanceHealthSettingsResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InstanceHealthConfig::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InstanceHealthConfig::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InstanceHealthSettingsResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InstanceHealthSettingsResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_InstanceHealthConfig::FResponse_InstanceHealthConfig(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_InstanceHealthConfig::Name = TEXT("InstanceHealthConfig");

FHttpRequestPtr Traits_InstanceHealthConfig::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->InstanceHealthConfig(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::InviteSessionToSession(const FRequest_InviteSessionToSession& Request, const FDelegate_InviteSessionToSession& Delegate /*= FDelegate_InviteSessionToSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnInviteSessionToSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnInviteSessionToSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_InviteSessionToSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnInviteSessionToSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_InviteSessionToSession> Response = MakeShared<FResponse_InviteSessionToSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_InviteSessionToSession::FRequest_InviteSessionToSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_InviteSessionToSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/invited-session/{invited_session_id}:invite"));
	return Path;
}

FName FRequest_InviteSessionToSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_InviteSessionToSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("invited_session_id"), ToStringFormatArg(InvitedSessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/invited-session/{invited_session_id}:invite"), PathParams);

	return Path;
}

bool FRequest_InviteSessionToSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InviteSessionToSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InviteSessionToSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SessionInviteRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InviteSessionToSession - Body parameter (FRHAPI_SessionInviteRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InviteSessionToSession - Body parameter (FRHAPI_SessionInviteRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_InviteSessionToSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_InviteSessionToSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_InviteSessionToSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_InviteSessionToSession::TryGetContentFor200(FRHAPI_SessionInviteResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_InviteSessionToSession::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_InviteSessionToSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InviteSessionToSession::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InviteSessionToSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_InviteSessionToSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionInviteResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionInviteResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_InviteSessionToSession::FResponse_InviteSessionToSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_InviteSessionToSession::Name = TEXT("InviteSessionToSession");

FHttpRequestPtr Traits_InviteSessionToSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->InviteSessionToSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::JoinQueue(const FRequest_JoinQueue& Request, const FDelegate_JoinQueue& Delegate /*= FDelegate_JoinQueue()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinQueueResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnJoinQueueResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_JoinQueue Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinQueueResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_JoinQueue> Response = MakeShared<FResponse_JoinQueue>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_JoinQueue::FRequest_JoinQueue()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_JoinQueue::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/queue"));
	return Path;
}

FName FRequest_JoinQueue::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_JoinQueue::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/queue"), PathParams);

	return Path;
}

bool FRequest_JoinQueue::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinQueue - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinQueue - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, QueueJoinRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinQueue - Body parameter (FRHAPI_QueueJoinRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinQueue - Body parameter (FRHAPI_QueueJoinRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinQueue - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_JoinQueue::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_JoinQueue::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_JoinQueue::TryGetContentFor200(FRHAPI_QueueJoinResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinQueue::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinQueue::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinQueue::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_QueueJoinResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_QueueJoinResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_JoinQueue::FResponse_JoinQueue(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_JoinQueue::Name = TEXT("JoinQueue");

FHttpRequestPtr Traits_JoinQueue::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->JoinQueue(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::JoinSessionByIdSelf(const FRequest_JoinSessionByIdSelf& Request, const FDelegate_JoinSessionByIdSelf& Delegate /*= FDelegate_JoinSessionByIdSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinSessionByIdSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnJoinSessionByIdSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_JoinSessionByIdSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinSessionByIdSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_JoinSessionByIdSelf> Response = MakeShared<FResponse_JoinSessionByIdSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_JoinSessionByIdSelf::FRequest_JoinSessionByIdSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_JoinSessionByIdSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/me"));
	return Path;
}

FName FRequest_JoinSessionByIdSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_JoinSessionByIdSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/me"), PathParams);

	return Path;
}

bool FRequest_JoinSessionByIdSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByIdSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByIdSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SelfSessionPlayerUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByIdSelf - Body parameter (FRHAPI_SelfSessionPlayerUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByIdSelf - Body parameter (FRHAPI_SelfSessionPlayerUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByIdSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_JoinSessionByIdSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_JoinSessionByIdSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_JoinSessionByIdSelf::TryGetContentFor200(FRHAPI_SessionPlayerUpdateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_JoinSessionByIdSelf::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_JoinSessionByIdSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByIdSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByIdSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByIdSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionPlayerUpdateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionPlayerUpdateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_JoinSessionByIdSelf::FResponse_JoinSessionByIdSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_JoinSessionByIdSelf::Name = TEXT("JoinSessionByIdSelf");

FHttpRequestPtr Traits_JoinSessionByIdSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->JoinSessionByIdSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::JoinSessionByPlatformSessionByUuid(const FRequest_JoinSessionByPlatformSessionByUuid& Request, const FDelegate_JoinSessionByPlatformSessionByUuid& Delegate /*= FDelegate_JoinSessionByPlatformSessionByUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinSessionByPlatformSessionByUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnJoinSessionByPlatformSessionByUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_JoinSessionByPlatformSessionByUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinSessionByPlatformSessionByUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_JoinSessionByPlatformSessionByUuid> Response = MakeShared<FResponse_JoinSessionByPlatformSessionByUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_JoinSessionByPlatformSessionByUuid::FRequest_JoinSessionByPlatformSessionByUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_JoinSessionByPlatformSessionByUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/{player_uuid}"));
	return Path;
}

FName FRequest_JoinSessionByPlatformSessionByUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_JoinSessionByPlatformSessionByUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) },
		{ TEXT("platform"), ToStringFormatArg(Platform) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/{player_uuid}"), PathParams);

	TArray<FString> QueryParams;
	if(PlayerId.IsSet())
	{
		QueryParams.Add(FString(TEXT("player_id=")) + ToUrlString(PlayerId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_JoinSessionByPlatformSessionByUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionByUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionByUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SelfSessionPlayerUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionByUuid - Body parameter (FRHAPI_SelfSessionPlayerUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionByUuid - Body parameter (FRHAPI_SelfSessionPlayerUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionByUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_JoinSessionByPlatformSessionByUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 409:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_JoinSessionByPlatformSessionByUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 409:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_JoinSessionByPlatformSessionByUuid::TryGetContentFor200(FRHAPI_Session& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_JoinSessionByPlatformSessionByUuid::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_JoinSessionByPlatformSessionByUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByPlatformSessionByUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByPlatformSessionByUuid::TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 409)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_JoinSessionByPlatformSessionByUuid::GetHeader409_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_JoinSessionByPlatformSessionByUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByPlatformSessionByUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_Session Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_Session>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 409:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_JoinSessionByPlatformSessionByUuid::FResponse_JoinSessionByPlatformSessionByUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_JoinSessionByPlatformSessionByUuid::Name = TEXT("JoinSessionByPlatformSessionByUuid");

FHttpRequestPtr Traits_JoinSessionByPlatformSessionByUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->JoinSessionByPlatformSessionByUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::JoinSessionByPlatformSessionIdSelf(const FRequest_JoinSessionByPlatformSessionIdSelf& Request, const FDelegate_JoinSessionByPlatformSessionIdSelf& Delegate /*= FDelegate_JoinSessionByPlatformSessionIdSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinSessionByPlatformSessionIdSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnJoinSessionByPlatformSessionIdSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_JoinSessionByPlatformSessionIdSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnJoinSessionByPlatformSessionIdSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_JoinSessionByPlatformSessionIdSelf> Response = MakeShared<FResponse_JoinSessionByPlatformSessionIdSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_JoinSessionByPlatformSessionIdSelf::FRequest_JoinSessionByPlatformSessionIdSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_JoinSessionByPlatformSessionIdSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/me"));
	return Path;
}

FName FRequest_JoinSessionByPlatformSessionIdSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_JoinSessionByPlatformSessionIdSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) },
		{ TEXT("platform"), ToStringFormatArg(Platform) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/me"), PathParams);

	return Path;
}

bool FRequest_JoinSessionByPlatformSessionIdSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionIdSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionIdSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SelfSessionPlayerUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionIdSelf - Body parameter (FRHAPI_SelfSessionPlayerUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionIdSelf - Body parameter (FRHAPI_SelfSessionPlayerUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_JoinSessionByPlatformSessionIdSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_JoinSessionByPlatformSessionIdSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 409:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 409:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::TryGetContentFor200(FRHAPI_Session& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_JoinSessionByPlatformSessionIdSelf::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 409)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_JoinSessionByPlatformSessionIdSelf::GetHeader409_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_JoinSessionByPlatformSessionIdSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_Session Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_Session>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 409:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_JoinSessionByPlatformSessionIdSelf::FResponse_JoinSessionByPlatformSessionIdSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_JoinSessionByPlatformSessionIdSelf::Name = TEXT("JoinSessionByPlatformSessionIdSelf");

FHttpRequestPtr Traits_JoinSessionByPlatformSessionIdSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->JoinSessionByPlatformSessionIdSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::KickPlayerFromSessionById(const FRequest_KickPlayerFromSessionById& Request, const FDelegate_KickPlayerFromSessionById& Delegate /*= FDelegate_KickPlayerFromSessionById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickPlayerFromSessionByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnKickPlayerFromSessionByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_KickPlayerFromSessionById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickPlayerFromSessionByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_KickPlayerFromSessionById> Response = MakeShared<FResponse_KickPlayerFromSessionById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_KickPlayerFromSessionById::FRequest_KickPlayerFromSessionById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_KickPlayerFromSessionById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/id/{player_id}"));
	return Path;
}

FName FRequest_KickPlayerFromSessionById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_KickPlayerFromSessionById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/id/{player_id}"), PathParams);

	return Path;
}

bool FRequest_KickPlayerFromSessionById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_KickPlayerFromSessionById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_KickPlayerFromSessionById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_KickPlayerFromSessionById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionById::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_KickPlayerFromSessionById::FResponse_KickPlayerFromSessionById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_KickPlayerFromSessionById::Name = TEXT("KickPlayerFromSessionById");

FHttpRequestPtr Traits_KickPlayerFromSessionById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->KickPlayerFromSessionById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::KickPlayerFromSessionByUuid(const FRequest_KickPlayerFromSessionByUuid& Request, const FDelegate_KickPlayerFromSessionByUuid& Delegate /*= FDelegate_KickPlayerFromSessionByUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickPlayerFromSessionByUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnKickPlayerFromSessionByUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_KickPlayerFromSessionByUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickPlayerFromSessionByUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_KickPlayerFromSessionByUuid> Response = MakeShared<FResponse_KickPlayerFromSessionByUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_KickPlayerFromSessionByUuid::FRequest_KickPlayerFromSessionByUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_KickPlayerFromSessionByUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/uuid/{player_uuid}"));
	return Path;
}

FName FRequest_KickPlayerFromSessionByUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_KickPlayerFromSessionByUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/uuid/{player_uuid}"), PathParams);

	return Path;
}

bool FRequest_KickPlayerFromSessionByUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionByUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionByUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionByUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_KickPlayerFromSessionByUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_KickPlayerFromSessionByUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_KickPlayerFromSessionByUuid::GetHeader204_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_KickPlayerFromSessionByUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionByUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionByUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionByUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_KickPlayerFromSessionByUuid::FResponse_KickPlayerFromSessionByUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_KickPlayerFromSessionByUuid::Name = TEXT("KickPlayerFromSessionByUuid");

FHttpRequestPtr Traits_KickPlayerFromSessionByUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->KickPlayerFromSessionByUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::KickPlayerFromSessionByUuidV2(const FRequest_KickPlayerFromSessionByUuidV2& Request, const FDelegate_KickPlayerFromSessionByUuidV2& Delegate /*= FDelegate_KickPlayerFromSessionByUuidV2()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickPlayerFromSessionByUuidV2Response, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnKickPlayerFromSessionByUuidV2Response(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_KickPlayerFromSessionByUuidV2 Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickPlayerFromSessionByUuidV2Response, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_KickPlayerFromSessionByUuidV2> Response = MakeShared<FResponse_KickPlayerFromSessionByUuidV2>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_KickPlayerFromSessionByUuidV2::FRequest_KickPlayerFromSessionByUuidV2()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_KickPlayerFromSessionByUuidV2::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/{player_uuid}"));
	return Path;
}

FName FRequest_KickPlayerFromSessionByUuidV2::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_KickPlayerFromSessionByUuidV2::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/{player_uuid}"), PathParams);

	return Path;
}

bool FRequest_KickPlayerFromSessionByUuidV2::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionByUuidV2 - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionByUuidV2 - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickPlayerFromSessionByUuidV2 - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_KickPlayerFromSessionByUuidV2::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_KickPlayerFromSessionByUuidV2::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_KickPlayerFromSessionByUuidV2::GetHeader204_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_KickPlayerFromSessionByUuidV2::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionByUuidV2::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionByUuidV2::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickPlayerFromSessionByUuidV2::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_KickPlayerFromSessionByUuidV2::FResponse_KickPlayerFromSessionByUuidV2(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_KickPlayerFromSessionByUuidV2::Name = TEXT("KickPlayerFromSessionByUuidV2");

FHttpRequestPtr Traits_KickPlayerFromSessionByUuidV2::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->KickPlayerFromSessionByUuidV2(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::KickSessionFromSession(const FRequest_KickSessionFromSession& Request, const FDelegate_KickSessionFromSession& Delegate /*= FDelegate_KickSessionFromSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickSessionFromSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnKickSessionFromSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_KickSessionFromSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnKickSessionFromSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_KickSessionFromSession> Response = MakeShared<FResponse_KickSessionFromSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_KickSessionFromSession::FRequest_KickSessionFromSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_KickSessionFromSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/kicked-session/{kicked_session_id}"));
	return Path;
}

FName FRequest_KickSessionFromSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_KickSessionFromSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("kicked_session_id"), ToStringFormatArg(KickedSessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/kicked-session/{kicked_session_id}"), PathParams);

	return Path;
}

bool FRequest_KickSessionFromSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickSessionFromSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickSessionFromSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_KickSessionFromSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_KickSessionFromSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_KickSessionFromSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_KickSessionFromSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickSessionFromSession::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickSessionFromSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_KickSessionFromSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_KickSessionFromSession::FResponse_KickSessionFromSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_KickSessionFromSession::Name = TEXT("KickSessionFromSession");

FHttpRequestPtr Traits_KickSessionFromSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->KickSessionFromSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::LeaveQueue(const FRequest_LeaveQueue& Request, const FDelegate_LeaveQueue& Delegate /*= FDelegate_LeaveQueue()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveQueueResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnLeaveQueueResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_LeaveQueue Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveQueueResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_LeaveQueue> Response = MakeShared<FResponse_LeaveQueue>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_LeaveQueue::FRequest_LeaveQueue()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_LeaveQueue::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/queue"));
	return Path;
}

FName FRequest_LeaveQueue::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_LeaveQueue::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/queue"), PathParams);

	TArray<FString> QueryParams;
	if(Reason.IsSet())
	{
		QueryParams.Add(FString(TEXT("reason=")) + ToUrlString(Reason.GetValue()));
	}
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_LeaveQueue::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveQueue - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveQueue - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveQueue - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_LeaveQueue::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_LeaveQueue::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_LeaveQueue::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveQueue::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveQueue::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveQueue::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_LeaveQueue::FResponse_LeaveQueue(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_LeaveQueue::Name = TEXT("LeaveQueue");

FHttpRequestPtr Traits_LeaveQueue::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->LeaveQueue(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::LeaveSessionByIdSelf(const FRequest_LeaveSessionByIdSelf& Request, const FDelegate_LeaveSessionByIdSelf& Delegate /*= FDelegate_LeaveSessionByIdSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveSessionByIdSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnLeaveSessionByIdSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_LeaveSessionByIdSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveSessionByIdSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_LeaveSessionByIdSelf> Response = MakeShared<FResponse_LeaveSessionByIdSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_LeaveSessionByIdSelf::FRequest_LeaveSessionByIdSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_LeaveSessionByIdSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/me"));
	return Path;
}

FName FRequest_LeaveSessionByIdSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_LeaveSessionByIdSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/me"), PathParams);

	return Path;
}

bool FRequest_LeaveSessionByIdSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByIdSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByIdSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByIdSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_LeaveSessionByIdSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_LeaveSessionByIdSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_LeaveSessionByIdSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByIdSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByIdSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByIdSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_LeaveSessionByIdSelf::FResponse_LeaveSessionByIdSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_LeaveSessionByIdSelf::Name = TEXT("LeaveSessionByIdSelf");

FHttpRequestPtr Traits_LeaveSessionByIdSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->LeaveSessionByIdSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::LeaveSessionByPlatformSessionByUuid(const FRequest_LeaveSessionByPlatformSessionByUuid& Request, const FDelegate_LeaveSessionByPlatformSessionByUuid& Delegate /*= FDelegate_LeaveSessionByPlatformSessionByUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveSessionByPlatformSessionByUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnLeaveSessionByPlatformSessionByUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_LeaveSessionByPlatformSessionByUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveSessionByPlatformSessionByUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_LeaveSessionByPlatformSessionByUuid> Response = MakeShared<FResponse_LeaveSessionByPlatformSessionByUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_LeaveSessionByPlatformSessionByUuid::FRequest_LeaveSessionByPlatformSessionByUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_LeaveSessionByPlatformSessionByUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/{player_uuid}"));
	return Path;
}

FName FRequest_LeaveSessionByPlatformSessionByUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_LeaveSessionByPlatformSessionByUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) },
		{ TEXT("platform"), ToStringFormatArg(Platform) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/{player_uuid}"), PathParams);

	return Path;
}

bool FRequest_LeaveSessionByPlatformSessionByUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByPlatformSessionByUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByPlatformSessionByUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByPlatformSessionByUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_LeaveSessionByPlatformSessionByUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 409:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_LeaveSessionByPlatformSessionByUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 409:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_LeaveSessionByPlatformSessionByUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByPlatformSessionByUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByPlatformSessionByUuid::TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 409)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_LeaveSessionByPlatformSessionByUuid::GetHeader409_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_LeaveSessionByPlatformSessionByUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByPlatformSessionByUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_LeaveSessionByPlatformSessionByUuid::FResponse_LeaveSessionByPlatformSessionByUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_LeaveSessionByPlatformSessionByUuid::Name = TEXT("LeaveSessionByPlatformSessionByUuid");

FHttpRequestPtr Traits_LeaveSessionByPlatformSessionByUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->LeaveSessionByPlatformSessionByUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::LeaveSessionByPlatformSessionSelf(const FRequest_LeaveSessionByPlatformSessionSelf& Request, const FDelegate_LeaveSessionByPlatformSessionSelf& Delegate /*= FDelegate_LeaveSessionByPlatformSessionSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveSessionByPlatformSessionSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnLeaveSessionByPlatformSessionSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_LeaveSessionByPlatformSessionSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnLeaveSessionByPlatformSessionSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_LeaveSessionByPlatformSessionSelf> Response = MakeShared<FResponse_LeaveSessionByPlatformSessionSelf>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_LeaveSessionByPlatformSessionSelf::FRequest_LeaveSessionByPlatformSessionSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_LeaveSessionByPlatformSessionSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/me"));
	return Path;
}

FName FRequest_LeaveSessionByPlatformSessionSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_LeaveSessionByPlatformSessionSelf::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("platform_session_id_base64"), ToStringFormatArg(PlatformSessionIdBase64) },
		{ TEXT("platform"), ToStringFormatArg(Platform) }
	};

	FString Path = FString::Format(TEXT("/session/v1/platform/{platform}/platform-session/{platform_session_id_base64}/player/me"), PathParams);

	return Path;
}

bool FRequest_LeaveSessionByPlatformSessionSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByPlatformSessionSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByPlatformSessionSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_LeaveSessionByPlatformSessionSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_LeaveSessionByPlatformSessionSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("User is not authenticated, or does not have sufficient role access to perform request");
	case 404:
		return TEXT("Platform Session or Platform Player doesn&#39;t exist.  See error code for more info");
	case 409:
		return TEXT("Service was unable to fulfill the request at this time and should be retried after the Retry-After wait time");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_LeaveSessionByPlatformSessionSelf::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 409:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_LeaveSessionByPlatformSessionSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByPlatformSessionSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByPlatformSessionSelf::TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 409)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Number of seconds after which to retry the request */
TOptional<int32> FResponse_LeaveSessionByPlatformSessionSelf::GetHeader409_RetryAfter() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("Retry-After"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<int32>(HeaderVal);
		}
	}
	return 0;
}

bool FResponse_LeaveSessionByPlatformSessionSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_LeaveSessionByPlatformSessionSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_LeaveSessionByPlatformSessionSelf::FResponse_LeaveSessionByPlatformSessionSelf(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_LeaveSessionByPlatformSessionSelf::Name = TEXT("LeaveSessionByPlatformSessionSelf");

FHttpRequestPtr Traits_LeaveSessionByPlatformSessionSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->LeaveSessionByPlatformSessionSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::PostBrowserInfo(const FRequest_PostBrowserInfo& Request, const FDelegate_PostBrowserInfo& Delegate /*= FDelegate_PostBrowserInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnPostBrowserInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnPostBrowserInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PostBrowserInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnPostBrowserInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_PostBrowserInfo> Response = MakeShared<FResponse_PostBrowserInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_PostBrowserInfo::FRequest_PostBrowserInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_PostBrowserInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/browser"));
	return Path;
}

FName FRequest_PostBrowserInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_PostBrowserInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/browser"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_PostBrowserInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PostBrowserInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PostBrowserInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, BrowserInfo);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PostBrowserInfo - Body parameter (FRHAPI_BrowserInfo) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PostBrowserInfo - Body parameter (FRHAPI_BrowserInfo) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_PostBrowserInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_PostBrowserInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_PostBrowserInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_PostBrowserInfo::TryGetContentFor200(FRHAPI_BrowserInfo& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_PostBrowserInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_PostBrowserInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_PostBrowserInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_BrowserInfo Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_BrowserInfo>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_PostBrowserInfo::FResponse_PostBrowserInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_PostBrowserInfo::Name = TEXT("PostBrowserInfo");

FHttpRequestPtr Traits_PostBrowserInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->PostBrowserInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::SwapPlayersInSession(const FRequest_SwapPlayersInSession& Request, const FDelegate_SwapPlayersInSession& Delegate /*= FDelegate_SwapPlayersInSession()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnSwapPlayersInSessionResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnSwapPlayersInSessionResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_SwapPlayersInSession Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnSwapPlayersInSessionResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_SwapPlayersInSession> Response = MakeShared<FResponse_SwapPlayersInSession>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_SwapPlayersInSession::FRequest_SwapPlayersInSession()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_SwapPlayersInSession::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player:swap"));
	return Path;
}

FName FRequest_SwapPlayersInSession::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_SwapPlayersInSession::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player:swap"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_SwapPlayersInSession::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SwapPlayersInSession - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SwapPlayersInSession - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, PlayerSwapRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SwapPlayersInSession - Body parameter (FRHAPI_PlayerSwapRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SwapPlayersInSession - Body parameter (FRHAPI_PlayerSwapRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SwapPlayersInSession - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_SwapPlayersInSession::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_SwapPlayersInSession::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_SwapPlayersInSession::TryGetContentFor200(FRHAPI_SessionPlayersUpdateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_SwapPlayersInSession::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_SwapPlayersInSession::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_SwapPlayersInSession::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_SwapPlayersInSession::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionPlayersUpdateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionPlayersUpdateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_SwapPlayersInSession::FResponse_SwapPlayersInSession(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_SwapPlayersInSession::Name = TEXT("SwapPlayersInSession");

FHttpRequestPtr Traits_SwapPlayersInSession::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->SwapPlayersInSession(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateBackfillRequest(const FRequest_UpdateBackfillRequest& Request, const FDelegate_UpdateBackfillRequest& Delegate /*= FDelegate_UpdateBackfillRequest()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateBackfillRequestResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateBackfillRequestResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateBackfillRequest Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateBackfillRequestResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateBackfillRequest> Response = MakeShared<FResponse_UpdateBackfillRequest>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateBackfillRequest::FRequest_UpdateBackfillRequest()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateBackfillRequest::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/backfill/session/{session_id}"));
	return Path;
}

FName FRequest_UpdateBackfillRequest::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PATCH %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateBackfillRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/backfill/session/{session_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_UpdateBackfillRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBackfillRequest - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBackfillRequest - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, UpdateBackfillRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBackfillRequest - Body parameter (FRHAPI_UpdateBackfillRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBackfillRequest - Body parameter (FRHAPI_UpdateBackfillRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBackfillRequest - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateBackfillRequest::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Backfill resource could not be found on the session, or in the open-match system");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateBackfillRequest::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateBackfillRequest::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateBackfillRequest::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateBackfillRequest::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateBackfillRequest::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_UpdateBackfillRequest::FResponse_UpdateBackfillRequest(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateBackfillRequest::Name = TEXT("UpdateBackfillRequest");

FHttpRequestPtr Traits_UpdateBackfillRequest::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateBackfillRequest(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateBrowserInfo(const FRequest_UpdateBrowserInfo& Request, const FDelegate_UpdateBrowserInfo& Delegate /*= FDelegate_UpdateBrowserInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateBrowserInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateBrowserInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateBrowserInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateBrowserInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateBrowserInfo> Response = MakeShared<FResponse_UpdateBrowserInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateBrowserInfo::FRequest_UpdateBrowserInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateBrowserInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/browser"));
	return Path;
}

FName FRequest_UpdateBrowserInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PATCH %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateBrowserInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/browser"), PathParams);

	return Path;
}

bool FRequest_UpdateBrowserInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBrowserInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBrowserInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, BrowserInfo);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBrowserInfo - Body parameter (FRHAPI_BrowserInfo) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBrowserInfo - Body parameter (FRHAPI_BrowserInfo) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateBrowserInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateBrowserInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateBrowserInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateBrowserInfo::TryGetContentFor200(FRHAPI_BrowserInfo& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateBrowserInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateBrowserInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateBrowserInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_BrowserInfo Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_BrowserInfo>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateBrowserInfo::FResponse_UpdateBrowserInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateBrowserInfo::Name = TEXT("UpdateBrowserInfo");

FHttpRequestPtr Traits_UpdateBrowserInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateBrowserInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateInstanceInfo(const FRequest_UpdateInstanceInfo& Request, const FDelegate_UpdateInstanceInfo& Delegate /*= FDelegate_UpdateInstanceInfo()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateInstanceInfoResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateInstanceInfoResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateInstanceInfo Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateInstanceInfoResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateInstanceInfo> Response = MakeShared<FResponse_UpdateInstanceInfo>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateInstanceInfo::FRequest_UpdateInstanceInfo()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateInstanceInfo::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/instance"));
	return Path;
}

FName FRequest_UpdateInstanceInfo::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PATCH %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateInstanceInfo::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/instance"), PathParams);

	return Path;
}

bool FRequest_UpdateInstanceInfo::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateInstanceInfo - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateInstanceInfo - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, InstanceInfoUpdate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateInstanceInfo - Body parameter (FRHAPI_InstanceInfoUpdate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateInstanceInfo - Body parameter (FRHAPI_InstanceInfoUpdate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateInstanceInfo - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateInstanceInfo::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateInstanceInfo::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateInstanceInfo::TryGetContentFor200(FRHAPI_InstanceInfo& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateInstanceInfo::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateInstanceInfo::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateInstanceInfo::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_InstanceInfo Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_InstanceInfo>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateInstanceInfo::FResponse_UpdateInstanceInfo(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateInstanceInfo::Name = TEXT("UpdateInstanceInfo");

FHttpRequestPtr Traits_UpdateInstanceInfo::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateInstanceInfo(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateSessionById(const FRequest_UpdateSessionById& Request, const FDelegate_UpdateSessionById& Delegate /*= FDelegate_UpdateSessionById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateSessionByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateSessionById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateSessionById> Response = MakeShared<FResponse_UpdateSessionById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateSessionById::FRequest_UpdateSessionById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateSessionById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}"));
	return Path;
}

FName FRequest_UpdateSessionById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PATCH %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateSessionById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}"), PathParams);

	return Path;
}

bool FRequest_UpdateSessionById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SessionUpdate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionById - Body parameter (FRHAPI_SessionUpdate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionById - Body parameter (FRHAPI_SessionUpdate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateSessionById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateSessionById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateSessionById::TryGetContentFor200(FRHAPI_Session& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_UpdateSessionById::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_UpdateSessionById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_Session Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_Session>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateSessionById::FResponse_UpdateSessionById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateSessionById::Name = TEXT("UpdateSessionById");

FHttpRequestPtr Traits_UpdateSessionById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateSessionById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateSessionPlayerById(const FRequest_UpdateSessionPlayerById& Request, const FDelegate_UpdateSessionPlayerById& Delegate /*= FDelegate_UpdateSessionPlayerById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionPlayerByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateSessionPlayerByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateSessionPlayerById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionPlayerByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateSessionPlayerById> Response = MakeShared<FResponse_UpdateSessionPlayerById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateSessionPlayerById::FRequest_UpdateSessionPlayerById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateSessionPlayerById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/id/{player_id}"));
	return Path;
}

FName FRequest_UpdateSessionPlayerById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateSessionPlayerById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("player_id"), ToStringFormatArg(PlayerId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/id/{player_id}"), PathParams);

	return Path;
}

bool FRequest_UpdateSessionPlayerById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SessionPlayerUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerById - Body parameter (FRHAPI_SessionPlayerUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerById - Body parameter (FRHAPI_SessionPlayerUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateSessionPlayerById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateSessionPlayerById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateSessionPlayerById::TryGetContentFor200(FRHAPI_SessionPlayerUpdateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerById::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionPlayerUpdateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionPlayerUpdateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateSessionPlayerById::FResponse_UpdateSessionPlayerById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateSessionPlayerById::Name = TEXT("UpdateSessionPlayerById");

FHttpRequestPtr Traits_UpdateSessionPlayerById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateSessionPlayerById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateSessionPlayerByUuid(const FRequest_UpdateSessionPlayerByUuid& Request, const FDelegate_UpdateSessionPlayerByUuid& Delegate /*= FDelegate_UpdateSessionPlayerByUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionPlayerByUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateSessionPlayerByUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateSessionPlayerByUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionPlayerByUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateSessionPlayerByUuid> Response = MakeShared<FResponse_UpdateSessionPlayerByUuid>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateSessionPlayerByUuid::FRequest_UpdateSessionPlayerByUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateSessionPlayerByUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/uuid/{player_uuid}"));
	return Path;
}

FName FRequest_UpdateSessionPlayerByUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateSessionPlayerByUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/uuid/{player_uuid}"), PathParams);

	return Path;
}

bool FRequest_UpdateSessionPlayerByUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SessionPlayerUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuid - Body parameter (FRHAPI_SessionPlayerUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuid - Body parameter (FRHAPI_SessionPlayerUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateSessionPlayerByUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateSessionPlayerByUuid::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateSessionPlayerByUuid::TryGetContentFor200(FRHAPI_SessionPlayerUpdateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_UpdateSessionPlayerByUuid::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_UpdateSessionPlayerByUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerByUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerByUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerByUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionPlayerUpdateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionPlayerUpdateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateSessionPlayerByUuid::FResponse_UpdateSessionPlayerByUuid(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateSessionPlayerByUuid::Name = TEXT("UpdateSessionPlayerByUuid");

FHttpRequestPtr Traits_UpdateSessionPlayerByUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateSessionPlayerByUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateSessionPlayerByUuidV2(const FRequest_UpdateSessionPlayerByUuidV2& Request, const FDelegate_UpdateSessionPlayerByUuidV2& Delegate /*= FDelegate_UpdateSessionPlayerByUuidV2()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionPlayerByUuidV2Response, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateSessionPlayerByUuidV2Response(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateSessionPlayerByUuidV2 Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateSessionPlayerByUuidV2Response, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateSessionPlayerByUuidV2> Response = MakeShared<FResponse_UpdateSessionPlayerByUuidV2>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateSessionPlayerByUuidV2::FRequest_UpdateSessionPlayerByUuidV2()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateSessionPlayerByUuidV2::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/player/{player_uuid}"));
	return Path;
}

FName FRequest_UpdateSessionPlayerByUuidV2::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateSessionPlayerByUuidV2::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("session_id"), ToStringFormatArg(SessionId) },
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/player/{player_uuid}"), PathParams);

	return Path;
}

bool FRequest_UpdateSessionPlayerByUuidV2::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuidV2 - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuidV2 - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, SessionPlayerUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuidV2 - Body parameter (FRHAPI_SessionPlayerUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuidV2 - Body parameter (FRHAPI_SessionPlayerUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateSessionPlayerByUuidV2 - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateSessionPlayerByUuidV2::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 404:
		return TEXT("Session doesn&#39;t exist or Player is not a member of the session.  See error code for more info");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateSessionPlayerByUuidV2::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateSessionPlayerByUuidV2::TryGetContentFor200(FRHAPI_SessionPlayerUpdateResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_UpdateSessionPlayerByUuidV2::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_UpdateSessionPlayerByUuidV2::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerByUuidV2::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerByUuidV2::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateSessionPlayerByUuidV2::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionPlayerUpdateResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionPlayerUpdateResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateSessionPlayerByUuidV2::FResponse_UpdateSessionPlayerByUuidV2(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateSessionPlayerByUuidV2::Name = TEXT("UpdateSessionPlayerByUuidV2");

FHttpRequestPtr Traits_UpdateSessionPlayerByUuidV2::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateSessionPlayerByUuidV2(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FSessionsAPI::UpdateTeamById(const FRequest_UpdateTeamById& Request, const FDelegate_UpdateTeamById& Delegate /*= FDelegate_UpdateTeamById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateTeamByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FSessionsAPI::OnUpdateTeamByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateTeamById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FSessionsAPI::OnUpdateTeamByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateTeamById> Response = MakeShared<FResponse_UpdateTeamById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateTeamById::FRequest_UpdateTeamById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateTeamById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/session/v1/session/{session_id}/team/{team_id}"));
	return Path;
}

FName FRequest_UpdateTeamById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PATCH %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateTeamById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("team_id"), ToStringFormatArg(TeamId) },
		{ TEXT("session_id"), ToStringFormatArg(SessionId) }
	};

	FString Path = FString::Format(TEXT("/session/v1/session/{session_id}/team/{team_id}"), PathParams);

	TArray<FString> QueryParams;
	if(RefreshTtl.IsSet())
	{
		QueryParams.Add(FString(TEXT("refresh_ttl=")) + ToUrlString(RefreshTtl.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_UpdateTeamById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateTeamById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateTeamById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, TeamUpdate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateTeamById - Body parameter (FRHAPI_TeamUpdate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateTeamById - Body parameter (FRHAPI_TeamUpdate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateTeamById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateTeamById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT("Forbidden");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateTeamById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


#if ALLOW_LEGACY_RESPONSE_CONTENT
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	// parse into default header storage
    if (const FString* Val = HeadersMap.Find(TEXT("ETag")))
    {
        ETag = FromHeaderString<FString>(*Val);
    }
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
#endif

	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateTeamById::TryGetContentFor200(FRHAPI_SessionTeam& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
TOptional<FString> FResponse_UpdateTeamById::GetHeader200_ETag() const
{
	if (HttpResponse)
	{
		FString HeaderVal = HttpResponse->GetHeader(TEXT("ETag"));
		if (!HeaderVal.IsEmpty())
		{
			return FromHeaderString<FString>(HeaderVal);
		}
	}
	return TOptional<FString>{};
}

bool FResponse_UpdateTeamById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateTeamById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateTeamById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SessionTeam Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SessionTeam>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateTeamById::FResponse_UpdateTeamById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateTeamById::Name = TEXT("UpdateTeamById");

FHttpRequestPtr Traits_UpdateTeamById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateTeamById(InRequest, InDelegate, InPriority);
}


}
