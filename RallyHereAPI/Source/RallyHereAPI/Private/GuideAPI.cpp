// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#include "GuideAPI.h"
#include "RallyHereAPIModule.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHttpRequester.h"
#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace RallyHereAPI
{

FGuideAPI::FGuideAPI() : FAPI()
{
	Url = TEXT("https://demo.rally-here.io");
	Name = FName(TEXT("Guide"));
}

FGuideAPI::~FGuideAPI() {}

FHttpRequestPtr FGuideAPI::AddEntityFavoriteGuide(const FRequest_AddEntityFavoriteGuide& Request, const FDelegate_AddEntityFavoriteGuide& Delegate /*= FDelegate_AddEntityFavoriteGuide()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnAddEntityFavoriteGuideResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnAddEntityFavoriteGuideResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_AddEntityFavoriteGuide Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnAddEntityFavoriteGuideResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_AddEntityFavoriteGuide> Response = MakeShared<FResponse_AddEntityFavoriteGuide>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_AddEntityFavoriteGuide::FRequest_AddEntityFavoriteGuide()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_AddEntityFavoriteGuide::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/{entity_type}/{entity_id}/favorite-guide"));
	return Path;
}

FName FRequest_AddEntityFavoriteGuide::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_AddEntityFavoriteGuide::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/{entity_type}/{entity_id}/favorite-guide"), PathParams);

	return Path;
}

bool FRequest_AddEntityFavoriteGuide::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityFavoriteGuide - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityFavoriteGuide - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, FavoriteGuideRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityFavoriteGuide - Body parameter (FRHAPI_FavoriteGuideRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityFavoriteGuide - Body parameter (FRHAPI_FavoriteGuideRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityFavoriteGuide - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_AddEntityFavoriteGuide::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_AddEntityFavoriteGuide::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_AddEntityFavoriteGuide::TryGetContentFor200(FRHAPI_FavoriteGuideResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddEntityFavoriteGuide::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddEntityFavoriteGuide::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddEntityFavoriteGuide::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_FavoriteGuideResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_FavoriteGuideResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_AddEntityFavoriteGuide::FResponse_AddEntityFavoriteGuide(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_AddEntityFavoriteGuide::Name = TEXT("AddEntityFavoriteGuide");

FHttpRequestPtr Traits_AddEntityFavoriteGuide::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->AddEntityFavoriteGuide(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::AddEntityRatingForGuide(const FRequest_AddEntityRatingForGuide& Request, const FDelegate_AddEntityRatingForGuide& Delegate /*= FDelegate_AddEntityRatingForGuide()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnAddEntityRatingForGuideResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnAddEntityRatingForGuideResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_AddEntityRatingForGuide Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnAddEntityRatingForGuideResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_AddEntityRatingForGuide> Response = MakeShared<FResponse_AddEntityRatingForGuide>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_AddEntityRatingForGuide::FRequest_AddEntityRatingForGuide()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_AddEntityRatingForGuide::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/{entity_type}/{entity_id}/rate-guide"));
	return Path;
}

FName FRequest_AddEntityRatingForGuide::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_AddEntityRatingForGuide::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/{entity_type}/{entity_id}/rate-guide"), PathParams);

	return Path;
}

bool FRequest_AddEntityRatingForGuide::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityRatingForGuide - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityRatingForGuide - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, GuideRating);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityRatingForGuide - Body parameter (FRHAPI_GuideRating) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityRatingForGuide - Body parameter (FRHAPI_GuideRating) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_AddEntityRatingForGuide - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_AddEntityRatingForGuide::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_AddEntityRatingForGuide::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_AddEntityRatingForGuide::TryGetContentFor200(FRHAPI_GuideRating& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddEntityRatingForGuide::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddEntityRatingForGuide::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_AddEntityRatingForGuide::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_GuideRating Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_GuideRating>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_AddEntityRatingForGuide::FResponse_AddEntityRatingForGuide(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_AddEntityRatingForGuide::Name = TEXT("AddEntityRatingForGuide");

FHttpRequestPtr Traits_AddEntityRatingForGuide::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->AddEntityRatingForGuide(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::CreateGuide(const FRequest_CreateGuide& Request, const FDelegate_CreateGuide& Delegate /*= FDelegate_CreateGuide()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnCreateGuideResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnCreateGuideResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateGuide Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnCreateGuideResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_CreateGuide> Response = MakeShared<FResponse_CreateGuide>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_CreateGuide::FRequest_CreateGuide()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateGuide::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/guide"));
	return Path;
}

FName FRequest_CreateGuide::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateGuide::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	return Path;
}

bool FRequest_CreateGuide::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateGuide - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateGuide - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, GuideCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateGuide - Body parameter (FRHAPI_GuideCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateGuide - Body parameter (FRHAPI_GuideCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateGuide - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateGuide::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 201:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateGuide::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 201:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_CreateGuide::TryGetContentFor201(FRHAPI_GuideFull& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 201)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateGuide::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateGuide::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateGuide::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 201:
			{
				// parse into the structured data format from the json object
				FRHAPI_GuideFull Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_GuideFull>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateGuide::FResponse_CreateGuide(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_CreateGuide::Name = TEXT("CreateGuide");

FHttpRequestPtr Traits_CreateGuide::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateGuide(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::DeleteGuideById(const FRequest_DeleteGuideById& Request, const FDelegate_DeleteGuideById& Delegate /*= FDelegate_DeleteGuideById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnDeleteGuideByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnDeleteGuideByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_DeleteGuideById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnDeleteGuideByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_DeleteGuideById> Response = MakeShared<FResponse_DeleteGuideById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_DeleteGuideById::FRequest_DeleteGuideById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_DeleteGuideById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/guide/{guide_id}"));
	return Path;
}

FName FRequest_DeleteGuideById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_DeleteGuideById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("guide_id"), ToStringFormatArg(GuideId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/guide/{guide_id}"), PathParams);

	return Path;
}

bool FRequest_DeleteGuideById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteGuideById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteGuideById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_DeleteGuideById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_DeleteGuideById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 404:
		return TEXT(" Error Codes: - &#x60;not_found&#x60; - Object was not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_DeleteGuideById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_DeleteGuideById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteGuideById::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteGuideById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_DeleteGuideById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_DeleteGuideById::FResponse_DeleteGuideById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_DeleteGuideById::Name = TEXT("DeleteGuideById");

FHttpRequestPtr Traits_DeleteGuideById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->DeleteGuideById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::GetEntityFavoriteGuide(const FRequest_GetEntityFavoriteGuide& Request, const FDelegate_GetEntityFavoriteGuide& Delegate /*= FDelegate_GetEntityFavoriteGuide()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnGetEntityFavoriteGuideResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnGetEntityFavoriteGuideResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetEntityFavoriteGuide Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnGetEntityFavoriteGuideResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetEntityFavoriteGuide> Response = MakeShared<FResponse_GetEntityFavoriteGuide>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetEntityFavoriteGuide::FRequest_GetEntityFavoriteGuide()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetEntityFavoriteGuide::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/{entity_type}/{entity_id}/favorite-guide"));
	return Path;
}

FName FRequest_GetEntityFavoriteGuide::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetEntityFavoriteGuide::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/{entity_type}/{entity_id}/favorite-guide"), PathParams);

	TArray<FString> QueryParams;
	if(SortBy.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort_by=")) + CollectionToUrlString_multi(SortBy.GetValue(), TEXT("sort_by")));
	}
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(OwnerEntityType.IsSet())
	{
		QueryParams.Add(FString(TEXT("owner_entity_type=")) + ToUrlString(OwnerEntityType.GetValue()));
	}
	if(OwnerEntityId.IsSet())
	{
		QueryParams.Add(FString(TEXT("owner_entity_id=")) + ToUrlString(OwnerEntityId.GetValue()));
	}
	if(Language.IsSet())
	{
		QueryParams.Add(FString(TEXT("language=")) + ToUrlString(Language.GetValue()));
	}
	if(GuideType.IsSet())
	{
		QueryParams.Add(FString(TEXT("guide_type=")) + ToUrlString(GuideType.GetValue()));
	}
	if(GameVersion.IsSet())
	{
		QueryParams.Add(FString(TEXT("game_version=")) + ToUrlString(GameVersion.GetValue()));
	}
	if(Name.IsSet())
	{
		QueryParams.Add(FString(TEXT("name=")) + ToUrlString(Name.GetValue()));
	}
	if(Ref1.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_1=")) + ToUrlString(Ref1.GetValue()));
	}
	if(Ref2.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_2=")) + ToUrlString(Ref2.GetValue()));
	}
	if(Ref3.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_3=")) + ToUrlString(Ref3.GetValue()));
	}
	if(Ref4.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_4=")) + ToUrlString(Ref4.GetValue()));
	}
	if(Ref5.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_5=")) + ToUrlString(Ref5.GetValue()));
	}
	if(Ref6.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_6=")) + ToUrlString(Ref6.GetValue()));
	}
	if(Ref7.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_7=")) + ToUrlString(Ref7.GetValue()));
	}
	if(Ref8.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_8=")) + ToUrlString(Ref8.GetValue()));
	}
	if(Ref9.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_9=")) + ToUrlString(Ref9.GetValue()));
	}
	if(Ref10.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_10=")) + ToUrlString(Ref10.GetValue()));
	}
	if(Ref11.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_11=")) + ToUrlString(Ref11.GetValue()));
	}
	if(Ref12.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_12=")) + ToUrlString(Ref12.GetValue()));
	}
	if(Ref13.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_13=")) + ToUrlString(Ref13.GetValue()));
	}
	if(Ref14.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_14=")) + ToUrlString(Ref14.GetValue()));
	}
	if(Ref15.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_15=")) + ToUrlString(Ref15.GetValue()));
	}
	if(Ref16.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_16=")) + ToUrlString(Ref16.GetValue()));
	}
	if(Ref17.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_17=")) + ToUrlString(Ref17.GetValue()));
	}
	if(Ref18.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_18=")) + ToUrlString(Ref18.GetValue()));
	}
	if(Ref19.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_19=")) + ToUrlString(Ref19.GetValue()));
	}
	if(Ref20.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_20=")) + ToUrlString(Ref20.GetValue()));
	}
	if(Ref21.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_21=")) + ToUrlString(Ref21.GetValue()));
	}
	if(Ref22.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_22=")) + ToUrlString(Ref22.GetValue()));
	}
	if(Ref23.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_23=")) + ToUrlString(Ref23.GetValue()));
	}
	if(Ref24.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_24=")) + ToUrlString(Ref24.GetValue()));
	}
	if(Ref25.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_25=")) + ToUrlString(Ref25.GetValue()));
	}
	if(Ref26.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_26=")) + ToUrlString(Ref26.GetValue()));
	}
	if(Ref27.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_27=")) + ToUrlString(Ref27.GetValue()));
	}
	if(Ref28.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_28=")) + ToUrlString(Ref28.GetValue()));
	}
	if(Ref29.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_29=")) + ToUrlString(Ref29.GetValue()));
	}
	if(Ref30.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_30=")) + ToUrlString(Ref30.GetValue()));
	}
	if(Ref31.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_31=")) + ToUrlString(Ref31.GetValue()));
	}
	if(Ref32.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_32=")) + ToUrlString(Ref32.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + CollectionToUrlString_multi(Sort.GetValue(), TEXT("sort")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetEntityFavoriteGuide::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityFavoriteGuide - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityFavoriteGuide - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityFavoriteGuide - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetEntityFavoriteGuide::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetEntityFavoriteGuide::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetEntityFavoriteGuide::TryGetContentFor200(FRHAPI_SearchGuideResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityFavoriteGuide::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityFavoriteGuide::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityFavoriteGuide::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SearchGuideResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SearchGuideResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetEntityFavoriteGuide::FResponse_GetEntityFavoriteGuide(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetEntityFavoriteGuide::Name = TEXT("GetEntityFavoriteGuide");

FHttpRequestPtr Traits_GetEntityFavoriteGuide::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetEntityFavoriteGuide(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::GetEntityGuideEngagement(const FRequest_GetEntityGuideEngagement& Request, const FDelegate_GetEntityGuideEngagement& Delegate /*= FDelegate_GetEntityGuideEngagement()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnGetEntityGuideEngagementResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnGetEntityGuideEngagementResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetEntityGuideEngagement Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnGetEntityGuideEngagementResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetEntityGuideEngagement> Response = MakeShared<FResponse_GetEntityGuideEngagement>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetEntityGuideEngagement::FRequest_GetEntityGuideEngagement()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetEntityGuideEngagement::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/{entity_type}/{entity_id}/guide-engagement"));
	return Path;
}

FName FRequest_GetEntityGuideEngagement::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetEntityGuideEngagement::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/{entity_type}/{entity_id}/guide-engagement"), PathParams);

	return Path;
}

bool FRequest_GetEntityGuideEngagement::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityGuideEngagement - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityGuideEngagement - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, ManyEntityGuideEngagementRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityGuideEngagement - Body parameter (FRHAPI_ManyEntityGuideEngagementRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityGuideEngagement - Body parameter (FRHAPI_ManyEntityGuideEngagementRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetEntityGuideEngagement - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetEntityGuideEngagement::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetEntityGuideEngagement::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetEntityGuideEngagement::TryGetContentFor200(FRHAPI_ManyEntityGuideEngagement& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityGuideEngagement::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityGuideEngagement::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetEntityGuideEngagement::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_ManyEntityGuideEngagement Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_ManyEntityGuideEngagement>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetEntityGuideEngagement::FResponse_GetEntityGuideEngagement(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetEntityGuideEngagement::Name = TEXT("GetEntityGuideEngagement");

FHttpRequestPtr Traits_GetEntityGuideEngagement::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetEntityGuideEngagement(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::GetGuideById(const FRequest_GetGuideById& Request, const FDelegate_GetGuideById& Delegate /*= FDelegate_GetGuideById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnGetGuideByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnGetGuideByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetGuideById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnGetGuideByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_GetGuideById> Response = MakeShared<FResponse_GetGuideById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_GetGuideById::FRequest_GetGuideById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetGuideById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/guide/{guide_id}"));
	return Path;
}

FName FRequest_GetGuideById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetGuideById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("guide_id"), ToStringFormatArg(GuideId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/guide/{guide_id}"), PathParams);

	return Path;
}

bool FRequest_GetGuideById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetGuideById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetGuideById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetGuideById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetGuideById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 404:
		return TEXT(" Error Codes: - &#x60;not_found&#x60; - Object was not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetGuideById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 404:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_GetGuideById::TryGetContentFor200(FRHAPI_GuideFull& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetGuideById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetGuideById::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetGuideById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetGuideById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_GuideFull Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_GuideFull>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 404:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetGuideById::FResponse_GetGuideById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_GetGuideById::Name = TEXT("GetGuideById");

FHttpRequestPtr Traits_GetGuideById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetGuideById(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::RemoveEntityFavoriteGuide(const FRequest_RemoveEntityFavoriteGuide& Request, const FDelegate_RemoveEntityFavoriteGuide& Delegate /*= FDelegate_RemoveEntityFavoriteGuide()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnRemoveEntityFavoriteGuideResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnRemoveEntityFavoriteGuideResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_RemoveEntityFavoriteGuide Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnRemoveEntityFavoriteGuideResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_RemoveEntityFavoriteGuide> Response = MakeShared<FResponse_RemoveEntityFavoriteGuide>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_RemoveEntityFavoriteGuide::FRequest_RemoveEntityFavoriteGuide()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_RemoveEntityFavoriteGuide::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/{entity_type}/{entity_id}/favorite-guide/{guide_id}"));
	return Path;
}

FName FRequest_RemoveEntityFavoriteGuide::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("DELETE %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_RemoveEntityFavoriteGuide::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("entity_type"), ToStringFormatArg(EntityType) },
		{ TEXT("entity_id"), ToStringFormatArg(EntityId) },
		{ TEXT("guide_id"), ToStringFormatArg(GuideId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/{entity_type}/{entity_id}/favorite-guide/{guide_id}"), PathParams);

	return Path;
}

bool FRequest_RemoveEntityFavoriteGuide::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_RemoveEntityFavoriteGuide - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_RemoveEntityFavoriteGuide - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_RemoveEntityFavoriteGuide - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_RemoveEntityFavoriteGuide::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 204:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_RemoveEntityFavoriteGuide::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 204:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_RemoveEntityFavoriteGuide::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_RemoveEntityFavoriteGuide::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_RemoveEntityFavoriteGuide::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	return true;
}

FResponse_RemoveEntityFavoriteGuide::FResponse_RemoveEntityFavoriteGuide(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_RemoveEntityFavoriteGuide::Name = TEXT("RemoveEntityFavoriteGuide");

FHttpRequestPtr Traits_RemoveEntityFavoriteGuide::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->RemoveEntityFavoriteGuide(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::SearchGuides(const FRequest_SearchGuides& Request, const FDelegate_SearchGuides& Delegate /*= FDelegate_SearchGuides()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnSearchGuidesResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnSearchGuidesResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_SearchGuides Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnSearchGuidesResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_SearchGuides> Response = MakeShared<FResponse_SearchGuides>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_SearchGuides::FRequest_SearchGuides()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_SearchGuides::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/guide"));
	return Path;
}

FName FRequest_SearchGuides::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_SearchGuides::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(SortBy.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort_by=")) + CollectionToUrlString_multi(SortBy.GetValue(), TEXT("sort_by")));
	}
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(OwnerEntityType.IsSet())
	{
		QueryParams.Add(FString(TEXT("owner_entity_type=")) + ToUrlString(OwnerEntityType.GetValue()));
	}
	if(OwnerEntityId.IsSet())
	{
		QueryParams.Add(FString(TEXT("owner_entity_id=")) + ToUrlString(OwnerEntityId.GetValue()));
	}
	if(Language.IsSet())
	{
		QueryParams.Add(FString(TEXT("language=")) + ToUrlString(Language.GetValue()));
	}
	if(GuideType.IsSet())
	{
		QueryParams.Add(FString(TEXT("guide_type=")) + ToUrlString(GuideType.GetValue()));
	}
	if(GameVersion.IsSet())
	{
		QueryParams.Add(FString(TEXT("game_version=")) + ToUrlString(GameVersion.GetValue()));
	}
	if(Name.IsSet())
	{
		QueryParams.Add(FString(TEXT("name=")) + ToUrlString(Name.GetValue()));
	}
	if(Ref1.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_1=")) + ToUrlString(Ref1.GetValue()));
	}
	if(Ref2.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_2=")) + ToUrlString(Ref2.GetValue()));
	}
	if(Ref3.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_3=")) + ToUrlString(Ref3.GetValue()));
	}
	if(Ref4.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_4=")) + ToUrlString(Ref4.GetValue()));
	}
	if(Ref5.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_5=")) + ToUrlString(Ref5.GetValue()));
	}
	if(Ref6.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_6=")) + ToUrlString(Ref6.GetValue()));
	}
	if(Ref7.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_7=")) + ToUrlString(Ref7.GetValue()));
	}
	if(Ref8.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_8=")) + ToUrlString(Ref8.GetValue()));
	}
	if(Ref9.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_9=")) + ToUrlString(Ref9.GetValue()));
	}
	if(Ref10.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_10=")) + ToUrlString(Ref10.GetValue()));
	}
	if(Ref11.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_11=")) + ToUrlString(Ref11.GetValue()));
	}
	if(Ref12.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_12=")) + ToUrlString(Ref12.GetValue()));
	}
	if(Ref13.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_13=")) + ToUrlString(Ref13.GetValue()));
	}
	if(Ref14.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_14=")) + ToUrlString(Ref14.GetValue()));
	}
	if(Ref15.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_15=")) + ToUrlString(Ref15.GetValue()));
	}
	if(Ref16.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_16=")) + ToUrlString(Ref16.GetValue()));
	}
	if(Ref17.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_17=")) + ToUrlString(Ref17.GetValue()));
	}
	if(Ref18.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_18=")) + ToUrlString(Ref18.GetValue()));
	}
	if(Ref19.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_19=")) + ToUrlString(Ref19.GetValue()));
	}
	if(Ref20.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_20=")) + ToUrlString(Ref20.GetValue()));
	}
	if(Ref21.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_21=")) + ToUrlString(Ref21.GetValue()));
	}
	if(Ref22.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_22=")) + ToUrlString(Ref22.GetValue()));
	}
	if(Ref23.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_23=")) + ToUrlString(Ref23.GetValue()));
	}
	if(Ref24.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_24=")) + ToUrlString(Ref24.GetValue()));
	}
	if(Ref25.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_25=")) + ToUrlString(Ref25.GetValue()));
	}
	if(Ref26.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_26=")) + ToUrlString(Ref26.GetValue()));
	}
	if(Ref27.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_27=")) + ToUrlString(Ref27.GetValue()));
	}
	if(Ref28.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_28=")) + ToUrlString(Ref28.GetValue()));
	}
	if(Ref29.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_29=")) + ToUrlString(Ref29.GetValue()));
	}
	if(Ref30.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_30=")) + ToUrlString(Ref30.GetValue()));
	}
	if(Ref31.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_31=")) + ToUrlString(Ref31.GetValue()));
	}
	if(Ref32.IsSet())
	{
		QueryParams.Add(FString(TEXT("ref_32=")) + ToUrlString(Ref32.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + CollectionToUrlString_multi(Sort.GetValue(), TEXT("sort")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_SearchGuides::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SearchGuides - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SearchGuides - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_SearchGuides - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_SearchGuides::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_SearchGuides::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_SearchGuides::TryGetContentFor200(FRHAPI_SearchGuideResponse& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_SearchGuides::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_SearchGuides::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_SearchGuides::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_SearchGuideResponse Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_SearchGuideResponse>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_SearchGuides::FResponse_SearchGuides(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_SearchGuides::Name = TEXT("SearchGuides");

FHttpRequestPtr Traits_SearchGuides::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->SearchGuides(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FGuideAPI::UpdateGuideById(const FRequest_UpdateGuideById& Request, const FDelegate_UpdateGuideById& Delegate /*= FDelegate_UpdateGuideById()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FGuideAPI::OnUpdateGuideByIdResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FGuideAPI::OnUpdateGuideByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_UpdateGuideById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FGuideAPI::OnUpdateGuideByIdResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	TSharedRef<FResponse_UpdateGuideById> Response = MakeShared<FResponse_UpdateGuideById>(RequestMetadata);
	
	auto CompletionDelegate = FSimpleDelegate::CreateLambda([Delegate, Response]()
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response.Get());
	});
	
	HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, CompletionDelegate, RequestMetadata, Priority);
}

FRequest_UpdateGuideById::FRequest_UpdateGuideById()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_UpdateGuideById::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/guide/v1/guide/{guide_id}"));
	return Path;
}

FName FRequest_UpdateGuideById::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("PUT %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_UpdateGuideById::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("guide_id"), ToStringFormatArg(GuideId) }
	};

	FString Path = FString::Format(TEXT("/guide/v1/guide/{guide_id}"), PathParams);

	return Path;
}

bool FRequest_UpdateGuideById::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PUT"));

	// check the pending flags, as the metadata has not been updated with it yet (it is updated after the http request is fully created)
	if (!AuthContext && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateGuideById - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !PendingMetadataFlags.bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateGuideById - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, GuideCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateGuideById - Body parameter (FRHAPI_GuideCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateGuideById - Body parameter (FRHAPI_GuideCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_UpdateGuideById - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_UpdateGuideById::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - &#x60;auth_invalid_key_id&#x60; - Invalid Authorization - Invalid Key ID in Access Token - &#x60;auth_invalid_version&#x60; - Invalid Authorization - version - &#x60;auth_malformed_access&#x60; - Invalid Authorization - malformed access token - &#x60;auth_not_jwt&#x60; - Invalid Authorization - &#x60;auth_token_expired&#x60; - Token is expired - &#x60;auth_token_format&#x60; - Invalid Authorization - {} - &#x60;auth_token_invalid_claim&#x60; - Token contained invalid claim value: {} - &#x60;auth_token_invalid_type&#x60; - Invalid Authorization - Invalid Token Type - &#x60;auth_token_sig_invalid&#x60; - Token Signature is invalid - &#x60;auth_token_unknown&#x60; - Failed to parse token - &#x60;insufficient_permissions&#x60; - Insufficient Permissions ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_UpdateGuideById::ParseHeaders()
{
	if (!Super::ParseHeaders())
	{
		return false;
	}


	// determine if all required headers were parsed
	bool bParsedAllRequiredHeaders = true;
	switch ((int)GetHttpResponseCode())
	{
	case 200:
		break;
	case 403:
		break;
	case 422:
		break;
	default:
		break;
	}
	
	return bParsedAllRequiredHeaders;
}

bool FResponse_UpdateGuideById::TryGetContentFor200(FRHAPI_GuideFull& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateGuideById::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateGuideById::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_UpdateGuideById::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				// parse into the structured data format from the json object
				FRHAPI_GuideFull Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_GuideFull>(Object);
				break;
			} 
		case 403:
			{
				// parse into the structured data format from the json object
				FRHAPI_HzApiErrorModel Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
				break;
			} 
		case 422:
			{
				// parse into the structured data format from the json object
				FRHAPI_HTTPValidationError Object;
				bParsed = TryGetJsonValue(JsonValue, Object);
				
				// even if parsing encountered errors, set the object in case parsing was partially successful
				ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_UpdateGuideById::FResponse_UpdateGuideById(FRequestMetadata InRequestMetadata)
	: Super(MoveTemp(InRequestMetadata))
{
}

FString Traits_UpdateGuideById::Name = TEXT("UpdateGuideById");

FHttpRequestPtr Traits_UpdateGuideById::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->UpdateGuideById(InRequest, InDelegate, InPriority);
}


}
