// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#include "ReportsAPI.h"
#include "RallyHereAPIModule.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHttpRequester.h"
#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"

namespace RallyHereAPI
{

FReportsAPI::FReportsAPI() : FAPI()
{
	Url = TEXT("https://demo.rally-here.io");
	Name = FName(TEXT("Reports"));
}

FReportsAPI::~FReportsAPI() {}

FHttpRequestPtr FReportsAPI::CreateReportForTargetPlayerUuid(const FRequest_CreateReportForTargetPlayerUuid& Request, const FDelegate_CreateReportForTargetPlayerUuid& Delegate /*= FDelegate_CreateReportForTargetPlayerUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FReportsAPI::OnCreateReportForTargetPlayerUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FReportsAPI::OnCreateReportForTargetPlayerUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_CreateReportForTargetPlayerUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FReportsAPI::OnCreateReportForTargetPlayerUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_CreateReportForTargetPlayerUuid Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_CreateReportForTargetPlayerUuid::FRequest_CreateReportForTargetPlayerUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_CreateReportForTargetPlayerUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/sanctions/v2/player/{player_uuid}/reports"));
	return Path;
}

FName FRequest_CreateReportForTargetPlayerUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("POST %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_CreateReportForTargetPlayerUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/sanctions/v2/player/{player_uuid}/reports"), PathParams);

	return Path;
}

bool FRequest_CreateReportForTargetPlayerUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateReportForTargetPlayerUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateReportForTargetPlayerUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
		// Body parameters
		FString JsonBody;
		TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, PlayerReportCreate);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateReportForTargetPlayerUuid - Body parameter (FRHAPI_PlayerReportCreate) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateReportForTargetPlayerUuid - Body parameter (FRHAPI_PlayerReportCreate) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_CreateReportForTargetPlayerUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_CreateReportForTargetPlayerUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 400:
		return TEXT(" Error Codes: - source_player_required - Source Player must be provided in request or with a user token ");
	case 403:
		return TEXT(" Error Codes: - insufficient_permissions - Insufficient Permissions - auth_malformed_access - Invalid Authorization - malformed access token - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_token_format - Invalid Authorization - {} - auth_not_jwt - Invalid Authorization - auth_invalid_version - Invalid Authorization - version - auth_token_expired - Token is expired - auth_token_sig_invalid - Token Signature is invalid - auth_token_unknown - Failed to parse token - auth_token_invalid_claim - Token contained invalid claim value: {} ");
	case 404:
		return TEXT(" Error Codes: - player_not_found - Player {id} not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_CreateReportForTargetPlayerUuid::TryGetContentFor200(FRHAPI_PlayerReport& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateReportForTargetPlayerUuid::TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 400)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateReportForTargetPlayerUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateReportForTargetPlayerUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateReportForTargetPlayerUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_CreateReportForTargetPlayerUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_PlayerReport Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_PlayerReport>(Object);
					bParsed = true;
				}
				break;
			} 
		case 400:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 404:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_CreateReportForTargetPlayerUuid::FResponse_CreateReportForTargetPlayerUuid(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_CreateReportForTargetPlayerUuid::Name = TEXT("CreateReportForTargetPlayerUuid");

FHttpRequestPtr Traits_CreateReportForTargetPlayerUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->CreateReportForTargetPlayerUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FReportsAPI::GetReportsForTargetPlayerUuid(const FRequest_GetReportsForTargetPlayerUuid& Request, const FDelegate_GetReportsForTargetPlayerUuid& Delegate /*= FDelegate_GetReportsForTargetPlayerUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsForTargetPlayerUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FReportsAPI::OnGetReportsForTargetPlayerUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetReportsForTargetPlayerUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsForTargetPlayerUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetReportsForTargetPlayerUuid Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetReportsForTargetPlayerUuid::FRequest_GetReportsForTargetPlayerUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetReportsForTargetPlayerUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/sanctions/v2/player/{player_uuid}/reports"));
	return Path;
}

FName FRequest_GetReportsForTargetPlayerUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetReportsForTargetPlayerUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/sanctions/v2/player/{player_uuid}/reports"), PathParams);

	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetReportsForTargetPlayerUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsForTargetPlayerUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsForTargetPlayerUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsForTargetPlayerUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetReportsForTargetPlayerUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - insufficient_permissions - Insufficient Permissions - auth_malformed_access - Invalid Authorization - malformed access token - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_token_format - Invalid Authorization - {} - auth_not_jwt - Invalid Authorization - auth_invalid_version - Invalid Authorization - version - auth_token_expired - Token is expired - auth_token_sig_invalid - Token Signature is invalid - auth_token_unknown - Failed to parse token - auth_token_invalid_claim - Token contained invalid claim value: {} ");
	case 404:
		return TEXT(" Error Codes: - player_not_found - Player {id} not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetReportsForTargetPlayerUuid::TryGetContentFor200(FRHAPI_PlayerReportList& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_PlayerReportList Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_PlayerReportList>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 404:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetReportsForTargetPlayerUuid::FResponse_GetReportsForTargetPlayerUuid(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_GetReportsForTargetPlayerUuid::Name = TEXT("GetReportsForTargetPlayerUuid");

FHttpRequestPtr Traits_GetReportsForTargetPlayerUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetReportsForTargetPlayerUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FReportsAPI::GetReportsForTargetPlayerUuidSelf(const FRequest_GetReportsForTargetPlayerUuidSelf& Request, const FDelegate_GetReportsForTargetPlayerUuidSelf& Delegate /*= FDelegate_GetReportsForTargetPlayerUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsForTargetPlayerUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FReportsAPI::OnGetReportsForTargetPlayerUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetReportsForTargetPlayerUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsForTargetPlayerUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetReportsForTargetPlayerUuidSelf Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetReportsForTargetPlayerUuidSelf::FRequest_GetReportsForTargetPlayerUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetReportsForTargetPlayerUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/sanctions/v2/player/me/reports"));
	return Path;
}

FName FRequest_GetReportsForTargetPlayerUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetReportsForTargetPlayerUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetReportsForTargetPlayerUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsForTargetPlayerUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsForTargetPlayerUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsForTargetPlayerUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetReportsForTargetPlayerUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - insufficient_permissions - Insufficient Permissions - auth_malformed_access - Invalid Authorization - malformed access token - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_token_format - Invalid Authorization - {} - auth_not_jwt - Invalid Authorization - auth_invalid_version - Invalid Authorization - version - auth_token_expired - Token is expired - auth_token_sig_invalid - Token Signature is invalid - auth_token_unknown - Failed to parse token - auth_token_invalid_claim - Token contained invalid claim value: {} ");
	case 404:
		return TEXT(" Error Codes: - player_not_found - Player {id} not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetReportsForTargetPlayerUuidSelf::TryGetContentFor200(FRHAPI_PlayerReportList& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuidSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsForTargetPlayerUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_PlayerReportList Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_PlayerReportList>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 404:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetReportsForTargetPlayerUuidSelf::FResponse_GetReportsForTargetPlayerUuidSelf(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_GetReportsForTargetPlayerUuidSelf::Name = TEXT("GetReportsForTargetPlayerUuidSelf");

FHttpRequestPtr Traits_GetReportsForTargetPlayerUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetReportsForTargetPlayerUuidSelf(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FReportsAPI::GetReportsFromSourcePlayerUuid(const FRequest_GetReportsFromSourcePlayerUuid& Request, const FDelegate_GetReportsFromSourcePlayerUuid& Delegate /*= FDelegate_GetReportsFromSourcePlayerUuid()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsFromSourcePlayerUuidResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FReportsAPI::OnGetReportsFromSourcePlayerUuidResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetReportsFromSourcePlayerUuid Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsFromSourcePlayerUuidResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetReportsFromSourcePlayerUuid Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetReportsFromSourcePlayerUuid::FRequest_GetReportsFromSourcePlayerUuid()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetReportsFromSourcePlayerUuid::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/sanctions/v2/player/{player_uuid}/sent-reports"));
	return Path;
}

FName FRequest_GetReportsFromSourcePlayerUuid::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetReportsFromSourcePlayerUuid::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
		{ TEXT("player_uuid"), ToStringFormatArg(PlayerUuid) }
	};

	FString Path = FString::Format(TEXT("/sanctions/v2/player/{player_uuid}/sent-reports"), PathParams);

	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetReportsFromSourcePlayerUuid::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsFromSourcePlayerUuid - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsFromSourcePlayerUuid - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsFromSourcePlayerUuid - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetReportsFromSourcePlayerUuid::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - insufficient_permissions - Insufficient Permissions - auth_malformed_access - Invalid Authorization - malformed access token - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_token_format - Invalid Authorization - {} - auth_not_jwt - Invalid Authorization - auth_invalid_version - Invalid Authorization - version - auth_token_expired - Token is expired - auth_token_sig_invalid - Token Signature is invalid - auth_token_unknown - Failed to parse token - auth_token_invalid_claim - Token contained invalid claim value: {} ");
	case 404:
		return TEXT(" Error Codes: - player_not_found - Player {id} not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetReportsFromSourcePlayerUuid::TryGetContentFor200(FRHAPI_PlayerReportList& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuid::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuid::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuid::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuid::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_PlayerReportList Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_PlayerReportList>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 404:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetReportsFromSourcePlayerUuid::FResponse_GetReportsFromSourcePlayerUuid(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_GetReportsFromSourcePlayerUuid::Name = TEXT("GetReportsFromSourcePlayerUuid");

FHttpRequestPtr Traits_GetReportsFromSourcePlayerUuid::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetReportsFromSourcePlayerUuid(InRequest, InDelegate, InPriority);
}

FHttpRequestPtr FReportsAPI::GetReportsFromSourcePlayerUuidSelf(const FRequest_GetReportsFromSourcePlayerUuidSelf& Request, const FDelegate_GetReportsFromSourcePlayerUuidSelf& Delegate /*= FDelegate_GetReportsFromSourcePlayerUuidSelf()*/, int32 Priority /*= DefaultRallyHereAPIPriority*/)
{
	if (!IsValid())
		return nullptr;

	// create the http request and tracking structure
	TSharedPtr<FRallyHereAPIHttpRequestData> RequestData = MakeShared<FRallyHereAPIHttpRequestData>(CreateHttpRequest(Request), AsShared(), Priority);
	RequestData->HttpRequest->SetURL(*(Url + Request.ComputePath()));

	// add headers to tracker
	for(const auto& It : AdditionalHeaderParams)
	{
		RequestData->HttpRequest->SetHeader(It.Key, It.Value);
	}

	// setup http request from custom request object
	if (!Request.SetupHttpRequest(RequestData->HttpRequest))
	{
		return nullptr;
	}
	
	// allow a delegate to modify the http request (such as binding custom handling delegates)
	Request.OnModifyRequest().Broadcast(Request, RequestData->HttpRequest);
	
	// update request metadata flags just before we store it in the tracking object
	FRequestMetadata Metadata = Request.GetRequestMetadata();
	Request.SetMetadataFlags(Metadata);

	// store metadata in tracking object (last place used by request)
	RequestData->SetMetadata(Metadata);

	// bind response handler
	FHttpRequestCompleteDelegate ResponseDelegate;
	ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsFromSourcePlayerUuidSelfResponse, Delegate, RequestData->Metadata, Request.GetAuthContext(), Priority);
	RequestData->SetDelegate(ResponseDelegate);

	// submit request to http system
	auto* HttpRequester = FRallyHereAPIHttpRequester::Get();
	if (HttpRequester)
	{
		HttpRequester->EnqueueHttpRequest(RequestData);
	}
	return RequestData->HttpRequest;
}

void FReportsAPI::OnGetReportsFromSourcePlayerUuidSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetReportsFromSourcePlayerUuidSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority)
{
	FHttpRequestCompleteDelegate ResponseDelegate;

	if (AuthContextForRetry)
	{
		// An included auth context indicates we should auth-retry this request, we only want to do that at most once per call.
		// So, we set the callback to use a null context for the retry
		ResponseDelegate.BindSP(this, &FReportsAPI::OnGetReportsFromSourcePlayerUuidSelfResponse, Delegate, RequestMetadata, TSharedPtr<FAuthContext>(), Priority);
	}

	FResponse_GetReportsFromSourcePlayerUuidSelf Response{ RequestMetadata };
	const bool bWillRetryWithRefreshedAuth = HandleResponse(HttpRequest, HttpResponse, bSucceeded, AuthContextForRetry, Response, ResponseDelegate, RequestMetadata, Priority);

	{
		SCOPED_NAMED_EVENT(RallyHere_BroadcastRequestCompleted, FColor::Purple);
		OnRequestCompleted().Broadcast(Response, HttpRequest, HttpResponse, bSucceeded, bWillRetryWithRefreshedAuth);
	}

	if (!bWillRetryWithRefreshedAuth)
	{
		SCOPED_NAMED_EVENT(RallyHere_ExecuteDelegate, FColor::Purple);
		Delegate.ExecuteIfBound(Response);
	}
}

FRequest_GetReportsFromSourcePlayerUuidSelf::FRequest_GetReportsFromSourcePlayerUuidSelf()
	: FRequest()
{
	RequestMetadata.SimplifiedPath = GetSimplifiedPath();
	RequestMetadata.SimplifiedPathWithVerb = GetSimplifiedPathWithVerb();
}

FName FRequest_GetReportsFromSourcePlayerUuidSelf::GetSimplifiedPath() const
{
	static FName Path = FName(TEXT("/sanctions/v2/player/me/sent-reports"));
	return Path;
}

FName FRequest_GetReportsFromSourcePlayerUuidSelf::GetSimplifiedPathWithVerb() const
{
	static FName PathWithVerb = FName(*FString::Printf(TEXT("GET %s"), *GetSimplifiedPath().ToString()));
	return PathWithVerb;
}

FString FRequest_GetReportsFromSourcePlayerUuidSelf::ComputePath() const
{
	FString Path = GetSimplifiedPath().ToString();
	TArray<FString> QueryParams;
	if(Cursor.IsSet())
	{
		QueryParams.Add(FString(TEXT("cursor=")) + ToUrlString(Cursor.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

bool FRequest_GetReportsFromSourcePlayerUuidSelf::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	if (!AuthContext && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsFromSourcePlayerUuidSelf - missing auth context"));
		return false;
	}
	if (AuthContext && !AuthContext->AddBearerToken(HttpRequest) && !bDisableAuthRequirement)
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsFromSourcePlayerUuidSelf - failed to add bearer token"));
		return false;
	}

	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json"))) // Default to Json Body request
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogRallyHereAPI, Error, TEXT("FRequest_GetReportsFromSourcePlayerUuidSelf - Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
		return false;
	}

	return true;
}

FString FResponse_GetReportsFromSourcePlayerUuidSelf::GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const
{
	switch ((int)InHttpResponseCode)
	{
	case 200:
		return TEXT("Successful Response");
	case 403:
		return TEXT(" Error Codes: - insufficient_permissions - Insufficient Permissions - auth_malformed_access - Invalid Authorization - malformed access token - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_token_format - Invalid Authorization - {} - auth_not_jwt - Invalid Authorization - auth_invalid_version - Invalid Authorization - version - auth_token_expired - Token is expired - auth_token_sig_invalid - Token Signature is invalid - auth_token_unknown - Failed to parse token - auth_token_invalid_claim - Token contained invalid claim value: {} ");
	case 404:
		return TEXT(" Error Codes: - player_not_found - Player {id} not found ");
	case 422:
		return TEXT("Validation Error");
	}
	
	return FResponse::GetHttpResponseCodeDescription(InHttpResponseCode);
}

bool FResponse_GetReportsFromSourcePlayerUuidSelf::TryGetContentFor200(FRHAPI_PlayerReportList& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 200)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuidSelf::TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 403)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuidSelf::TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 404)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuidSelf::TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const
{
	// if this is not the correct response code, fail quickly.
	if ((int)GetHttpResponseCode() != 422)
	{
		return false;
	}

	// forward on to type only handler
	return TryGetContent(OutContent);
}

bool FResponse_GetReportsFromSourcePlayerUuidSelf::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	bool bParsed = false;
	// for non default responses, parse into a temporary object to validate the response can be parsed properly
	switch ((int)GetHttpResponseCode())
	{  
		case 200:
			{
				FRHAPI_PlayerReportList Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_PlayerReportList>(Object);
					bParsed = true;
				}
				break;
			} 
		case 403:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 404:
			{
				FRHAPI_HzApiErrorModel Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HzApiErrorModel>(Object);
					bParsed = true;
				}
				break;
			} 
		case 422:
			{
				FRHAPI_HTTPValidationError Object;
				if (TryGetJsonValue(JsonValue, Object))
				{
					ParsedContent.Set<FRHAPI_HTTPValidationError>(Object);
					bParsed = true;
				}
				break;
			}
		default:
			break;
	}

#if ALLOW_LEGACY_RESPONSE_CONTENT
	// if using legacy content object, attempt to parse any response into the main content object.  For some legacy reasons around multiple success variants, this needs to ignore the intended type and always parse into the default type
	PRAGMA_DISABLE_DEPRECATION_WARNINGS;
	TryGetJsonValue(JsonValue, Content);
	PRAGMA_ENABLE_DEPRECATION_WARNINGS;
#endif

	return bParsed;
}

FResponse_GetReportsFromSourcePlayerUuidSelf::FResponse_GetReportsFromSourcePlayerUuidSelf(FRequestMetadata InRequestMetadata) :
	FResponse(MoveTemp(InRequestMetadata))
	, ParsedContent()
{
}

FString Traits_GetReportsFromSourcePlayerUuidSelf::Name = TEXT("GetReportsFromSourcePlayerUuidSelf");

FHttpRequestPtr Traits_GetReportsFromSourcePlayerUuidSelf::DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate, int32 InPriority)
{
	return InAPI->GetReportsFromSourcePlayerUuidSelf(InRequest, InDelegate, InPriority);
}


}
