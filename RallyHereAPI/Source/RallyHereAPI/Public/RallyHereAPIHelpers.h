// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "RallyHereAPIBaseModel.h"
#include "Serialization/JsonSerializer.h"
#include "Dom/JsonObject.h"
#include "Misc/Base64.h"
#include "Misc/TVariant.h"
#include "PlatformHttp.h"
#include "Containers/Set.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "RallyHereAPIHelpers.generated.h"

struct FRHAPI_JsonValue;
class IHttpRequest;

constexpr int32 DefaultRallyHereAPIPriority = 1000000;

UENUM(BlueprintType)
enum class ERHAPI_JsonValueType : uint8
{
	None,
	Null,
	String,
	Number,
	Boolean,
	Array,
	Object
};

// forward declare both json types since they can reference each other
struct FRHAPI_JsonObject;
struct FRHAPI_JsonValue;

USTRUCT(BlueprintType)
struct RALLYHEREAPI_API FRHAPI_JsonObject
{
	GENERATED_BODY()
public:
	FRHAPI_JsonObject() { SetObject(MakeShareable(new FJsonObject())); }
	FRHAPI_JsonObject(TSharedPtr<FJsonObject> InObj){ SetObject(InObj); }
	
	static FRHAPI_JsonObject CreateFromUnrealObject(TSharedPtr<FJsonObject> NewObj) { return FRHAPI_JsonObject(NewObj); }

	FRHAPI_JsonValue TryGetValue(const FString& FieldName) const;

	bool HasField(const FString& FieldName) const;
	void SetField(const FString& FieldName, const FRHAPI_JsonValue& Value) const;
	void RemoveField(const FString& FieldName) const;

	float GetNumberField(const FString& FieldName) const;
	bool TryGetNumberField(const FString& FieldName, float& OutNumber) const;
	void SetNumberField(const FString& FieldName, float Number) const;
	
	bool TryGetIntegerField(const FString& FieldName, int32& OutNumber) const;
	bool TryGetInteger64Field(const FString& FieldName, int64& OutNumber) const;

	// deprecated functions that used improper naming
	UE_DEPRECATED(5.0, "Please use the GetNumberField() instead")
	float GetFloatField(const FString& FieldName) const { return GetNumberField(FieldName); }
	UE_DEPRECATED(5.0, "Please use the TryGetNumberField() instead")
	float TryGetFloatField(const FString& FieldName, float& OutNumber) const { return TryGetNumberField(FieldName, OutNumber); }
	UE_DEPRECATED(5.0, "Please use the TryGetIntegerField() instead")
	int32 GetIntegerField(const FString& FieldName) const { int32 Val = 0; TryGetIntegerField(FieldName, Val); return Val; }

	FString GetStringField(const FString& FieldName) const;
	bool TryGetStringField(const FString& FieldName, FString& OutString) const;
	bool TryGetStringArrayField(const FString& FieldName, TArray<FString>& OutArray) const;
	void SetStringField(const FString& FieldName, const FString& StringValue) const;

	bool GetBoolField(const FString& FieldName) const;
	bool TryGetBoolField(const FString& FieldName, bool& OutBool) const;
	void SetBoolField(const FString& FieldName, bool InValue) const;

	TArray<FRHAPI_JsonValue> GetArrayField(const FString& FieldName) const;
	bool TryGetArrayField(const FString& FieldName, TArray<FRHAPI_JsonValue>& OutArray) const;
	void SetArrayField(const FString& FieldName, const TArray<FRHAPI_JsonValue>& Array) const;

	FRHAPI_JsonObject GetObjectField(const FString& FieldName) const;
	bool TryGetObjectField(const FString& FieldName, FRHAPI_JsonObject& OutObject) const;
	void SetObjectField(const FString& FieldName, const FRHAPI_JsonObject& JsonObject) const;

	void SetObject(const TSharedPtr<FJsonObject> NewObj) { Obj = NewObj; }
	TSharedPtr<FJsonObject> GetObject() const { return Obj; }

private:
	TSharedPtr<FJsonObject> Obj;
};

USTRUCT(BlueprintType)
struct RALLYHEREAPI_API FRHAPI_JsonValue
{
	GENERATED_BODY()
public:
	FRHAPI_JsonValue() { SetValue(MakeShareable(new FJsonValueNull())); }
	FRHAPI_JsonValue(TSharedPtr<FJsonValue> InValue) { SetValue(InValue); }

	static FRHAPI_JsonValue CreateFromUnrealValue(TSharedPtr<FJsonValue> NewVal) { return FRHAPI_JsonValue(NewVal); }

	float AsNumber() const;
	FString AsString() const;
	bool AsBool() const;
	bool IsNull() const;
	TArray<FRHAPI_JsonValue> AsArray() const;
	FRHAPI_JsonObject AsObject() const;

	ERHAPI_JsonValueType GetType() const;

	bool TryGetNumber(float& OutNumber) const;
	bool TryGetInteger(int32& OutNumber) const;
	bool TryGetInteger64(int64& OutNumber) const;
	
	// deprecated functions that used improper naming
	UE_DEPRECATED(5.0, "Please use the TryGetNumber() instead")
	bool TryGetFloat(float& OutNumber) const { return TryGetNumber(OutNumber); }
	UE_DEPRECATED(5.0, "Please use the TryGetInteger() instead")
	bool TryGetNumber(int32& OutNumber) const { return TryGetInteger(OutNumber); }
	
	bool TryGetString(FString& OutString) const;
	bool TryGetBool(bool& OutBool) const;
	bool TryGetArray(TArray<FRHAPI_JsonValue>& OutArray) const;
	bool TryGetObject(FRHAPI_JsonObject& OutObject) const;

	void SetValue(const TSharedPtr<FJsonValue> NewValue) { Value = NewValue; }
	TSharedPtr<FJsonValue> GetValue() const { return Value; }

	bool CompareEqual(const FRHAPI_JsonValue& Other) const;

private:
	TSharedPtr<FJsonValue> Value;
};


UCLASS()
class RALLYHEREAPI_API URHAPI_JsonObjectBlueprintLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json")
	static bool FRHAPI_JsonObjectToString(const FRHAPI_JsonObject& InObject, FString& OutString);
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json")
	static bool StringToFRHAPI_JsonObject(const FString& InString, FRHAPI_JsonObject& OutObject);
	
	
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	FRHAPI_JsonValue TryGetValue(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.TryGetValue(FieldName); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool HasField(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.HasField(FieldName); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void SetField(const FRHAPI_JsonObject& Object, const FString& FieldName, const FRHAPI_JsonValue& Value) { Object.SetField(FieldName, Value); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void RemoveField(const FRHAPI_JsonObject& Object, const FString& FieldName) { Object.RemoveField(FieldName); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static float GetNumberField(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.GetNumberField(FieldName); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGeNumberField(const FRHAPI_JsonObject& Object, const FString& FieldName, float& OutNumber) { return Object.TryGetNumberField(FieldName, OutNumber); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void SetNumberField(const FRHAPI_JsonObject& Object, const FString& FieldName, float Number) { Object.SetNumberField(FieldName, Number); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetIntegerField(const FRHAPI_JsonObject& Object, const FString& FieldName, int32& OutInteger) { return Object.TryGetIntegerField(FieldName, OutInteger); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetInteger64Field(const FRHAPI_JsonObject& Object, const FString& FieldName, int64& OutInteger64) { return Object.TryGetInteger64Field(FieldName, OutInteger64); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static FString GetStringField(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.GetStringField(FieldName); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetStringField(const FRHAPI_JsonObject& Object, const FString& FieldName, FString& OutString) { return Object.TryGetStringField(FieldName, OutString); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetStringArrayField(const FRHAPI_JsonObject& Object, const FString& FieldName, TArray<FString>& OutArray) { return Object.TryGetStringArrayField(FieldName, OutArray); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void SetStringField(const FRHAPI_JsonObject& Object, const FString& FieldName, const FString& StringValue) { Object.SetStringField(FieldName, StringValue); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool GetBoolField(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.GetBoolField(FieldName); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetBoolField(const FRHAPI_JsonObject& Object, const FString& FieldName, bool& OutBool) { return Object.TryGetBoolField(FieldName, OutBool); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void SetBoolField(const FRHAPI_JsonObject& Object, const FString& FieldName, bool InValue) { Object.SetBoolField(FieldName, InValue); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static TArray<FRHAPI_JsonValue> GetArrayField(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.GetArrayField(FieldName); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetArrayField(const FRHAPI_JsonObject& Object, const FString& FieldName, TArray<FRHAPI_JsonValue>& OutArray) { return Object.TryGetArrayField(FieldName, OutArray); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void SetArrayField(const FRHAPI_JsonObject& Object, const FString& FieldName, const TArray<FRHAPI_JsonValue>& Array) { Object.SetArrayField(FieldName, Array); }

	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static FRHAPI_JsonObject GetObjectField(const FRHAPI_JsonObject& Object, const FString& FieldName) { return Object.GetObjectField(FieldName); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static bool TryGetObjectField(const FRHAPI_JsonObject& Object, const FString& FieldName, FRHAPI_JsonObject& OutObject) { return Object.TryGetObjectField(FieldName, OutObject); }
	UFUNCTION(BlueprintCallable, Category = "RallyHere|Json")
	static void SetObjectField(const FRHAPI_JsonObject& Object, const FString& FieldName, const FRHAPI_JsonObject& JsonObject) { Object.SetObjectField(FieldName, JsonObject); }

};

UCLASS()
class RALLYHEREAPI_API URHAPI_JsonValueBlueprintLibrary : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()
public:
	
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json")
	static bool FRHAPI_JsonValueToString(const FRHAPI_JsonValue& InValue, FString& OutString);
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json")
	static bool StringToFRHAPI_JsonValue(const FString& InString, FRHAPI_JsonValue& OutValue);
	
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json", meta=(NativeMakeFunc))
	static FRHAPI_JsonValue MakeNumberJsonValue(float InNumber) { return FRHAPI_JsonValue(MakeShareable(new FJsonValueNumber(InNumber))); }
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json", meta=(NativeMakeFunc))
	static FRHAPI_JsonValue MakeStringJsonValue(const FString& InString) { return FRHAPI_JsonValue(MakeShareable(new FJsonValueString(InString))); }
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json", meta=(NativeMakeFunc))
	static FRHAPI_JsonValue MakeBoolJsonValue(const FString& InString, bool InBool) { return FRHAPI_JsonValue(MakeShareable(new FJsonValueBoolean(InBool))); }
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json", meta=(NativeMakeFunc))
	static FRHAPI_JsonValue MakeNullJsonValue(const FString& InString) { return FRHAPI_JsonValue(MakeShareable(new FJsonValueNull())); }
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json", meta=(NativeMakeFunc))
	static FRHAPI_JsonValue MakeArrayJsonValue(const FString& InString, const TArray<FRHAPI_JsonValue>& InArray)
	{
		// make an array of the inner types
		TArray<TSharedPtr<FJsonValue>> Values;
		Values.Reset(InArray.Num());
		for (const auto& InValue : InArray)
		{
			Values.Add(InValue.GetValue());
		}
		return FRHAPI_JsonValue(MakeShareable(new FJsonValueArray(Values)));
	}
	UFUNCTION(BlueprintCallable, Category="RallyHere|Json", meta=(NativeMakeFunc))
	static FRHAPI_JsonValue MakeObjectJsonValue(const FString& InString, const FRHAPI_JsonObject& InObject) { return FRHAPI_JsonValue(MakeShareable(new FJsonValueObject(InObject.GetObject()))); } 
	
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static float AsNumber(const FRHAPI_JsonValue& Value) { return Value.AsNumber(); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static FString AsString(const FRHAPI_JsonValue& Value) { return Value.AsString(); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool AsBool(const FRHAPI_JsonValue& Value) { return Value.AsBool(); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool IsNull(const FRHAPI_JsonValue& Value) { return Value.IsNull(); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static TArray<FRHAPI_JsonValue> AsArray(const FRHAPI_JsonValue& Value) { return Value.AsArray(); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json") 
	static FRHAPI_JsonObject AsObject(const FRHAPI_JsonValue& Value) { return Value.AsObject(); }

	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	ERHAPI_JsonValueType GetType(const FRHAPI_JsonValue& Value) { return Value.GetType(); }

	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetNumber(const FRHAPI_JsonValue& Value, float& OutNumber) { return Value.TryGetNumber(OutNumber); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetInteger(const FRHAPI_JsonValue& Value, int32& OutInteger) { return Value.TryGetInteger(OutInteger); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetInteger64(const FRHAPI_JsonValue& Value, int64& OutInteger64) { return Value.TryGetInteger64(OutInteger64); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetString(const FRHAPI_JsonValue& Value, FString& OutString) { return Value.TryGetString(OutString); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetBool(const FRHAPI_JsonValue& Value, bool& OutBool) { return Value.TryGetBool(OutBool); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetArray(const FRHAPI_JsonValue& Value, TArray<FRHAPI_JsonValue>& OutArray) { return Value.TryGetArray(OutArray); }
	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool TryGetObject(const FRHAPI_JsonValue& Value, FRHAPI_JsonObject& OutObject) { return Value.TryGetObject(OutObject); }

	UFUNCTION(BlueprintPure, Category = "RallyHere|Json")
	static bool CompareEqual(const FRHAPI_JsonValue& A, const FRHAPI_JsonValue& B) { return A.CompareEqual(B); }
};

namespace RallyHereAPI
{

//////////////////////////////////////////////////////////////////////////

class RALLYHEREAPI_API FHttpFileInput
{
public:
	FHttpFileInput();
	FHttpFileInput(const TCHAR* InFilePath);
	FHttpFileInput(const FString& InFilePath);

	// This will automatically set the content type if not already set
	void SetFilePath(const TCHAR* InFilePath);
	void SetFilePath(const FString& InFilePath);

	// Optional if it can be deduced from the FilePath
	void SetContentType(const TCHAR* ContentType);

	FHttpFileInput& operator=(const FHttpFileInput& Other) = default;
	FHttpFileInput& operator=(const FString& InFilePath) { SetFilePath(*InFilePath); return*this; }
	FHttpFileInput& operator=(const TCHAR* InFilePath) { SetFilePath(InFilePath); return*this; }

	const FString& GetFilePath() const { return FilePath; }
	const FString& GetContentType() const { return ContentType; }

	// Returns the filename with extension
	FString GetFilename() const;

private:
	FString FilePath;
	FString ContentType;
};

//////////////////////////////////////////////////////////////////////////

class FHttpMultipartFormData
{
public:
	void SetBoundary(const TCHAR* InBoundary);
	void SetupHttpRequest(const FHttpRequestRef& HttpRequest);

	void AddStringPart(const TCHAR* Name, const TCHAR* Data);
	void AddJsonPart(const TCHAR* Name, const FString& JsonString);
	void AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray);
	void AddFilePart(const TCHAR* Name, const FHttpFileInput& File);

private:
	void AppendString(const TCHAR* Str);
	const FString& GetBoundary() const;

	mutable FString Boundary;
	TArray<uint8> FormData;

	static const TCHAR* Delimiter;
	static const TCHAR* Newline;
};

//////////////////////////////////////////////////////////////////////////

// Decodes Base64Url encoded strings, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
bool Base64UrlDecode(const FString& Base64String, T& Value)
{
	FString TmpCopy(Base64String);
	TmpCopy.ReplaceInline(TEXT("-"), TEXT("+"));
	TmpCopy.ReplaceInline(TEXT("_"), TEXT("/"));

	return FBase64::Decode(TmpCopy, Value);
}

// Encodes strings in Base64Url, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
FString Base64UrlEncode(const T& Value)
{
	FString Base64String = FBase64::Encode(Value);
	Base64String.ReplaceInline(TEXT("+"), TEXT("-"));
	Base64String.ReplaceInline(TEXT("/"), TEXT("_"));
	return Base64String;
}

template<typename T>
inline FStringFormatArg ToStringFormatArg(const T& Value)
{
	return FStringFormatArg(Value);
}

inline FStringFormatArg ToStringFormatArg(const FDateTime& Value)
{
	return FStringFormatArg(Value.ToIso8601());
}

inline FStringFormatArg ToStringFormatArg(const FGuid& Value)
{
	return FStringFormatArg(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline FStringFormatArg ToStringFormatArg(const TArray<uint8>& Value)
{
	return FStringFormatArg(Base64UrlEncode(Value));
}

template<typename T, typename std::enable_if<!std::is_base_of<FRHAPI_Model, T>::value, int>::type = 0>
inline FString ToString(const T& Value)
{
	return FString::Format(TEXT("{0}"), { ToStringFormatArg(Value) });
}

inline FString ToString(const FString& Value)
{
	return Value;
}

inline FString ToString(bool Value)
{
	return Value ? TEXT("true") : TEXT("false");
}

inline FStringFormatArg ToStringFormatArg(bool Value)
{
	return FStringFormatArg(ToString(Value));
}

template<typename T, typename U>
inline FStringFormatArg ToStringFormatArg(const TVariant<T,U>& Value)
{
	if (Value.template IsType<T>())
	{
		return ToStringFormatArg(Value.template Get<T>());
	}
	else
	{
		return ToStringFormatArg(Value.template Get<U>());
	}
}

inline FString ToString(const TArray<uint8>& Value)
{
	return Base64UrlEncode(Value);
}

inline FString ToString(const FRHAPI_Model& Value)
{
	FString String;
	TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&String);
	Value.WriteJson(Writer);
	Writer->Close();
	return String;
}

template<typename T>
inline FString ToUrlString(const T& Value)
{
	return FPlatformHttp::UrlEncode(ToString(Value));
}

template<typename T>
inline FString CollectionToUrlString(const TArray<T>& Collection, const TCHAR* Separator)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("{0}{1}"), { Separator, *ToUrlString(Collection[i]) });
	}
	return Output;
}

template<typename T>
inline FString CollectionToUrlString_csv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(","));
}

template<typename T>
inline FString CollectionToUrlString_ssv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(" "));
}

template<typename T>
inline FString CollectionToUrlString_tsv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("\t"));
}

template<typename T>
inline FString CollectionToUrlString_pipes(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("|"));
}

template<typename T>
inline FString CollectionToUrlString_multi(const TArray<T>& Collection, const TCHAR* BaseName)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	// Since this function is used to print a value string, the initial key has already been printed, so do not print it again
	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
	}
	return Output;
}

//////////////////////////////////////////////////////////////////////////

template<typename T>
inline T FromHeaderString(const FString& Value)
{
	return Value;
}

template<>
inline int32 FromHeaderString<int32>(const FString& Value)
{
	return FCString::Atoi(*Value);
}

template<>
inline int64 FromHeaderString<int64>(const FString& Value)
{
	return FCString::Atoi64(*Value);
}

template<>
inline float FromHeaderString<float>(const FString& Value)
{
	return FCString::Atof(*Value);
}

template<>
inline double FromHeaderString<double>(const FString& Value)
{
	return FCString::Atod(*Value);
}

template<>
inline FDateTime FromHeaderString<FDateTime>(const FString& Value)
{
	FDateTime DateTime;
	return FDateTime::ParseHttpDate(Value, DateTime) ? DateTime : FDateTime();
}

//////////////////////////////////////////////////////////////////////////

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonValue>& Value)
{
	if (Value.IsValid())
	{
		// prefer to use the serialize function that does not take an idenitfier, as we are trying to just write a value
		if (Value->Type == EJson::Object)
		{
			FJsonSerializer::Serialize(Value->AsObject().ToSharedRef(), Writer, false);
		}
		else if (Value->Type == EJson::Array)
		{
			FJsonSerializer::Serialize(Value->AsArray(), Writer, false);
		}
		else
		{
			// there is not a serialize function that does not take identifiers for other types, so pass in an empty identifier which should get ignored
			FJsonSerializer::Serialize(Value.ToSharedRef(), "", Writer, false);
		}
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FRHAPI_JsonValue& Value)
{
	WriteJsonValue(Writer, Value.GetValue());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonObject>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FRHAPI_JsonObject& Value)
{
	WriteJsonValue(Writer, Value.GetObject());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<uint8>& Value)
{
	Writer->WriteValue(ToString(Value));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FDateTime& Value)
{
	Writer->WriteValue(Value.ToIso8601());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FGuid& Value)
{
	Writer->WriteValue(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FRHAPI_Model& Value)
{
	Value.WriteJson(Writer);
}

template<typename T, typename std::enable_if<!TIsVariant<T>::Value && !std::is_base_of<FRHAPI_Model, T>::value, int>::type = 0>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const T& Value)
{
	Writer->WriteValue(Value);
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSet<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TMap<FString, T>& Value)
{
	Writer->WriteObjectStart();
	for (const auto& It : Value)
	{
		Writer->WriteIdentifierPrefix(It.Key);
		WriteJsonValue(Writer, It.Value);
	}
	Writer->WriteObjectEnd();
}

template<typename T, typename U>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TVariant<T, U>& Value)
{
	if (Value.template IsType<T>())
	{
		return WriteJsonValue(Writer, Value.template Get<T>());
	}
	else
	{
		return WriteJsonValue(Writer, Value.template Get<U>());
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, nullptr_t)
{
	Writer->WriteNull();
}

//////////////////////////////////////////////////////////////////////////

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FRHAPI_JsonValue& Value)
{
	Value.SetValue(JsonValue);
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FRHAPI_JsonObject& Value)
{
	const TSharedPtr<FJsonObject>* TmpValue;
	if (JsonValue->TryGetObject(TmpValue))
	{
		Value.SetObject(*TmpValue);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FString& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

RALLYHEREAPI_API bool ParseDateTime(const FString& DateTimeString, FDateTime& OutDateTime);

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FDateTime& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return ParseDateTime(TmpValue, Value);
	}
	else
		return false;
}

template<typename T, typename U>
inline bool TryGetJsonValueTVariant(const TSharedPtr<FJsonObject>& JsonObject, TVariant<T, U>& Value)
{
	for (const auto& It : (*JsonObject).Values)
	{
		T TmpValue;
		if (TryGetJsonValue(It.Value, TmpValue))
		{
			Value.template Set<T>(TmpValue);
			return true;
		}

		U TmpValue2;
		if (TryGetJsonValue(It.Value, TmpValue2))
		{
			Value.template Set<U>(TmpValue2);
			return true;
		}
	}
	return false;
}

template<typename T, typename U>
inline bool TryGetJsonValueTVariant(const TSharedPtr<FJsonValue>& JsonValue, TVariant<T, U>& Value)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		return (TryGetJsonValueTVariant(*Object, Value));
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FGuid& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return FGuid::Parse(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, bool& Value)
{
	bool TmpValue;
	if (JsonValue->TryGetBool(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonValue>& JsonObjectValue)
{
	JsonObjectValue = JsonValue;
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonObject>& JsonObjectValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		JsonObjectValue = *Object;
		return true;
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<uint8>& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Base64UrlDecode(TmpValue, Value);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FRHAPI_Model& Value)
{
	return Value.FromJson(JsonValue);
}

template<typename T, typename std::enable_if<TIsVariant<T>::Value, bool>::type = true>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, T& Value)
{
	return TryGetJsonValueTVariant(JsonObject, Value);
}

template<typename T, typename std::enable_if<TIsVariant<T>::Value, bool>::type = true>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	return TryGetJsonValueTVariant(JsonValue, Value);
}

template<typename T, typename std::enable_if<!TIsVariant<T>::Value && !std::is_base_of<FRHAPI_Model, T>::value, int>::type = 0>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	T TmpValue;
	if (JsonValue->TryGetNumber(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<T>& ArrayValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		ArrayValue.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			ArrayValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSet<T>& SetValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		SetValue.Reset();
		SetValue.Reserve(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			SetValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TMap<FString, T>& MapValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		MapValue.Reset();
		bool ParseSuccess = true;
		for (const auto& It : (*Object)->Values)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue(It.Value, TmpValue);
			MapValue.Emplace(It.Key, MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TOptional<T>& OptionalValue)
{
	if (JsonObject->HasField(Key))
	{
		T Value;
		const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
		if (JsonValue.IsValid() && !JsonValue->IsNull())
		{
			if (TryGetJsonValue(JsonValue, Value))
			{
				OptionalValue = Value;
				return true;
			}
		}

		return false;
	}
	return true; // Absence of optional value is not a parsing error
}

template<typename T, typename U>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TVariant<T, U>& Value)
{
	for (const auto& It : JsonObject->Values)
	{
		T TmpValue;
		if (TryGetJsonValue(It.Value, TmpValue))
		{
			Value.template Set<T>(TmpValue);
			return true;
		}

		U TmpValue2;
		if (TryGetJsonValue(It.Value, TmpValue2))
		{
			Value.template Set<U>(TmpValue2);
			return true;
		}
	}
	return false;
}

}
