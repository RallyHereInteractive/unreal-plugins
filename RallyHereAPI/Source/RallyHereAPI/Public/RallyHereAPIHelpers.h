// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "RallyHereAPIBaseModel.h"
#include "Serialization/JsonSerializer.h"
#include "Dom/JsonObject.h"
#include "Misc/Base64.h"
#include "Misc/TVariant.h"
#include "PlatformHttp.h"
#include "Containers/Set.h"
#include "RallyHereAPIHelpers.generated.h"

struct FRHAPI_JsonValue;
class IHttpRequest;

constexpr int32 DefaultRallyHereAPIPriority = 1000000;

UENUM(BlueprintType)
enum class ERHAPI_JsonValueType : uint8
{
    None,
    Null,
    String,
    Number,
    Boolean,
    Array,
    Object
};

USTRUCT(BlueprintType)
struct RALLYHEREAPI_API FRHAPI_JsonObject
{
    GENERATED_BODY()
public:
    FRHAPI_JsonValue TryGetValue(const FString& FieldName) const;

    bool HasField(const FString& FieldName) const;
	void SetField(const FString& FieldName, const FRHAPI_JsonValue& Value) const;
	void RemoveField(const FString& FieldName) const;

	float GetFloatField(const FString& FieldName) const;
	int32 GetIntegerField(const FString& FieldName) const;
	bool TryGetFloatField(const FString& FieldName, float& OutNumber) const;
	bool TryGetNumberField(const FString& FieldName, int32& OutNumber) const;
	bool TryGetInteger64Field(const FString& FieldName, int64& OutNumber) const;
	void SetNumberField(const FString& FieldName, float Number) const;

	FString GetStringField(const FString& FieldName) const;
	bool TryGetStringField(const FString& FieldName, FString& OutString) const;
	bool TryGetStringArrayField(const FString& FieldName, TArray<FString>& OutArray) const;
	void SetStringField(const FString& FieldName, const FString& StringValue) const;

	bool GetBoolField(const FString& FieldName) const;
    bool TryGetBoolField(const FString& FieldName, bool& OutBool) const;
	void SetBoolField(const FString& FieldName, bool InValue) const;

	TArray<FRHAPI_JsonValue> GetArrayField(const FString& FieldName) const;
	bool TryGetArrayField(const FString& FieldName, TArray<FRHAPI_JsonValue>& OutArray) const;
	void SetArrayField(const FString& FieldName, const TArray<FRHAPI_JsonValue>& Array) const;

    FRHAPI_JsonObject GetObjectField(const FString& FieldName) const;
	bool TryGetObjectField(const FString& FieldName, FRHAPI_JsonObject& OutObject) const;
	void SetObjectField(const FString& FieldName, const FRHAPI_JsonObject& JsonObject) const;

    void SetObject(const TSharedPtr<FJsonObject> NewObj) { Obj = NewObj; }
    TSharedPtr<FJsonObject> GetObject() const { return Obj; }

    static FRHAPI_JsonObject CreateFromUnrealObject(TSharedPtr<FJsonObject> NewObj);

private:
    TSharedPtr<FJsonObject> Obj;
};


USTRUCT(BlueprintType)
struct RALLYHEREAPI_API FRHAPI_JsonValue
{
    GENERATED_BODY()
public:
    float AsNumber() const;
    FString AsString() const;
    bool AsBool() const;
    bool IsNull() const;
    TArray<FRHAPI_JsonValue> AsArray() const;
    FRHAPI_JsonObject AsObject() const;

    ERHAPI_JsonValueType GetType() const;

	bool TryGetFloat(float& OutNumber) const;
	bool TryGetNumber(int32& OutNumber) const;
	bool TryGetInteger64(int64& OutNumber) const;
	bool TryGetString(FString& OutString) const;
	bool TryGetBool(bool& OutBool) const;
	bool TryGetArray(TArray<FRHAPI_JsonValue>& OutArray) const;
	bool TryGetObject(FRHAPI_JsonObject& OutObject) const;

    void SetValue(const TSharedPtr<FJsonValue> NewValue) { Value = NewValue; }
    TSharedPtr<FJsonValue> GetValue() const { return Value; }

    static FRHAPI_JsonValue CreateFromUnrealValue(const TSharedPtr<FJsonValue> NewValue);

    bool CompareEqual(const FRHAPI_JsonValue& Other) const;

private:
    TSharedPtr<FJsonValue> Value;
};

namespace RallyHereAPI
{

//////////////////////////////////////////////////////////////////////////

class RALLYHEREAPI_API FHttpFileInput
{
public:
	explicit FHttpFileInput(const TCHAR* InFilePath);
	explicit FHttpFileInput(const FString& InFilePath);

	// This will automatically set the content type if not already set
    void SetFilePath(const TCHAR* InFilePath);
	void SetFilePath(const FString& InFilePath);

    // Optional if it can be deduced from the FilePath
    void SetContentType(const TCHAR* ContentType);

	FHttpFileInput& operator=(const FHttpFileInput& Other) = default;
	FHttpFileInput& operator=(const FString& InFilePath) { SetFilePath(*InFilePath); return*this; }
	FHttpFileInput& operator=(const TCHAR* InFilePath) { SetFilePath(InFilePath); return*this; }

	const FString& GetFilePath() const { return FilePath; }
	const FString& GetContentType() const { return ContentType; }

	// Returns the filename with extension
	FString GetFilename() const;

private:
    FString FilePath;
    FString ContentType;
};

//////////////////////////////////////////////////////////////////////////

class FHttpMultipartFormData
{
public:
	void SetBoundary(const TCHAR* InBoundary);
	void SetupHttpRequest(const FHttpRequestRef& HttpRequest);

	void AddStringPart(const TCHAR* Name, const TCHAR* Data);
	void AddJsonPart(const TCHAR* Name, const FString& JsonString);
	void AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray);
	void AddFilePart(const TCHAR* Name, const FHttpFileInput& File);

private:
	void AppendString(const TCHAR* Str);
	const FString& GetBoundary() const;

	mutable FString Boundary;
	TArray<uint8> FormData;

	static const TCHAR* Delimiter;
	static const TCHAR* Newline;
};

//////////////////////////////////////////////////////////////////////////

// Decodes Base64Url encoded strings, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
bool Base64UrlDecode(const FString& Base64String, T& Value)
{
	FString TmpCopy(Base64String);
	TmpCopy.ReplaceInline(TEXT("-"), TEXT("+"));
	TmpCopy.ReplaceInline(TEXT("_"), TEXT("/"));

	return FBase64::Decode(TmpCopy, Value);
}

// Encodes strings in Base64Url, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
FString Base64UrlEncode(const T& Value)
{
	FString Base64String = FBase64::Encode(Value);
	Base64String.ReplaceInline(TEXT("+"), TEXT("-"));
	Base64String.ReplaceInline(TEXT("/"), TEXT("_"));
	return Base64String;
}

template<typename T>
inline FStringFormatArg ToStringFormatArg(const T& Value)
{
	return FStringFormatArg(Value);
}

inline FStringFormatArg ToStringFormatArg(const FDateTime& Value)
{
	return FStringFormatArg(Value.ToIso8601());
}

inline FStringFormatArg ToStringFormatArg(const FGuid& Value)
{
	return FStringFormatArg(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline FStringFormatArg ToStringFormatArg(const TArray<uint8>& Value)
{
	return FStringFormatArg(Base64UrlEncode(Value));
}

template<typename T, typename std::enable_if<!std::is_base_of<FRHAPI_Model, T>::value, int>::type = 0>
inline FString ToString(const T& Value)
{
	return FString::Format(TEXT("{0}"), { ToStringFormatArg(Value) });
}

inline FString ToString(const FString& Value)
{
	return Value;
}

inline FString ToString(bool Value)
{
	return Value ? TEXT("true") : TEXT("false");
}

inline FStringFormatArg ToStringFormatArg(bool Value)
{
	return FStringFormatArg(ToString(Value));
}

template<typename T, typename U>
inline FStringFormatArg ToStringFormatArg(const TVariant<T,U>& Value)
{
	if (Value.template IsType<T>())
	{
		return ToStringFormatArg(Value.template Get<T>());
	}
	else
	{
		return ToStringFormatArg(Value.template Get<U>());
	}
}

inline FString ToString(const TArray<uint8>& Value)
{
	return Base64UrlEncode(Value);
}

inline FString ToString(const FRHAPI_Model& Value)
{
	FString String;
    TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&String);
	Value.WriteJson(Writer);
	Writer->Close();
	return String;
}

template<typename T>
inline FString ToUrlString(const T& Value)
{
	return FPlatformHttp::UrlEncode(ToString(Value));
}

template<typename T>
inline FString CollectionToUrlString(const TArray<T>& Collection, const TCHAR* Separator)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("{0}{1}"), { Separator, *ToUrlString(Collection[i]) });
	}
	return Output;
}

template<typename T>
inline FString CollectionToUrlString_csv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(","));
}

template<typename T>
inline FString CollectionToUrlString_ssv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(" "));
}

template<typename T>
inline FString CollectionToUrlString_tsv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("\t"));
}

template<typename T>
inline FString CollectionToUrlString_pipes(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("|"));
}

template<typename T>
inline FString CollectionToUrlString_multi(const TArray<T>& Collection, const TCHAR* BaseName)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	// Since this function is used to print a value string, the initial key has already been printed, so do not print it again
	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
	}
	return Output;
}

//////////////////////////////////////////////////////////////////////////

template<typename T>
inline T FromHeaderString(const FString& Value)
{
	return Value;
}

template<>
inline int32 FromHeaderString<int32>(const FString& Value)
{
	return FCString::Atoi(*Value);
}

template<>
inline int64 FromHeaderString<int64>(const FString& Value)
{
	return FCString::Atoi64(*Value);
}

template<>
inline float FromHeaderString<float>(const FString& Value)
{
	return FCString::Atof(*Value);
}

template<>
inline double FromHeaderString<double>(const FString& Value)
{
	return FCString::Atod(*Value);
}

//////////////////////////////////////////////////////////////////////////

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonValue>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), "", Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FRHAPI_JsonValue& Value)
{
	WriteJsonValue(Writer, Value.GetValue());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonObject>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FRHAPI_JsonObject& Value)
{
	WriteJsonValue(Writer, Value.GetObject());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<uint8>& Value)
{
	Writer->WriteValue(ToString(Value));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FDateTime& Value)
{
	Writer->WriteValue(Value.ToIso8601());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FGuid& Value)
{
	Writer->WriteValue(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FRHAPI_Model& Value)
{
	Value.WriteJson(Writer);
}

template<typename T, typename std::enable_if<!TIsVariant<T>::Value && !std::is_base_of<FRHAPI_Model, T>::value, int>::type = 0>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const T& Value)
{
	Writer->WriteValue(Value);
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSet<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TMap<FString, T>& Value)
{
	Writer->WriteObjectStart();
	for (const auto& It : Value)
	{
		Writer->WriteIdentifierPrefix(It.Key);
		WriteJsonValue(Writer, It.Value);
	}
	Writer->WriteObjectEnd();
}

template<typename T, typename U>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TVariant<T, U>& Value)
{
	if (Value.template IsType<T>())
	{
		return WriteJsonValue(Writer, Value.template Get<T>());
	}
	else
	{
		return WriteJsonValue(Writer, Value.template Get<U>());
	}
}


//////////////////////////////////////////////////////////////////////////

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FRHAPI_JsonValue& Value)
{
	Value.SetValue(JsonValue);
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FRHAPI_JsonObject& Value)
{
	const TSharedPtr<FJsonObject>* TmpValue;
	if (JsonValue->TryGetObject(TmpValue))
	{
		Value.SetObject(*TmpValue);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FString& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

RALLYHEREAPI_API bool ParseDateTime(const FString& DateTimeString, FDateTime& OutDateTime);

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FDateTime& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return ParseDateTime(TmpValue, Value);
	}
	else
		return false;
}

template<typename T, typename U>
inline bool TryGetJsonValueTVariant(const TSharedPtr<FJsonObject>& JsonObject, TVariant<T, U>& Value)
{
	for (const auto& It : (*JsonObject).Values)
	{
		T TmpValue;
		if (TryGetJsonValue(It.Value, TmpValue))
		{
			Value.template Set<T>(TmpValue);
			return true;
		}

		U TmpValue2;
		if (TryGetJsonValue(It.Value, TmpValue2))
		{
			Value.template Set<U>(TmpValue2);
			return true;
		}
	}
	return false;
}

template<typename T, typename U>
inline bool TryGetJsonValueTVariant(const TSharedPtr<FJsonValue>& JsonValue, TVariant<T, U>& Value)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		return (TryGetJsonValueTVariant(*Object, Value));
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FGuid& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return FGuid::Parse(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, bool& Value)
{
	bool TmpValue;
	if (JsonValue->TryGetBool(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonValue>& JsonObjectValue)
{
	JsonObjectValue = JsonValue;
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonObject>& JsonObjectValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		JsonObjectValue = *Object;
		return true;
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<uint8>& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Base64UrlDecode(TmpValue, Value);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FRHAPI_Model& Value)
{
	return Value.FromJson(JsonValue);
}

template<typename T, typename std::enable_if<TIsVariant<T>::Value, bool>::type = true>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, T& Value)
{
	return TryGetJsonValueTVariant(JsonObject, Value);
}

template<typename T, typename std::enable_if<TIsVariant<T>::Value, bool>::type = true>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	return TryGetJsonValueTVariant(JsonValue, Value);
}

template<typename T, typename std::enable_if<!TIsVariant<T>::Value && !std::is_base_of<FRHAPI_Model, T>::value, int>::type = 0>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	T TmpValue;
	if (JsonValue->TryGetNumber(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<T>& ArrayValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		ArrayValue.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			ArrayValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSet<T>& SetValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		SetValue.Reset();
		SetValue.Reserve(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			SetValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TMap<FString, T>& MapValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		MapValue.Reset();
		bool ParseSuccess = true;
		for (const auto& It : (*Object)->Values)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue(It.Value, TmpValue);
			MapValue.Emplace(It.Key, MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TOptional<T>& OptionalValue)
{
	if (JsonObject->HasField(Key))
	{
		T Value;
		const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
		if (JsonValue.IsValid() && !JsonValue->IsNull())
		{
			if (TryGetJsonValue(JsonValue, Value))
			{
				OptionalValue = Value;
				return true;
			}
		}

		return false;
	}
	return true; // Absence of optional value is not a parsing error
}

template<typename T, typename U>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TVariant<T, U>& Value)
{
	for (const auto& It : JsonObject->Values)
	{
		T TmpValue;
		if (TryGetJsonValue(It.Value, TmpValue))
		{
			Value.template Set<T>(TmpValue);
			return true;
		}

		U TmpValue2;
		if (TryGetJsonValue(It.Value, TmpValue2))
		{
			Value.template Set<U>(TmpValue2);
			return true;
		}
	}
	return false;
}

}
