// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "CoreMinimal.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHelpers.h"
#include "Platform.h"
#include "Catalog.h"
#include "HTTPValidationError.h"
#include "HzApiErrorModel.h"
#include "InventoryBucketUseRuleSet.h"
#include "InventoryBucketUseRuleSets.h"
#include "Item.h"
#include "Items.h"
#include "Loot.h"
#include "Loots.h"
#include "PlatformSKU.h"
#include "PlatformSKUs.h"
#include "PortalUseRuleset.h"
#include "PortalUseRulesets.h"
#include "PricePoint.h"
#include "PricePoints.h"
#include "TimeFrame.h"
#include "TimeFrames.h"
#include "Vendor.h"
#include "Vendors.h"
#include "XpTable.h"
#include "XpTables.h"

namespace RallyHereAPI
{
using RallyHereAPI::ToStringFormatArg;
using RallyHereAPI::WriteJsonValue;
using RallyHereAPI::TryGetJsonValue;

struct FRequest_GetCatalogAll;
struct FResponse_GetCatalogAll;
struct FRequest_GetCatalogEntitlementSku;
struct FResponse_GetCatalogEntitlementSku;
struct FRequest_GetCatalogEntitlementSkuAll;
struct FResponse_GetCatalogEntitlementSkuAll;
struct FRequest_GetCatalogInventoryBucketUseRuleSet;
struct FResponse_GetCatalogInventoryBucketUseRuleSet;
struct FRequest_GetCatalogInventoryBucketUseRuleSetsAll;
struct FResponse_GetCatalogInventoryBucketUseRuleSetsAll;
struct FRequest_GetCatalogItem;
struct FResponse_GetCatalogItem;
struct FRequest_GetCatalogItemsAll;
struct FResponse_GetCatalogItemsAll;
struct FRequest_GetCatalogLoot;
struct FResponse_GetCatalogLoot;
struct FRequest_GetCatalogLootsAll;
struct FResponse_GetCatalogLootsAll;
struct FRequest_GetCatalogPortalUseRuleset;
struct FResponse_GetCatalogPortalUseRuleset;
struct FRequest_GetCatalogPortalUseRulesetsAll;
struct FResponse_GetCatalogPortalUseRulesetsAll;
struct FRequest_GetCatalogPricePoint;
struct FResponse_GetCatalogPricePoint;
struct FRequest_GetCatalogPricePointsAll;
struct FResponse_GetCatalogPricePointsAll;
struct FRequest_GetCatalogTimeFrame;
struct FResponse_GetCatalogTimeFrame;
struct FRequest_GetCatalogTimeFramesAll;
struct FResponse_GetCatalogTimeFramesAll;
struct FRequest_GetCatalogVendor;
struct FResponse_GetCatalogVendor;
struct FRequest_GetCatalogVendorsAll;
struct FResponse_GetCatalogVendorsAll;
struct FRequest_GetCatalogXpAll;
struct FResponse_GetCatalogXpAll;
struct FRequest_GetCatalogXpTable;
struct FResponse_GetCatalogXpTable;

DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogAll, const FResponse_GetCatalogAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogEntitlementSku, const FResponse_GetCatalogEntitlementSku&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogEntitlementSkuAll, const FResponse_GetCatalogEntitlementSkuAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogInventoryBucketUseRuleSet, const FResponse_GetCatalogInventoryBucketUseRuleSet&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogInventoryBucketUseRuleSetsAll, const FResponse_GetCatalogInventoryBucketUseRuleSetsAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogItem, const FResponse_GetCatalogItem&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogItemsAll, const FResponse_GetCatalogItemsAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogLoot, const FResponse_GetCatalogLoot&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogLootsAll, const FResponse_GetCatalogLootsAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogPortalUseRuleset, const FResponse_GetCatalogPortalUseRuleset&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogPortalUseRulesetsAll, const FResponse_GetCatalogPortalUseRulesetsAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogPricePoint, const FResponse_GetCatalogPricePoint&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogPricePointsAll, const FResponse_GetCatalogPricePointsAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogTimeFrame, const FResponse_GetCatalogTimeFrame&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogTimeFramesAll, const FResponse_GetCatalogTimeFramesAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogVendor, const FResponse_GetCatalogVendor&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogVendorsAll, const FResponse_GetCatalogVendorsAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogXpAll, const FResponse_GetCatalogXpAll&);
DECLARE_DELEGATE_OneParam(FDelegate_GetCatalogXpTable, const FResponse_GetCatalogXpTable&);

class RALLYHEREAPI_API FCatalogAPI : public FAPI
{
public:
	FCatalogAPI();
	virtual ~FCatalogAPI();

	FHttpRequestPtr GetCatalogAll(const FRequest_GetCatalogAll& Request, const FDelegate_GetCatalogAll& Delegate = FDelegate_GetCatalogAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogEntitlementSku(const FRequest_GetCatalogEntitlementSku& Request, const FDelegate_GetCatalogEntitlementSku& Delegate = FDelegate_GetCatalogEntitlementSku(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogEntitlementSkuAll(const FRequest_GetCatalogEntitlementSkuAll& Request, const FDelegate_GetCatalogEntitlementSkuAll& Delegate = FDelegate_GetCatalogEntitlementSkuAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogInventoryBucketUseRuleSet(const FRequest_GetCatalogInventoryBucketUseRuleSet& Request, const FDelegate_GetCatalogInventoryBucketUseRuleSet& Delegate = FDelegate_GetCatalogInventoryBucketUseRuleSet(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogInventoryBucketUseRuleSetsAll(const FRequest_GetCatalogInventoryBucketUseRuleSetsAll& Request, const FDelegate_GetCatalogInventoryBucketUseRuleSetsAll& Delegate = FDelegate_GetCatalogInventoryBucketUseRuleSetsAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogItem(const FRequest_GetCatalogItem& Request, const FDelegate_GetCatalogItem& Delegate = FDelegate_GetCatalogItem(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogItemsAll(const FRequest_GetCatalogItemsAll& Request, const FDelegate_GetCatalogItemsAll& Delegate = FDelegate_GetCatalogItemsAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogLoot(const FRequest_GetCatalogLoot& Request, const FDelegate_GetCatalogLoot& Delegate = FDelegate_GetCatalogLoot(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogLootsAll(const FRequest_GetCatalogLootsAll& Request, const FDelegate_GetCatalogLootsAll& Delegate = FDelegate_GetCatalogLootsAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogPortalUseRuleset(const FRequest_GetCatalogPortalUseRuleset& Request, const FDelegate_GetCatalogPortalUseRuleset& Delegate = FDelegate_GetCatalogPortalUseRuleset(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogPortalUseRulesetsAll(const FRequest_GetCatalogPortalUseRulesetsAll& Request, const FDelegate_GetCatalogPortalUseRulesetsAll& Delegate = FDelegate_GetCatalogPortalUseRulesetsAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogPricePoint(const FRequest_GetCatalogPricePoint& Request, const FDelegate_GetCatalogPricePoint& Delegate = FDelegate_GetCatalogPricePoint(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogPricePointsAll(const FRequest_GetCatalogPricePointsAll& Request, const FDelegate_GetCatalogPricePointsAll& Delegate = FDelegate_GetCatalogPricePointsAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogTimeFrame(const FRequest_GetCatalogTimeFrame& Request, const FDelegate_GetCatalogTimeFrame& Delegate = FDelegate_GetCatalogTimeFrame(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogTimeFramesAll(const FRequest_GetCatalogTimeFramesAll& Request, const FDelegate_GetCatalogTimeFramesAll& Delegate = FDelegate_GetCatalogTimeFramesAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogVendor(const FRequest_GetCatalogVendor& Request, const FDelegate_GetCatalogVendor& Delegate = FDelegate_GetCatalogVendor(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogVendorsAll(const FRequest_GetCatalogVendorsAll& Request, const FDelegate_GetCatalogVendorsAll& Delegate = FDelegate_GetCatalogVendorsAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogXpAll(const FRequest_GetCatalogXpAll& Request, const FDelegate_GetCatalogXpAll& Delegate = FDelegate_GetCatalogXpAll(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr GetCatalogXpTable(const FRequest_GetCatalogXpTable& Request, const FDelegate_GetCatalogXpTable& Delegate = FDelegate_GetCatalogXpTable(), int32 Priority = DefaultRallyHereAPIPriority);

private:
	void OnGetCatalogAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogEntitlementSkuResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogEntitlementSku Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogEntitlementSkuAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogEntitlementSkuAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogInventoryBucketUseRuleSetResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogInventoryBucketUseRuleSet Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogInventoryBucketUseRuleSetsAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogInventoryBucketUseRuleSetsAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogItemResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogItem Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogItemsAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogItemsAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogLootResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogLoot Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogLootsAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogLootsAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogPortalUseRulesetResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogPortalUseRuleset Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogPortalUseRulesetsAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogPortalUseRulesetsAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogPricePointResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogPricePoint Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogPricePointsAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogPricePointsAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogTimeFrameResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogTimeFrame Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogTimeFramesAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogTimeFramesAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogVendorResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogVendor Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogVendorsAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogVendorsAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogXpAllResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogXpAll Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnGetCatalogXpTableResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_GetCatalogXpTable Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);

};

/* Get Catalog All
 *
 * Get the entire catalog.
 * 
 * This endpoint endpoint is generally discouraged outside of prototyping and early development.  It's not that the endpoint won't function, but rather that it creates a pattern that may result in a poor end user experience.  It has etag/if-none-match handling, but it is for the entire catalog.  So if a single byte changes inside the catalog (e.g. turning on a loot record, adding a single new item, changing a price point, adjusting the threshold to hit level X in an XP Table), then the etag will change.  If clients are re-requesting data from this endpoint, then those changes will result in them re-downloading, and re-parsing the entire catalog for that tiny modification.
 * 
 * Early on in a game's lifecycle, this doesn't matter much - since catalog data is pretty small.  But as your game grows, and you create lots of things to receive/purchase/grant, the data will balloon in size.  Parsing the response does occur on unreal's main thread, and with a sufficiently large catalog, you may see hitches.  There will also be lots of data in there that may not even be necessary for your client to see at all (e.g. if you only grant the loot from the dedicated server or if an item is just a tracker, it doesn't necessarily need to be visible on the client).
 * 
 * We generally encourage having a well-known list of vendors to request from `/inventory/v1/catalog/vendor/{vendor_id}`, and then requesting the entire set of xp tables, price points, and bucket rulesets (as those are generally pretty small lists).  That list of vendors could come from anywhere, it could be hardcoded, be set from an ini (if your client is unlikely to need arbitrary vendor additions, but you want to retain the ability to patch it) or it could come down in a kv.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogAll : public FRequest
{
	FRequest_GetCatalogAll();
	virtual ~FRequest_GetCatalogAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogAll : public FResponse
{
	FResponse_GetCatalogAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Catalog, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Catalog Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Catalog& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogAll
{
	typedef FRequest_GetCatalogAll Request;
	typedef FResponse_GetCatalogAll Response;
	typedef FDelegate_GetCatalogAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Entitlement Sku
 *
 * Get a specific Entitlement SKU.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogEntitlementSku : public FRequest
{
	FRequest_GetCatalogEntitlementSku();
	virtual ~FRequest_GetCatalogEntitlementSku() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	ERHAPI_Platform Platform;
	FString Sku;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogEntitlementSku : public FResponse
{
	FResponse_GetCatalogEntitlementSku(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogEntitlementSku() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_PlatformSKU, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_PlatformSKU Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_PlatformSKU& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogEntitlementSku
{
	typedef FRequest_GetCatalogEntitlementSku Request;
	typedef FResponse_GetCatalogEntitlementSku Response;
	typedef FDelegate_GetCatalogEntitlementSku Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogEntitlementSku(InRequest, InDelegate, Priority); }
};

/* Get Catalog Entitlement Sku All
 *
 * Get all Entitlement SKUs.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogEntitlementSkuAll : public FRequest
{
	FRequest_GetCatalogEntitlementSkuAll();
	virtual ~FRequest_GetCatalogEntitlementSkuAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogEntitlementSkuAll : public FResponse
{
	FResponse_GetCatalogEntitlementSkuAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogEntitlementSkuAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_PlatformSKUs, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_PlatformSKUs Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_PlatformSKUs& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogEntitlementSkuAll
{
	typedef FRequest_GetCatalogEntitlementSkuAll Request;
	typedef FResponse_GetCatalogEntitlementSkuAll Response;
	typedef FDelegate_GetCatalogEntitlementSkuAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogEntitlementSkuAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Inventory Bucket Use Rule Set
 *
 * Get a specific Inventory Bucket Use Rule Set.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogInventoryBucketUseRuleSet : public FRequest
{
	FRequest_GetCatalogInventoryBucketUseRuleSet();
	virtual ~FRequest_GetCatalogInventoryBucketUseRuleSet() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	FString InventoryBucketUseRulesetId;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogInventoryBucketUseRuleSet : public FResponse
{
	FResponse_GetCatalogInventoryBucketUseRuleSet(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogInventoryBucketUseRuleSet() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_InventoryBucketUseRuleSet, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_InventoryBucketUseRuleSet Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_InventoryBucketUseRuleSet& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogInventoryBucketUseRuleSet
{
	typedef FRequest_GetCatalogInventoryBucketUseRuleSet Request;
	typedef FResponse_GetCatalogInventoryBucketUseRuleSet Response;
	typedef FDelegate_GetCatalogInventoryBucketUseRuleSet Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogInventoryBucketUseRuleSet(InRequest, InDelegate, Priority); }
};

/* Get Catalog Inventory Bucket Use Rule Sets All
 *
 * Get all Inventory Bucket Use Rule Sets.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogInventoryBucketUseRuleSetsAll : public FRequest
{
	FRequest_GetCatalogInventoryBucketUseRuleSetsAll();
	virtual ~FRequest_GetCatalogInventoryBucketUseRuleSetsAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogInventoryBucketUseRuleSetsAll : public FResponse
{
	FResponse_GetCatalogInventoryBucketUseRuleSetsAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogInventoryBucketUseRuleSetsAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_InventoryBucketUseRuleSets, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_InventoryBucketUseRuleSets Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_InventoryBucketUseRuleSets& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogInventoryBucketUseRuleSetsAll
{
	typedef FRequest_GetCatalogInventoryBucketUseRuleSetsAll Request;
	typedef FResponse_GetCatalogInventoryBucketUseRuleSetsAll Response;
	typedef FDelegate_GetCatalogInventoryBucketUseRuleSetsAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogInventoryBucketUseRuleSetsAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Item
 *
 * Get a specific Item.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogItem : public FRequest
{
	FRequest_GetCatalogItem();
	virtual ~FRequest_GetCatalogItem() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	int32 ItemId = 0;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogItem : public FResponse
{
	FResponse_GetCatalogItem(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogItem() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Item, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Item Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Item& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogItem
{
	typedef FRequest_GetCatalogItem Request;
	typedef FResponse_GetCatalogItem Response;
	typedef FDelegate_GetCatalogItem Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogItem(InRequest, InDelegate, Priority); }
};

/* Get Catalog Items All
 *
 * Get all Items.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogItemsAll : public FRequest
{
	FRequest_GetCatalogItemsAll();
	virtual ~FRequest_GetCatalogItemsAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogItemsAll : public FResponse
{
	FResponse_GetCatalogItemsAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogItemsAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Items, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Items Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Items& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogItemsAll
{
	typedef FRequest_GetCatalogItemsAll Request;
	typedef FResponse_GetCatalogItemsAll Response;
	typedef FDelegate_GetCatalogItemsAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogItemsAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Loot
 *
 * Get a specific Loot.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogLoot : public FRequest
{
	FRequest_GetCatalogLoot();
	virtual ~FRequest_GetCatalogLoot() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	int32 LootId = 0;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogLoot : public FResponse
{
	FResponse_GetCatalogLoot(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogLoot() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Loot, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Loot Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Loot& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogLoot
{
	typedef FRequest_GetCatalogLoot Request;
	typedef FResponse_GetCatalogLoot Response;
	typedef FDelegate_GetCatalogLoot Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogLoot(InRequest, InDelegate, Priority); }
};

/* Get Catalog Loots All
 *
 * Get all Loot.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogLootsAll : public FRequest
{
	FRequest_GetCatalogLootsAll();
	virtual ~FRequest_GetCatalogLootsAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogLootsAll : public FResponse
{
	FResponse_GetCatalogLootsAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogLootsAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Loots, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Loots Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Loots& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogLootsAll
{
	typedef FRequest_GetCatalogLootsAll Request;
	typedef FResponse_GetCatalogLootsAll Response;
	typedef FDelegate_GetCatalogLootsAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogLootsAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Portal Use Ruleset
 *
 * Get a specific Portal Use Ruleset.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogPortalUseRuleset : public FRequest
{
	FRequest_GetCatalogPortalUseRuleset();
	virtual ~FRequest_GetCatalogPortalUseRuleset() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	int32 PortalUseRulesetId = 0;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogPortalUseRuleset : public FResponse
{
	FResponse_GetCatalogPortalUseRuleset(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogPortalUseRuleset() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_PortalUseRuleset, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_PortalUseRuleset Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_PortalUseRuleset& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogPortalUseRuleset
{
	typedef FRequest_GetCatalogPortalUseRuleset Request;
	typedef FResponse_GetCatalogPortalUseRuleset Response;
	typedef FDelegate_GetCatalogPortalUseRuleset Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogPortalUseRuleset(InRequest, InDelegate, Priority); }
};

/* Get Catalog Portal Use Rulesets All
 *
 * Get all Portal Use Rulesets.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogPortalUseRulesetsAll : public FRequest
{
	FRequest_GetCatalogPortalUseRulesetsAll();
	virtual ~FRequest_GetCatalogPortalUseRulesetsAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogPortalUseRulesetsAll : public FResponse
{
	FResponse_GetCatalogPortalUseRulesetsAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogPortalUseRulesetsAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_PortalUseRulesets, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_PortalUseRulesets Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_PortalUseRulesets& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogPortalUseRulesetsAll
{
	typedef FRequest_GetCatalogPortalUseRulesetsAll Request;
	typedef FResponse_GetCatalogPortalUseRulesetsAll Response;
	typedef FDelegate_GetCatalogPortalUseRulesetsAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogPortalUseRulesetsAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Price Point
 *
 * Get a specific Price Point.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogPricePoint : public FRequest
{
	FRequest_GetCatalogPricePoint();
	virtual ~FRequest_GetCatalogPricePoint() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	FString PricePointId;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogPricePoint : public FResponse
{
	FResponse_GetCatalogPricePoint(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogPricePoint() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_PricePoint, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_PricePoint Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_PricePoint& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogPricePoint
{
	typedef FRequest_GetCatalogPricePoint Request;
	typedef FResponse_GetCatalogPricePoint Response;
	typedef FDelegate_GetCatalogPricePoint Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogPricePoint(InRequest, InDelegate, Priority); }
};

/* Get Catalog Price Points All
 *
 * Get all Price Points.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogPricePointsAll : public FRequest
{
	FRequest_GetCatalogPricePointsAll();
	virtual ~FRequest_GetCatalogPricePointsAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogPricePointsAll : public FResponse
{
	FResponse_GetCatalogPricePointsAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogPricePointsAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_PricePoints, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_PricePoints Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_PricePoints& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogPricePointsAll
{
	typedef FRequest_GetCatalogPricePointsAll Request;
	typedef FResponse_GetCatalogPricePointsAll Response;
	typedef FDelegate_GetCatalogPricePointsAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogPricePointsAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Time Frame
 *
 * Get a specific Time Frame.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogTimeFrame : public FRequest
{
	FRequest_GetCatalogTimeFrame();
	virtual ~FRequest_GetCatalogTimeFrame() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	int32 TimeFrameId = 0;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogTimeFrame : public FResponse
{
	FResponse_GetCatalogTimeFrame(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogTimeFrame() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_TimeFrame, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_TimeFrame Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_TimeFrame& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogTimeFrame
{
	typedef FRequest_GetCatalogTimeFrame Request;
	typedef FResponse_GetCatalogTimeFrame Response;
	typedef FDelegate_GetCatalogTimeFrame Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogTimeFrame(InRequest, InDelegate, Priority); }
};

/* Get Catalog Time Frames All
 *
 * Get all Time Frames.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogTimeFramesAll : public FRequest
{
	FRequest_GetCatalogTimeFramesAll();
	virtual ~FRequest_GetCatalogTimeFramesAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogTimeFramesAll : public FResponse
{
	FResponse_GetCatalogTimeFramesAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogTimeFramesAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_TimeFrames, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_TimeFrames Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_TimeFrames& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogTimeFramesAll
{
	typedef FRequest_GetCatalogTimeFramesAll Request;
	typedef FResponse_GetCatalogTimeFramesAll Response;
	typedef FDelegate_GetCatalogTimeFramesAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogTimeFramesAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Vendor
 *
 * Get a specific Vendor.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogVendor : public FRequest
{
	FRequest_GetCatalogVendor();
	virtual ~FRequest_GetCatalogVendor() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	int32 VendorId = 0;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogVendor : public FResponse
{
	FResponse_GetCatalogVendor(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogVendor() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Vendor, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Vendor Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Vendor& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogVendor
{
	typedef FRequest_GetCatalogVendor Request;
	typedef FResponse_GetCatalogVendor Response;
	typedef FDelegate_GetCatalogVendor Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogVendor(InRequest, InDelegate, Priority); }
};

/* Get Catalog Vendors All
 *
 * Get all Vendors.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogVendorsAll : public FRequest
{
	FRequest_GetCatalogVendorsAll();
	virtual ~FRequest_GetCatalogVendorsAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogVendorsAll : public FResponse
{
	FResponse_GetCatalogVendorsAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogVendorsAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_Vendors, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Vendors Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Vendors& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogVendorsAll
{
	typedef FRequest_GetCatalogVendorsAll Request;
	typedef FResponse_GetCatalogVendorsAll Response;
	typedef FDelegate_GetCatalogVendorsAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogVendorsAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Xp All
 *
 * Get all XP Tables.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogXpAll : public FRequest
{
	FRequest_GetCatalogXpAll();
	virtual ~FRequest_GetCatalogXpAll() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogXpAll : public FResponse
{
	FResponse_GetCatalogXpAll(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogXpAll() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_XpTables, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_XpTables Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_XpTables& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogXpAll
{
	typedef FRequest_GetCatalogXpAll Request;
	typedef FResponse_GetCatalogXpAll Response;
	typedef FDelegate_GetCatalogXpAll Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogXpAll(InRequest, InDelegate, Priority); }
};

/* Get Catalog Xp Table
 *
 * Get a specific XP Table.
*/
struct RALLYHEREAPI_API FRequest_GetCatalogXpTable : public FRequest
{
	FRequest_GetCatalogXpTable();
	virtual ~FRequest_GetCatalogXpTable() = default;
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	FString ComputePath() const override;
	FName GetSimplifiedPath() const override;
	FName GetSimplifiedPathWithVerb() const override;
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	TSharedPtr<FAuthContext> AuthContext;
	int32 XpTableId = 0;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed. */
	TOptional<FString> IfNoneMatch;
};

struct RALLYHEREAPI_API FResponse_GetCatalogXpTable : public FResponse
{
	FResponse_GetCatalogXpTable(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_GetCatalogXpTable() = default;
	bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	bool ParseHeaders() override;
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

	typedef TVariant<FRHAPI_XpTable, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
protected:
	ContentVariantType ParsedContent;
public:
	template<typename T>
	bool TryGetContent(T& OutResponse)const { const T* OutResponsePtr = ParsedContent.TryGet<T>(); if (OutResponsePtr != nullptr) OutResponse = *OutResponsePtr; return OutResponsePtr != nullptr; }
	template<typename T>
	const T* TryGetContent() const { return ParsedContent.TryGet<T>(); }

	#if ALLOW_LEGACY_RESPONSE_CONTENT
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_XpTable Content;
	#endif
	
	
	// Headers
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> ETag;

	// Manual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_XpTable& OutContent) const;
	/* Used to identify this version of the content.  Provide with a get request to avoid downloading the same data multiple times. */
	TOptional<FString> GetHeader200_ETag() const;

	/* Response 304
	Content still has the same etag and has not changed
	*/

	/* Response 403
	Forbidden
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	Not Found
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

};

struct RALLYHEREAPI_API Traits_GetCatalogXpTable
{
	typedef FRequest_GetCatalogXpTable Request;
	typedef FResponse_GetCatalogXpTable Response;
	typedef FDelegate_GetCatalogXpTable Delegate;
	typedef FCatalogAPI API;
	static FString Name;

	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 Priority = DefaultRallyHereAPIPriority) { return InAPI->GetCatalogXpTable(InRequest, InDelegate, Priority); }
};


}
