// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "CoreMinimal.h"
#include "RallyHereAPIAuthContext.h"
#include "RallyHereAPIHelpers.h"
#include "OffsetReset.h"
#include "HTTPValidationError.h"
#include "HzApiErrorModel.h"
#include "Notification.h"
#include "NotificationCreateResult.h"
#include "NotificationCreates.h"
#include "Notifications.h"

namespace RallyHereAPI
{
using RallyHereAPI::ToStringFormatArg;
using RallyHereAPI::WriteJsonValue;
using RallyHereAPI::TryGetJsonValue;

// forward declaration
class FPlayerIdNotificationAPI;

/**
 * @brief Create Notification
 * Create new notification for client.  Requires permission to create for a different client
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:write`
 * 
 * - For the playerid themselves any of: `notification:playerid:self:*`, `notification:playerid:self:write`
*/
struct RALLYHEREAPI_API FRequest_PlayeridCreateNotification : public FRequest
{
	FRequest_PlayeridCreateNotification();
	virtual ~FRequest_PlayeridCreateNotification() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	int32 PlayerId = 0;
	FRHAPI_NotificationCreates NotificationCreates;
};

/** The response type for FRequest_PlayeridCreateNotification */
struct RALLYHEREAPI_API FResponse_PlayeridCreateNotification : public FResponse
{
	FResponse_PlayeridCreateNotification(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridCreateNotification() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_NotificationCreateResult, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_NotificationCreateResult Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_NotificationCreateResult& OutContent) const { return TryGetContent<FRHAPI_NotificationCreateResult>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_NotificationCreateResult>& OutContent) const { return TryGetContent<FRHAPI_NotificationCreateResult>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_NotificationCreateResult* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_NotificationCreateResult>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_NotificationCreateResult> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_NotificationCreateResult>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_NotificationCreateResult& OutContent) const;

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridCreateNotification */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridCreateNotification, const FResponse_PlayeridCreateNotification&);

/** @brief A helper metadata object for PlayeridCreateNotification that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridCreateNotification
{
	/** The request type */
	typedef FRequest_PlayeridCreateNotification Request;
	/** The response type */
	typedef FResponse_PlayeridCreateNotification Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridCreateNotification Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Create Notification Self
 * Create new notification for client.
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:self:*`, `notification:playerid:self:write`, `notification:playerid:write`
*/
struct RALLYHEREAPI_API FRequest_PlayeridCreateNotificationSelf : public FRequest
{
	FRequest_PlayeridCreateNotificationSelf();
	virtual ~FRequest_PlayeridCreateNotificationSelf() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	FRHAPI_NotificationCreates NotificationCreates;
};

/** The response type for FRequest_PlayeridCreateNotificationSelf */
struct RALLYHEREAPI_API FResponse_PlayeridCreateNotificationSelf : public FResponse
{
	FResponse_PlayeridCreateNotificationSelf(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridCreateNotificationSelf() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_NotificationCreateResult, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_NotificationCreateResult Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_NotificationCreateResult& OutContent) const { return TryGetContent<FRHAPI_NotificationCreateResult>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_NotificationCreateResult>& OutContent) const { return TryGetContent<FRHAPI_NotificationCreateResult>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_NotificationCreateResult* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_NotificationCreateResult>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_NotificationCreateResult> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_NotificationCreateResult>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_NotificationCreateResult& OutContent) const;

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridCreateNotificationSelf */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridCreateNotificationSelf, const FResponse_PlayeridCreateNotificationSelf&);

/** @brief A helper metadata object for PlayeridCreateNotificationSelf that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridCreateNotificationSelf
{
	/** The request type */
	typedef FRequest_PlayeridCreateNotificationSelf Request;
	/** The response type */
	typedef FResponse_PlayeridCreateNotificationSelf Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridCreateNotificationSelf Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Get Notification By Id
 * Retrieve a single notification by id
 * 
 * This version can be used for any client provided its id (with proper permissions)
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:read`
 * 
 * - For the playerid themselves any of: `notification:playerid:self:*`, `notification:playerid:self:read`
*/
struct RALLYHEREAPI_API FRequest_PlayeridGetNotificationById : public FRequest
{
	FRequest_PlayeridGetNotificationById();
	virtual ~FRequest_PlayeridGetNotificationById() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	FString NotificationId;
	int32 PlayerId = 0;
};

/** The response type for FRequest_PlayeridGetNotificationById */
struct RALLYHEREAPI_API FResponse_PlayeridGetNotificationById : public FResponse
{
	FResponse_PlayeridGetNotificationById(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridGetNotificationById() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_Notification, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Notification Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_Notification& OutContent) const { return TryGetContent<FRHAPI_Notification>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_Notification>& OutContent) const { return TryGetContent<FRHAPI_Notification>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_Notification* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_Notification>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_Notification> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_Notification>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Notification& OutContent) const;

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	 Error Codes: - resource_not_found - Notification could not be found 
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridGetNotificationById */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridGetNotificationById, const FResponse_PlayeridGetNotificationById&);

/** @brief A helper metadata object for PlayeridGetNotificationById that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridGetNotificationById
{
	/** The request type */
	typedef FRequest_PlayeridGetNotificationById Request;
	/** The response type */
	typedef FResponse_PlayeridGetNotificationById Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridGetNotificationById Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Get Notification By Id Self
 * Retrieve a single notification by id
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:read`, `notification:playerid:self:*`, `notification:playerid:self:read`
*/
struct RALLYHEREAPI_API FRequest_PlayeridGetNotificationByIdSelf : public FRequest
{
	FRequest_PlayeridGetNotificationByIdSelf();
	virtual ~FRequest_PlayeridGetNotificationByIdSelf() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	FString NotificationId;
};

/** The response type for FRequest_PlayeridGetNotificationByIdSelf */
struct RALLYHEREAPI_API FResponse_PlayeridGetNotificationByIdSelf : public FResponse
{
	FResponse_PlayeridGetNotificationByIdSelf(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridGetNotificationByIdSelf() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_Notification, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Notification Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_Notification& OutContent) const { return TryGetContent<FRHAPI_Notification>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_Notification>& OutContent) const { return TryGetContent<FRHAPI_Notification>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_Notification* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_Notification>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_Notification> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_Notification>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Notification& OutContent) const;

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 404
	 Error Codes: - resource_not_found - Notification could not be found 
	*/
	bool TryGetContentFor404(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridGetNotificationByIdSelf */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridGetNotificationByIdSelf, const FResponse_PlayeridGetNotificationByIdSelf&);

/** @brief A helper metadata object for PlayeridGetNotificationByIdSelf that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridGetNotificationByIdSelf
{
	/** The request type */
	typedef FRequest_PlayeridGetNotificationByIdSelf Request;
	/** The response type */
	typedef FResponse_PlayeridGetNotificationByIdSelf Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridGetNotificationByIdSelf Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Get Notifications Page
 * Get recent notifications ordered from the newest to the oldest.
 * 
 * It is important to stress that this endpoint returns notifications in reverse order compared to the streaming API.
 * The first notification returned from this will be the newest one we can find, and older ones will be further down
 * the page (or on later pages).
 * 
 * This API is useful for displaying a list of the most recent notifications to the user, only requesting further
 * pages when the user requests a bigger list.
 * 
 * Client are expected to poll this endpoint regularly.
 * 
 * This version can be used for any client provided its id (with proper permissions)
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:read`
 * 
 * - For the playerid themselves any of: `notification:playerid:self:*`, `notification:playerid:self:read`
*/
struct RALLYHEREAPI_API FRequest_PlayeridGetNotificationsPage : public FRequest
{
	FRequest_PlayeridGetNotificationsPage();
	virtual ~FRequest_PlayeridGetNotificationsPage() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	int32 PlayerId = 0;
	TOptional<int32> PageSize;
	/* Return results starting at this index (inclusive).  If none provided then will start at the latest notification.  You cannot depend on the format of this string, and it must be considered opaque */
	TOptional<FString> StartAt;
	/* All notifications including and before this (chronologically) provided id will be ignored when returning results.  You cannot depend on the format of this string, and it must be considered opaque */
	TOptional<FString> ExcludeBefore;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed */
	TOptional<FString> IfNoneMatch;
};

/** The response type for FRequest_PlayeridGetNotificationsPage */
struct RALLYHEREAPI_API FResponse_PlayeridGetNotificationsPage : public FResponse
{
	FResponse_PlayeridGetNotificationsPage(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridGetNotificationsPage() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_Notifications, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Notifications Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_Notifications& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_Notifications>& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_Notifications* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_Notifications>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_Notifications> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_Notifications>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Notifications& OutContent) const;

	/* Response 304
	Not Modified
	*/

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridGetNotificationsPage */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridGetNotificationsPage, const FResponse_PlayeridGetNotificationsPage&);

/** @brief A helper metadata object for PlayeridGetNotificationsPage that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridGetNotificationsPage
{
	/** The request type */
	typedef FRequest_PlayeridGetNotificationsPage Request;
	/** The response type */
	typedef FResponse_PlayeridGetNotificationsPage Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridGetNotificationsPage Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Get Notifications Page Self
 * Get recent notifications ordered from the newest to the oldest.
 * 
 * It is important to stress that this endpoint returns notifications in reverse order compared to the streaming API.
 * The first notification returned from this will be the newest one we can find, and older ones will be further down
 * the page (or on later pages).
 * 
 * This API is useful for displaying a list of the most recent notifications to the user, only requesting further
 * pages when the user requests a bigger list.
 * 
 * Client are expected to poll this endpoint regularly.
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:read`, `notification:playerid:self:*`, `notification:playerid:self:read`
*/
struct RALLYHEREAPI_API FRequest_PlayeridGetNotificationsPageSelf : public FRequest
{
	FRequest_PlayeridGetNotificationsPageSelf();
	virtual ~FRequest_PlayeridGetNotificationsPageSelf() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	TOptional<int32> PageSize;
	/* Return results starting at this index (inclusive).  If none provided then will start at the latest notification.  You cannot depend on the format of this string, and it must be considered opaque */
	TOptional<FString> StartAt;
	/* All notifications including and before this (chronologically) provided id will be ignored when returning results.  You cannot depend on the format of this string, and it must be considered opaque */
	TOptional<FString> ExcludeBefore;
	/* If you provide the ETag that matches the current ETag for this content, will return a 304 response - indicating that the content has not changed */
	TOptional<FString> IfNoneMatch;
};

/** The response type for FRequest_PlayeridGetNotificationsPageSelf */
struct RALLYHEREAPI_API FResponse_PlayeridGetNotificationsPageSelf : public FResponse
{
	FResponse_PlayeridGetNotificationsPageSelf(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridGetNotificationsPageSelf() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_Notifications, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Notifications Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_Notifications& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_Notifications>& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_Notifications* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_Notifications>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_Notifications> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_Notifications>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Notifications& OutContent) const;

	/* Response 304
	Not Modified
	*/

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridGetNotificationsPageSelf */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridGetNotificationsPageSelf, const FResponse_PlayeridGetNotificationsPageSelf&);

/** @brief A helper metadata object for PlayeridGetNotificationsPageSelf that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridGetNotificationsPageSelf
{
	/** The request type */
	typedef FRequest_PlayeridGetNotificationsPageSelf Request;
	/** The response type */
	typedef FResponse_PlayeridGetNotificationsPageSelf Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridGetNotificationsPageSelf Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Long Poll For Notifications
 * This endpoint will return notifications newer than `exclude_before`.  This endpoint returns notifications
 * from older to newer, which is the opposite of the paging API.  The returned `cursor` value can be used as
 * `exclude_before` in subsequent polls to ensure you only receive new notifications.
 * 
 * This operation is a long-poll.  That means we will keep the connection open until we get any notification
 * or until the passed in deadline (to the best of our ability).  Once one of these happens, we will return
 * the notifications found.
 * 
 * This version can be used for any client provided its id (with proper permissions)
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:read`
 * 
 * - For the playerid themselves any of: `notification:playerid:self:*`, `notification:playerid:self:read`
*/
struct RALLYHEREAPI_API FRequest_PlayeridLongPollForNotifications : public FRequest
{
	FRequest_PlayeridLongPollForNotifications();
	virtual ~FRequest_PlayeridLongPollForNotifications() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	int32 PlayerId = 0;
	/* Max number of entries to return at one time */
	TOptional<int32> MaxPageSize;
	/* All notifications including and before this (chronologically) provided id will be ignored when returning results.  You cannot depend on the format of this string, and it must be considered opaque */
	TOptional<FString> ExcludeBefore;
	/* When `exclude_before` is not found in the stream or not given, begin streaming messages from the earliest/latest message */
	TOptional<ERHAPI_OffsetReset> OffsetResetStrategy;
	/* We will try to the best of our ability to return by this deadline, even when we have no notifications.  Value should be in seconds */
	TOptional<int32> Deadline;
};

/** The response type for FRequest_PlayeridLongPollForNotifications */
struct RALLYHEREAPI_API FResponse_PlayeridLongPollForNotifications : public FResponse
{
	FResponse_PlayeridLongPollForNotifications(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridLongPollForNotifications() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_Notifications, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Notifications Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_Notifications& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_Notifications>& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_Notifications* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_Notifications>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_Notifications> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_Notifications>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Notifications& OutContent) const;

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridLongPollForNotifications */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridLongPollForNotifications, const FResponse_PlayeridLongPollForNotifications&);

/** @brief A helper metadata object for PlayeridLongPollForNotifications that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridLongPollForNotifications
{
	/** The request type */
	typedef FRequest_PlayeridLongPollForNotifications Request;
	/** The response type */
	typedef FResponse_PlayeridLongPollForNotifications Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridLongPollForNotifications Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};

/**
 * @brief Long Poll For Notifications Self
 * This endpoint will return notifications newer than `exclude_before`.  This endpoint returns notifications
 * from older to newer, which is the opposite of the paging API.  The returned `cursor` value can be used as
 * `exclude_before` in subsequent polls to ensure you only receive new notifications.
 * 
 * This operation is a long-poll.  That means we will keep the connection open until we get any notification
 * or until the passed in deadline (to the best of our ability).  Once one of these happens, we will return
 * the notifications found.
 * 
 * Required Permissions:
 * 
 * - For any playerid (including themselves) any of: `notification:playerid:*`, `notification:playerid:read`, `notification:playerid:self:*`, `notification:playerid:self:read`
*/
struct RALLYHEREAPI_API FRequest_PlayeridLongPollForNotificationsSelf : public FRequest
{
	FRequest_PlayeridLongPollForNotificationsSelf();
	virtual ~FRequest_PlayeridLongPollForNotificationsSelf() = default;
	
	/** @brief Given a http request, apply data and settings from this request object to it */
	bool SetupHttpRequest(const FHttpRequestRef& HttpRequest) const override;
	/** @brief Compute the URL path for this request instance */
	FString ComputePath() const override;
	/** @brief Get the simplified URL path for this request, not including the verb */
	FName GetSimplifiedPath() const override;
	/** @brief Get the simplified URL path for this request, including the verb */
	FName GetSimplifiedPathWithVerb() const override;
	/** @brief Get the auth context used for this request */
	TSharedPtr<FAuthContext> GetAuthContext() const override { return AuthContext; }

	/** The specified auth context to use for this request */
	TSharedPtr<FAuthContext> AuthContext;
	/* Max number of entries to return at one time */
	TOptional<int32> MaxPageSize;
	/* All notifications including and before this (chronologically) provided id will be ignored when returning results.  You cannot depend on the format of this string, and it must be considered opaque */
	TOptional<FString> ExcludeBefore;
	/* When `exclude_before` is not found in the stream or not given, begin streaming messages from the earliest/latest message */
	TOptional<ERHAPI_OffsetReset> OffsetResetStrategy;
	/* We will try to the best of our ability to return by this deadline, even when we have no notifications.  Value should be in seconds */
	TOptional<int32> Deadline;
};

/** The response type for FRequest_PlayeridLongPollForNotificationsSelf */
struct RALLYHEREAPI_API FResponse_PlayeridLongPollForNotificationsSelf : public FResponse
{
	FResponse_PlayeridLongPollForNotificationsSelf(FRequestMetadata InRequestMetadata);
	//virtual ~FResponse_PlayeridLongPollForNotificationsSelf() = default;
	
	/** @brief Parse out response content into local storage from a given JsonValue */
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override;
	/** @brief Parse out header information for later usage */
	virtual bool ParseHeaders() override;
	/** @brief Gets the description of the response code */
	virtual FString GetHttpResponseCodeDescription(EHttpResponseCodes::Type InHttpResponseCode) const override;

protected:
	/** Variant type representing the potential content responses for this call */
	typedef TVariant<FRHAPI_Notifications, FRHAPI_HzApiErrorModel, FRHAPI_HTTPValidationError> ContentVariantType;
	
	/** A variant containing the parsed content */
	ContentVariantType ParsedContent;

	/** A parsed map of the headers from the request */
	TMap<FString, FString> HeadersMap;

public:
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(T& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @param [out] OutContent A copy of the response data, if the type matched
	 * @return Whether or not the response was of the given type
	 */
	template<typename T>
	bool TryGetContent(TOptional<T>& OutContent)const { const T* OutContentPtr = ParsedContent.TryGet<T>(); if (OutContentPtr != nullptr) OutContent = *OutContentPtr; else OutContent.Reset(); return OutContentPtr != nullptr; }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A pointer to the content, if it was the specified type.  The memory is owned by the response object!
	 */
	template<typename T>
	const T* TryGetContentAsPointer() const { return ParsedContent.TryGet<T>(); }
	/**
	 * @brief Attempt to get the response content in a specific type
	 * @return A optional object to the content, if it was the specified type.  The memory is owned by the returned optional object, which contains a copy of the value, if valid.
	 */
	template<typename T>
	const TOptional<T> TryGetContentAsOptional() const { const auto Ptr = TryGetContentAsPointer<T>(); return Ptr != nullptr ? *Ptr : TOptional<T>(); }
	
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A string to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, FString& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @param [out] OutValue A TOptional<FString> to store the header value to, if found
	 * @return Whether or not the header was found
	 */
	bool TryGetHeader(const FString& Header, TOptional<FString>& OutValue) const { const auto OutValuePtr = HeadersMap.Find(Header); if (OutValuePtr != nullptr) OutValue = *OutValuePtr; else OutValue.Reset(); return OutValuePtr != nullptr; }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return A pointer to the header string value, if found.  The memory is owned by the response object!
	 */
	const FString* TryGetHeaderAsPointer(const FString& Header) const { return HeadersMap.Find(Header); }
	/**
	 * @brief Attempt to fetch a header by name
	 * @param [in] Header The name of the header to fetch
	 * @return An optional string of the header string value, if found.  The memory is owned by the returned optional object, which contains a copy of the value if valid.
	 */
	const TOptional<FString> TryGetHeaderAsOptional(const FString& Header) const { const auto Ptr = HeadersMap.Find(Header); return Ptr != nullptr ? *Ptr : TOptional<FString>(); }

#if ALLOW_LEGACY_RESPONSE_CONTENT
	/** Default Response Content */
	UE_DEPRECATED(5.0, "Direct use of Content is deprecated, please use TryGetDefaultContent(), TryGetContent(), TryGetResponse<>(), or TryGetContentFor<>() instead.")
	FRHAPI_Notifications Content;
	

#endif //ALLOW_LEGACY_RESPONSE_CONTENT

	// Default Response Helpers
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(FRHAPI_Notifications& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	bool TryGetDefaultContent(TOptional<FRHAPI_Notifications>& OutContent) const { return TryGetContent<FRHAPI_Notifications>(OutContent); }
	/** @brief Attempt to retrieve the content in the default response */
	const FRHAPI_Notifications* TryGetDefaultContentAsPointer() const { return TryGetContentAsPointer<FRHAPI_Notifications>(); }
	/** @brief Attempt to retrieve the content in the default response */
	TOptional<FRHAPI_Notifications> TryGetDefaultContentAsOptional() const { return TryGetContentAsOptional<FRHAPI_Notifications>(); }

	// Individual Response Helpers	
	/* Response 200
	Successful Response
	*/
	bool TryGetContentFor200(FRHAPI_Notifications& OutContent) const;

	/* Response 400
	 Error Codes: - bad_id - Passed client id is not a valid id 
	*/
	bool TryGetContentFor400(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 403
	 Error Codes: - auth_invalid_version - Invalid Authorization - version - auth_token_invalid_claim - Token contained invalid claim value: {} - auth_invalid_key_id - Invalid Authorization - Invalid Key ID in Access Token - auth_malformed_access - Invalid Authorization - malformed access token - auth_token_sig_invalid - Token Signature is invalid - auth_token_format - Invalid Authorization - {} - auth_token_expired - Token is expired - insufficient_permissions - Insufficient Permissions - auth_token_unknown - Failed to parse token - auth_not_jwt - Invalid Authorization 
	*/
	bool TryGetContentFor403(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 409
	 Error Codes: - too_many_listening_to_single_client - An enumeration. 
	*/
	bool TryGetContentFor409(FRHAPI_HzApiErrorModel& OutContent) const;

	/* Response 422
	Validation Error
	*/
	bool TryGetContentFor422(FRHAPI_HTTPValidationError& OutContent) const;

	/* Response 503
	 Error Codes: - connection_limit_reached - An enumeration. 
	*/
	bool TryGetContentFor503(FRHAPI_HzApiErrorModel& OutContent) const;

};

/** The delegate class for FRequest_PlayeridLongPollForNotificationsSelf */
DECLARE_DELEGATE_OneParam(FDelegate_PlayeridLongPollForNotificationsSelf, const FResponse_PlayeridLongPollForNotificationsSelf&);

/** @brief A helper metadata object for PlayeridLongPollForNotificationsSelf that defines the relationship between Request, Delegate, API, etc.  Intended for use with templating */
struct RALLYHEREAPI_API Traits_PlayeridLongPollForNotificationsSelf
{
	/** The request type */
	typedef FRequest_PlayeridLongPollForNotificationsSelf Request;
	/** The response type */
	typedef FResponse_PlayeridLongPollForNotificationsSelf Response;
	/** The delegate type, triggered by the response */
	typedef FDelegate_PlayeridLongPollForNotificationsSelf Delegate;
	/** The API object that supports this API call */
	typedef FPlayerIdNotificationAPI API;
	/** A human readable name for this API call */
	static FString Name;

	/**
	 * @brief A helper that uses all of the above types to initiate an API call, with a specified priority.
	 * @param [in] InAPI The API object the call will be made with
	 * @param [in] InRequest The request to submit to the API call
	 * @param [in] InDelegate An optional delegate to call when the API call completes, containing the response information
	 * @param [in] InPriority An optional priority override for the API call, for use when API calls are being throttled
	 * @return A http request object, if the call was successfully queued.
	 */
	static FHttpRequestPtr DoCall(TSharedRef<API> InAPI, const Request& InRequest, Delegate InDelegate = Delegate(), int32 InPriority = DefaultRallyHereAPIPriority);
};


/** The API class itself, which will handle calls to */
class RALLYHEREAPI_API FPlayerIdNotificationAPI : public FAPI
{
public:
	FPlayerIdNotificationAPI();
	virtual ~FPlayerIdNotificationAPI();

	FHttpRequestPtr PlayeridCreateNotification(const FRequest_PlayeridCreateNotification& Request, const FDelegate_PlayeridCreateNotification& Delegate = FDelegate_PlayeridCreateNotification(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridCreateNotificationSelf(const FRequest_PlayeridCreateNotificationSelf& Request, const FDelegate_PlayeridCreateNotificationSelf& Delegate = FDelegate_PlayeridCreateNotificationSelf(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridGetNotificationById(const FRequest_PlayeridGetNotificationById& Request, const FDelegate_PlayeridGetNotificationById& Delegate = FDelegate_PlayeridGetNotificationById(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridGetNotificationByIdSelf(const FRequest_PlayeridGetNotificationByIdSelf& Request, const FDelegate_PlayeridGetNotificationByIdSelf& Delegate = FDelegate_PlayeridGetNotificationByIdSelf(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridGetNotificationsPage(const FRequest_PlayeridGetNotificationsPage& Request, const FDelegate_PlayeridGetNotificationsPage& Delegate = FDelegate_PlayeridGetNotificationsPage(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridGetNotificationsPageSelf(const FRequest_PlayeridGetNotificationsPageSelf& Request, const FDelegate_PlayeridGetNotificationsPageSelf& Delegate = FDelegate_PlayeridGetNotificationsPageSelf(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridLongPollForNotifications(const FRequest_PlayeridLongPollForNotifications& Request, const FDelegate_PlayeridLongPollForNotifications& Delegate = FDelegate_PlayeridLongPollForNotifications(), int32 Priority = DefaultRallyHereAPIPriority);
	FHttpRequestPtr PlayeridLongPollForNotificationsSelf(const FRequest_PlayeridLongPollForNotificationsSelf& Request, const FDelegate_PlayeridLongPollForNotificationsSelf& Delegate = FDelegate_PlayeridLongPollForNotificationsSelf(), int32 Priority = DefaultRallyHereAPIPriority);

private:
	void OnPlayeridCreateNotificationResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridCreateNotification Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridCreateNotificationSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridCreateNotificationSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridGetNotificationByIdResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridGetNotificationById Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridGetNotificationByIdSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridGetNotificationByIdSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridGetNotificationsPageResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridGetNotificationsPage Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridGetNotificationsPageSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridGetNotificationsPageSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridLongPollForNotificationsResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridLongPollForNotifications Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);
	void OnPlayeridLongPollForNotificationsSelfResponse(FHttpRequestPtr HttpRequest, FHttpResponsePtr HttpResponse, bool bSucceeded, FDelegate_PlayeridLongPollForNotificationsSelf Delegate, FRequestMetadata RequestMetadata, TSharedPtr<FAuthContext> AuthContextForRetry, int32 Priority);

};



}
