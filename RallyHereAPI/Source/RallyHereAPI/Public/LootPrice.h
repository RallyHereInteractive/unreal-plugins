// NOTE: This file is auto generated by https://github.com/hirezstudios/rally-here-api-generator
// Do not edit the file manually.
//
// Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
// Copyright 2022-2023 RallyHere Interactive
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include "RallyHereAPIBaseModel.h"
#include "RallyHereAPIHelpers.h"
#include "LootPriceBreakpoint.h"
#include "LootPrice.generated.h"

/** @defgroup RHAPI_LootPrice RallyHere API Model LootPrice
 *  @{
 */

/**
 * @brief Price with current and original (pre-sale) price breakpoints
 */
USTRUCT(BlueprintType)
struct RALLYHEREAPI_API FRHAPI_LootPrice : public FRHAPI_Model
{
	GENERATED_BODY()

	/**
	* @brief Fills this object with data from the passed in JSON
	*
	* @param [in] JsonValue Data from the API call.
	*
	* @return true if parsing of the JSON data was successful.
	*/
	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override final;

	/**
	* @brief Writes the data from this object into the specified JSON Writer stream
	*
	* @param [in] Writer JSON Writer stream to push .
	*/
	virtual void WriteJson(TSharedRef<TJsonWriter<>>& Writer) const override final;

	/** @brief Breakpoints that the loot is available for purchase with */
	UPROPERTY(BlueprintReadWrite, Category = "RallyHere")
	TArray<FRHAPI_LootPriceBreakpoint> Breakpoints_Optional{  };
	/** @brief true if Breakpoints_Optional has been set to a value */
	UPROPERTY(BlueprintReadWrite, Category = "RallyHere")
	bool Breakpoints_IsSet{ false };
	/** @brief Gets the value of Breakpoints_Optional, regardless of it having been set */
	FORCEINLINE TArray<FRHAPI_LootPriceBreakpoint>& GetBreakpoints() { return Breakpoints_Optional; }
	/** @brief Gets the value of Breakpoints_Optional, regardless of it having been set */
	FORCEINLINE const TArray<FRHAPI_LootPriceBreakpoint>& GetBreakpoints() const { return Breakpoints_Optional; }
	/** @brief Gets the value of Breakpoints_Optional, if it has been set, otherwise it returns DefaultValue */
	FORCEINLINE const TArray<FRHAPI_LootPriceBreakpoint>& GetBreakpoints(const TArray<FRHAPI_LootPriceBreakpoint>& DefaultValue) const { if (Breakpoints_IsSet) return Breakpoints_Optional; return DefaultValue; }
	/** @brief Fills OutValue with the value of Breakpoints_Optional and returns true if it has been set, otherwise returns false */
	FORCEINLINE bool GetBreakpoints(TArray<FRHAPI_LootPriceBreakpoint>& OutValue) const { if (Breakpoints_IsSet) OutValue = Breakpoints_Optional; return Breakpoints_IsSet; }
	/** @brief Returns a pointer to Breakpoints_Optional, if it has been set, otherwise returns nullptr */
	FORCEINLINE TArray<FRHAPI_LootPriceBreakpoint>* GetBreakpointsOrNull() { if (Breakpoints_IsSet) return (&Breakpoints_Optional); return nullptr; }
	/** @brief Returns a pointer to Breakpoints_Optional, if it has been set, otherwise returns nullptr */
	FORCEINLINE const TArray<FRHAPI_LootPriceBreakpoint>* GetBreakpointsOrNull() const { if (Breakpoints_IsSet) return (&Breakpoints_Optional); return nullptr; }
	/** @brief Sets the value of Breakpoints_Optional and also sets Breakpoints_IsSet to true */
	FORCEINLINE void SetBreakpoints(const TArray<FRHAPI_LootPriceBreakpoint>& NewValue) { Breakpoints_Optional = NewValue; Breakpoints_IsSet = true;  }
	/** @brief Sets the value of Breakpoints_Optional and also sets Breakpoints_IsSet to true using move semantics */
	FORCEINLINE void SetBreakpoints(TArray<FRHAPI_LootPriceBreakpoint>&& NewValue) { Breakpoints_Optional = NewValue; Breakpoints_IsSet = true;  }
	/** @brief Clears the value of Breakpoints_Optional and sets Breakpoints_IsSet to false */
	void ClearBreakpoints() { Breakpoints_IsSet = false;  }

	/** @brief Does the number of units being purchased need to be an exact match to the quantity on a Price Breakpoint? */
	UPROPERTY(BlueprintReadWrite, Category = "RallyHere")
	bool StrictFlag_Optional{ false };
	/** @brief true if StrictFlag_Optional has been set to a value */
	UPROPERTY(BlueprintReadWrite, Category = "RallyHere")
	bool StrictFlag_IsSet{ false };
	/** @brief Gets the value of StrictFlag_Optional, regardless of it having been set */
	FORCEINLINE bool& GetStrictFlag() { return StrictFlag_Optional; }
	/** @brief Gets the value of StrictFlag_Optional, regardless of it having been set */
	FORCEINLINE const bool& GetStrictFlag() const { return StrictFlag_Optional; }
	/** @brief Gets the value of StrictFlag_Optional, if it has been set, otherwise it returns DefaultValue */
	FORCEINLINE const bool& GetStrictFlag(const bool& DefaultValue) const { if (StrictFlag_IsSet) return StrictFlag_Optional; return DefaultValue; }
	/** @brief Fills OutValue with the value of StrictFlag_Optional and returns true if it has been set, otherwise returns false */
	FORCEINLINE bool GetStrictFlag(bool& OutValue) const { if (StrictFlag_IsSet) OutValue = StrictFlag_Optional; return StrictFlag_IsSet; }
	/** @brief Returns a pointer to StrictFlag_Optional, if it has been set, otherwise returns nullptr */
	FORCEINLINE bool* GetStrictFlagOrNull() { if (StrictFlag_IsSet) return (&StrictFlag_Optional); return nullptr; }
	/** @brief Returns a pointer to StrictFlag_Optional, if it has been set, otherwise returns nullptr */
	FORCEINLINE const bool* GetStrictFlagOrNull() const { if (StrictFlag_IsSet) return (&StrictFlag_Optional); return nullptr; }
	/** @brief Sets the value of StrictFlag_Optional and also sets StrictFlag_IsSet to true */
	FORCEINLINE void SetStrictFlag(const bool& NewValue) { StrictFlag_Optional = NewValue; StrictFlag_IsSet = true;  }
	/** @brief Sets the value of StrictFlag_Optional and also sets StrictFlag_IsSet to true using move semantics */
	FORCEINLINE void SetStrictFlag(bool&& NewValue) { StrictFlag_Optional = NewValue; StrictFlag_IsSet = true;  }
	/** @brief Clears the value of StrictFlag_Optional and sets StrictFlag_IsSet to false */
	void ClearStrictFlag() { StrictFlag_Optional = false; StrictFlag_IsSet = false;  }
	/** @brief Returns the default value of StrictFlag */
	FORCEINLINE bool GetDefaultValue_StrictFlag() { return false; }

	/** @brief Can the number of units being purchased be higher than the highest quantity on the Price Breakpoints? */
	UPROPERTY(BlueprintReadWrite, Category = "RallyHere")
	bool CapFlag_Optional{ false };
	/** @brief true if CapFlag_Optional has been set to a value */
	UPROPERTY(BlueprintReadWrite, Category = "RallyHere")
	bool CapFlag_IsSet{ false };
	/** @brief Gets the value of CapFlag_Optional, regardless of it having been set */
	FORCEINLINE bool& GetCapFlag() { return CapFlag_Optional; }
	/** @brief Gets the value of CapFlag_Optional, regardless of it having been set */
	FORCEINLINE const bool& GetCapFlag() const { return CapFlag_Optional; }
	/** @brief Gets the value of CapFlag_Optional, if it has been set, otherwise it returns DefaultValue */
	FORCEINLINE const bool& GetCapFlag(const bool& DefaultValue) const { if (CapFlag_IsSet) return CapFlag_Optional; return DefaultValue; }
	/** @brief Fills OutValue with the value of CapFlag_Optional and returns true if it has been set, otherwise returns false */
	FORCEINLINE bool GetCapFlag(bool& OutValue) const { if (CapFlag_IsSet) OutValue = CapFlag_Optional; return CapFlag_IsSet; }
	/** @brief Returns a pointer to CapFlag_Optional, if it has been set, otherwise returns nullptr */
	FORCEINLINE bool* GetCapFlagOrNull() { if (CapFlag_IsSet) return (&CapFlag_Optional); return nullptr; }
	/** @brief Returns a pointer to CapFlag_Optional, if it has been set, otherwise returns nullptr */
	FORCEINLINE const bool* GetCapFlagOrNull() const { if (CapFlag_IsSet) return (&CapFlag_Optional); return nullptr; }
	/** @brief Sets the value of CapFlag_Optional and also sets CapFlag_IsSet to true */
	FORCEINLINE void SetCapFlag(const bool& NewValue) { CapFlag_Optional = NewValue; CapFlag_IsSet = true;  }
	/** @brief Sets the value of CapFlag_Optional and also sets CapFlag_IsSet to true using move semantics */
	FORCEINLINE void SetCapFlag(bool&& NewValue) { CapFlag_Optional = NewValue; CapFlag_IsSet = true;  }
	/** @brief Clears the value of CapFlag_Optional and sets CapFlag_IsSet to false */
	void ClearCapFlag() { CapFlag_Optional = false; CapFlag_IsSet = false;  }
	/** @brief Returns the default value of CapFlag */
	FORCEINLINE bool GetDefaultValue_CapFlag() { return false; }
};

/** @} */
