{{>licenseInfo}}
#pragma once

#include "{{unrealModuleName}}BaseModel.h"
#include "Serialization/JsonSerializer.h"
#include "Dom/JsonObject.h"
#include "Misc/Base64.h"
#include "PlatformHttp.h"
#include "Containers/Set.h"
#include "RallyHereAPIHelpers.generated.h"

struct {{unrealModelPrefix}}JsonValue;
class IHttpRequest;

constexpr int32 Default{{unrealModuleName}}Priority = 1000000;

UENUM(BlueprintType)
enum class {{unrealEnumPrefix}}JsonValueType : uint8
{
    None,
    Null,
    String,
    Number,
    Boolean,
    Array,
    Object
};

USTRUCT(BlueprintType)
struct {{dllapi}} {{unrealModelPrefix}}JsonObject
{
    GENERATED_BODY()
public:
    {{unrealModelPrefix}}JsonValue TryGetValue(const FString& FieldName) const;

    bool HasField(const FString& FieldName) const;
	void SetField(const FString& FieldName, const {{unrealModelPrefix}}JsonValue& Value) const;
	void RemoveField(const FString& FieldName) const;

	float GetFloatField(const FString& FieldName) const;
	int32 GetIntegerField(const FString& FieldName) const;
	bool TryGetFloatField(const FString& FieldName, float& OutNumber) const;
	bool TryGetNumberField(const FString& FieldName, int32& OutNumber) const;
	bool TryGetInteger64Field(const FString& FieldName, int64& OutNumber) const;
	void SetNumberField(const FString& FieldName, float Number) const;

	FString GetStringField(const FString& FieldName) const;
	bool TryGetStringField(const FString& FieldName, FString& OutString) const;
	bool TryGetStringArrayField(const FString& FieldName, TArray<FString>& OutArray) const;
	void SetStringField(const FString& FieldName, const FString& StringValue) const;

	bool GetBoolField(const FString& FieldName) const;
    bool TryGetBoolField(const FString& FieldName, bool& OutBool) const;
	void SetBoolField(const FString& FieldName, bool InValue) const;

	TArray<{{unrealModelPrefix}}JsonValue> GetArrayField(const FString& FieldName) const;
	bool TryGetArrayField(const FString& FieldName, TArray<{{unrealModelPrefix}}JsonValue>& OutArray) const;
	void SetArrayField(const FString& FieldName, const TArray<{{unrealModelPrefix}}JsonValue>& Array) const;

    {{unrealModelPrefix}}JsonObject GetObjectField(const FString& FieldName) const;
	bool TryGetObjectField(const FString& FieldName, {{unrealModelPrefix}}JsonObject& OutObject) const;
	void SetObjectField(const FString& FieldName, const {{unrealModelPrefix}}JsonObject& JsonObject) const;

    void SetObject(const TSharedPtr<FJsonObject> NewObj) { Obj = NewObj; }
    TSharedPtr<FJsonObject> GetObject() const { return Obj; }

    static {{unrealModelPrefix}}JsonObject CreateFromUnrealObject(TSharedPtr<FJsonObject> NewObj);

private:
    TSharedPtr<FJsonObject> Obj;
};


USTRUCT(BlueprintType)
struct {{dllapi}} {{unrealModelPrefix}}JsonValue
{
    GENERATED_BODY()
public:
    float AsNumber() const;
    FString AsString() const;
    bool AsBool() const;
    bool IsNull() const;
    TArray<{{unrealModelPrefix}}JsonValue> AsArray() const;
    {{unrealModelPrefix}}JsonObject AsObject() const;

    {{unrealEnumPrefix}}JsonValueType GetType() const;

	bool TryGetFloat(float& OutNumber) const;
	bool TryGetNumber(int32& OutNumber) const;
	bool TryGetInteger64(int64& OutNumber) const;
	bool TryGetString(FString& OutString) const;
	bool TryGetBool(bool& OutBool) const;
	bool TryGetArray(TArray<{{unrealModelPrefix}}JsonValue>& OutArray) const;
	bool TryGetObject({{unrealModelPrefix}}JsonObject& OutObject) const;

    void SetValue(const TSharedPtr<FJsonValue> NewValue) { Value = NewValue; }
    TSharedPtr<FJsonValue> GetValue() const { return Value; }

    static {{unrealModelPrefix}}JsonValue CreateFromUnrealValue(const TSharedPtr<FJsonValue> NewValue);

    bool CompareEqual(const {{unrealModelPrefix}}JsonValue& Other) const;

private:
    TSharedPtr<FJsonValue> Value;
};

{{#cppNamespaceDeclarations}}
namespace {{this}}
{
{{/cppNamespaceDeclarations}}

//////////////////////////////////////////////////////////////////////////

class {{dllapi}} FHttpFileInput
{
public:
	explicit FHttpFileInput(const TCHAR* InFilePath);
	explicit FHttpFileInput(const FString& InFilePath);

	// This will automatically set the content type if not already set
    void SetFilePath(const TCHAR* InFilePath);
	void SetFilePath(const FString& InFilePath);

    // Optional if it can be deduced from the FilePath
    void SetContentType(const TCHAR* ContentType);

	FHttpFileInput& operator=(const FHttpFileInput& Other) = default;
	FHttpFileInput& operator=(const FString& InFilePath) { SetFilePath(*InFilePath); return*this; }
	FHttpFileInput& operator=(const TCHAR* InFilePath) { SetFilePath(InFilePath); return*this; }

	const FString& GetFilePath() const { return FilePath; }
	const FString& GetContentType() const { return ContentType; }

	// Returns the filename with extension
	FString GetFilename() const;

private:
    FString FilePath;
    FString ContentType;
};

//////////////////////////////////////////////////////////////////////////

class FHttpMultipartFormData
{
public:
	void SetBoundary(const TCHAR* InBoundary);
	void SetupHttpRequest(const FHttpRequestRef& HttpRequest);

	void AddStringPart(const TCHAR* Name, const TCHAR* Data);
	void AddJsonPart(const TCHAR* Name, const FString& JsonString);
	void AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray);
	void AddFilePart(const TCHAR* Name, const FHttpFileInput& File);

private:
	void AppendString(const TCHAR* Str);
	const FString& GetBoundary() const;

	mutable FString Boundary;
	TArray<uint8> FormData;

	static const TCHAR* Delimiter;
	static const TCHAR* Newline;
};

//////////////////////////////////////////////////////////////////////////

// Decodes Base64Url encoded strings, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
bool Base64UrlDecode(const FString& Base64String, T& Value)
{
	FString TmpCopy(Base64String);
	TmpCopy.ReplaceInline(TEXT("-"), TEXT("+"));
	TmpCopy.ReplaceInline(TEXT("_"), TEXT("/"));

	return FBase64::Decode(TmpCopy, Value);
}

// Encodes strings in Base64Url, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
FString Base64UrlEncode(const T& Value)
{
	FString Base64String = FBase64::Encode(Value);
	Base64String.ReplaceInline(TEXT("+"), TEXT("-"));
	Base64String.ReplaceInline(TEXT("/"), TEXT("_"));
	return Base64String;
}

template<typename T>
inline FStringFormatArg ToStringFormatArg(const T& Value)
{
	return FStringFormatArg(Value);
}

inline FStringFormatArg ToStringFormatArg(const FDateTime& Value)
{
	return FStringFormatArg(Value.ToIso8601());
}

inline FStringFormatArg ToStringFormatArg(const FGuid& Value)
{
	return FStringFormatArg(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline FStringFormatArg ToStringFormatArg(const TArray<uint8>& Value)
{
	return FStringFormatArg(Base64UrlEncode(Value));
}

template<typename T, typename std::enable_if<!std::is_base_of<{{unrealModelPrefix}}Model, T>::value, int>::type = 0>
inline FString ToString(const T& Value)
{
	return FString::Format(TEXT("{0}"), { ToStringFormatArg(Value) });
}

inline FString ToString(const FString& Value)
{
	return Value;
}

inline FString ToString(bool Value)
{
	return Value ? TEXT("true") : TEXT("false");
}

inline FStringFormatArg ToStringFormatArg(bool Value)
{
	return FStringFormatArg(ToString(Value));
}

inline FString ToString(const TArray<uint8>& Value)
{
	return Base64UrlEncode(Value);
}

inline FString ToString(const {{unrealModelPrefix}}Model& Value)
{
	FString String;
    TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&String);
	Value.WriteJson(Writer);
	Writer->Close();
	return String;
}

template<typename T>
inline FString ToUrlString(const T& Value)
{
	return FPlatformHttp::UrlEncode(ToString(Value));
}

template<typename T>
inline FString CollectionToUrlString(const TArray<T>& Collection, const TCHAR* Separator)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("{0}{1}"), { Separator, *ToUrlString(Collection[i]) });
	}
	return Output;
}

template<typename T>
inline FString CollectionToUrlString_csv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(","));
}

template<typename T>
inline FString CollectionToUrlString_ssv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(" "));
}

template<typename T>
inline FString CollectionToUrlString_tsv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("\t"));
}

template<typename T>
inline FString CollectionToUrlString_pipes(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("|"));
}

template<typename T>
inline FString CollectionToUrlString_multi(const TArray<T>& Collection, const TCHAR* BaseName)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	// Since this function is used to print a value string, the initial key has already been printed, so do not print it again
	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
	}
	return Output;
}

//////////////////////////////////////////////////////////////////////////

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonValue>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), "", Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const {{unrealModelPrefix}}JsonValue& Value)
{
	WriteJsonValue(Writer, Value.GetValue());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonObject>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const {{unrealModelPrefix}}JsonObject& Value)
{
	WriteJsonValue(Writer, Value.GetObject());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<uint8>& Value)
{
	Writer->WriteValue(ToString(Value));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FDateTime& Value)
{
	Writer->WriteValue(Value.ToIso8601());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FGuid& Value)
{
	Writer->WriteValue(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const {{unrealModelPrefix}}Model& Value)
{
	Value.WriteJson(Writer);
}

template<typename T, typename std::enable_if<!std::is_base_of<{{unrealModelPrefix}}Model, T>::value, int>::type = 0>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const T& Value)
{
	Writer->WriteValue(Value);
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSet<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TMap<FString, T>& Value)
{
	Writer->WriteObjectStart();
	for (const auto& It : Value)
	{
		Writer->WriteIdentifierPrefix(It.Key);
		WriteJsonValue(Writer, It.Value);
	}
	Writer->WriteObjectEnd();
}

//////////////////////////////////////////////////////////////////////////

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, {{unrealModelPrefix}}JsonValue& Value)
{
	Value.SetValue(JsonValue);
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, {{unrealModelPrefix}}JsonObject& Value)
{
	const TSharedPtr<FJsonObject>* TmpValue;
	if (JsonValue->TryGetObject(TmpValue))
	{
		Value.SetObject(*TmpValue);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FString& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

{{dllapi}} bool ParseDateTime(const FString& DateTimeString, FDateTime& OutDateTime);

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FDateTime& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return ParseDateTime(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FGuid& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return FGuid::Parse(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, bool& Value)
{
	bool TmpValue;
	if (JsonValue->TryGetBool(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonValue>& JsonObjectValue)
{
	JsonObjectValue = JsonValue;
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonObject>& JsonObjectValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		JsonObjectValue = *Object;
		return true;
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<uint8>& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Base64UrlDecode(TmpValue, Value);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, {{unrealModelPrefix}}Model& Value)
{
	return Value.FromJson(JsonValue);
}

template<typename T, typename std::enable_if<!std::is_base_of<{{unrealModelPrefix}}Model, T>::value, int>::type = 0>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	T TmpValue;
	if (JsonValue->TryGetNumber(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<T>& ArrayValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		ArrayValue.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			ArrayValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSet<T>& SetValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		SetValue.Reset();
		SetValue.Reserve(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			SetValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TMap<FString, T>& MapValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		MapValue.Reset();
		bool ParseSuccess = true;
		for (const auto& It : (*Object)->Values)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue(It.Value, TmpValue);
			MapValue.Emplace(It.Key, MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TOptional<T>& OptionalValue)
{
	if (JsonObject->HasField(Key))
	{
		T Value;
		const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
		if (JsonValue.IsValid() && !JsonValue->IsNull())
		{
			if (TryGetJsonValue(JsonValue, Value))
			{
				OptionalValue = Value;
				return true;
			}
		}

		return false;
	}
	return true; // Absence of optional value is not a parsing error
}

{{#cppNamespaceDeclarations}}
}
{{/cppNamespaceDeclarations}}
