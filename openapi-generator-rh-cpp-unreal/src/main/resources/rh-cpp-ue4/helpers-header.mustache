{{!
Copyright 2018 OpenAPI-Generator Contributors (https://openapi-generator.tech)
Copyright 2022-2023 RallyHere Interactive

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
}}
{{>licenseInfo}}
#pragma once

#include "{{unrealModuleName}}BaseModel.h"
#include "Serialization/JsonSerializer.h"
#include "Dom/JsonObject.h"
#include "Misc/Base64.h"
#include "Misc/TVariant.h"
#include "PlatformHttp.h"
#include "Containers/Set.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "{{unrealModuleName}}Helpers.generated.h"

struct {{unrealModelPrefix}}JsonValue;
class IHttpRequest;

constexpr int32 Default{{unrealModuleName}}Priority = 1000000;

UENUM(BlueprintType)
enum class {{unrealEnumPrefix}}JsonValueType : uint8
{
    None,
    Null,
    String,
    Number,
    Boolean,
    Array,
    Object
};

USTRUCT(BlueprintType)
struct {{dllapi}} {{unrealModelPrefix}}JsonObject
{
    GENERATED_BODY()
public:
    {{unrealModelPrefix}}JsonValue TryGetValue(const FString& FieldName) const;

    bool HasField(const FString& FieldName) const;
	void SetField(const FString& FieldName, const {{unrealModelPrefix}}JsonValue& Value) const;
	void RemoveField(const FString& FieldName) const;

	float GetFloatField(const FString& FieldName) const;
	int32 GetIntegerField(const FString& FieldName) const;
	bool TryGetFloatField(const FString& FieldName, float& OutNumber) const;
	bool TryGetNumberField(const FString& FieldName, int32& OutNumber) const;
	bool TryGetInteger64Field(const FString& FieldName, int64& OutNumber) const;
	void SetNumberField(const FString& FieldName, float Number) const;

	FString GetStringField(const FString& FieldName) const;
	bool TryGetStringField(const FString& FieldName, FString& OutString) const;
	bool TryGetStringArrayField(const FString& FieldName, TArray<FString>& OutArray) const;
	void SetStringField(const FString& FieldName, const FString& StringValue) const;

	bool GetBoolField(const FString& FieldName) const;
    bool TryGetBoolField(const FString& FieldName, bool& OutBool) const;
	void SetBoolField(const FString& FieldName, bool InValue) const;

	TArray<{{unrealModelPrefix}}JsonValue> GetArrayField(const FString& FieldName) const;
	bool TryGetArrayField(const FString& FieldName, TArray<{{unrealModelPrefix}}JsonValue>& OutArray) const;
	void SetArrayField(const FString& FieldName, const TArray<{{unrealModelPrefix}}JsonValue>& Array) const;

    {{unrealModelPrefix}}JsonObject GetObjectField(const FString& FieldName) const;
	bool TryGetObjectField(const FString& FieldName, {{unrealModelPrefix}}JsonObject& OutObject) const;
	void SetObjectField(const FString& FieldName, const {{unrealModelPrefix}}JsonObject& JsonObject) const;

    void SetObject(const TSharedPtr<FJsonObject> NewObj) { Obj = NewObj; }
    TSharedPtr<FJsonObject> GetObject() const { return Obj; }

    static {{unrealModelPrefix}}JsonObject CreateFromUnrealObject(TSharedPtr<FJsonObject> NewObj);

private:
    TSharedPtr<FJsonObject> Obj;
};

UCLASS()
class {{dllapi}} {{unrealClassPrefix}}JsonObjectBlueprintLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
public:

	UFUNCTION(BlueprintCallable, Category="RallyHere|Utilities")
	static bool {{unrealModelPrefix}}JsonObjectToString(const {{unrealModelPrefix}}JsonObject& InObject, FString& OutString);
	UFUNCTION(BlueprintCallable, Category="RallyHere|Utilities")
	static bool StringTo{{unrealModelPrefix}}JsonObject(const FString& InString, {{unrealModelPrefix}}JsonObject& OutObject);
};


USTRUCT(BlueprintType)
struct {{dllapi}} {{unrealModelPrefix}}JsonValue
{
    GENERATED_BODY()
public:
    float AsNumber() const;
    FString AsString() const;
    bool AsBool() const;
    bool IsNull() const;
    TArray<{{unrealModelPrefix}}JsonValue> AsArray() const;
    {{unrealModelPrefix}}JsonObject AsObject() const;

    {{unrealEnumPrefix}}JsonValueType GetType() const;

	bool TryGetFloat(float& OutNumber) const;
	bool TryGetNumber(int32& OutNumber) const;
	bool TryGetInteger64(int64& OutNumber) const;
	bool TryGetString(FString& OutString) const;
	bool TryGetBool(bool& OutBool) const;
	bool TryGetArray(TArray<{{unrealModelPrefix}}JsonValue>& OutArray) const;
	bool TryGetObject({{unrealModelPrefix}}JsonObject& OutObject) const;

    void SetValue(const TSharedPtr<FJsonValue> NewValue) { Value = NewValue; }
    TSharedPtr<FJsonValue> GetValue() const { return Value; }

    static {{unrealModelPrefix}}JsonValue CreateFromUnrealValue(const TSharedPtr<FJsonValue> NewValue);

    bool CompareEqual(const {{unrealModelPrefix}}JsonValue& Other) const;

private:
    TSharedPtr<FJsonValue> Value;
};

UCLASS()
class {{dllapi}} {{unrealClassPrefix}}JsonValueBlueprintLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
public:
	
	UFUNCTION(BlueprintCallable, Category="RallyHere|Utilities")
	static bool {{unrealModelPrefix}}JsonValueToString(const {{unrealModelPrefix}}JsonValue& InValue, FString& OutString);
	UFUNCTION(BlueprintCallable, Category="RallyHere|Utilities")
	static bool StringTo{{unrealModelPrefix}}JsonValue(const FString& InString, {{unrealModelPrefix}}JsonValue& OutValue);
};

{{#cppNamespaceDeclarations}}
namespace {{this}}
{
{{/cppNamespaceDeclarations}}

//////////////////////////////////////////////////////////////////////////

class {{dllapi}} FHttpFileInput
{
public:
	explicit FHttpFileInput(const TCHAR* InFilePath);
	explicit FHttpFileInput(const FString& InFilePath);

	// This will automatically set the content type if not already set
    void SetFilePath(const TCHAR* InFilePath);
	void SetFilePath(const FString& InFilePath);

    // Optional if it can be deduced from the FilePath
    void SetContentType(const TCHAR* ContentType);

	FHttpFileInput& operator=(const FHttpFileInput& Other) = default;
	FHttpFileInput& operator=(const FString& InFilePath) { SetFilePath(*InFilePath); return*this; }
	FHttpFileInput& operator=(const TCHAR* InFilePath) { SetFilePath(InFilePath); return*this; }

	const FString& GetFilePath() const { return FilePath; }
	const FString& GetContentType() const { return ContentType; }

	// Returns the filename with extension
	FString GetFilename() const;

private:
    FString FilePath;
    FString ContentType;
};

//////////////////////////////////////////////////////////////////////////

class FHttpMultipartFormData
{
public:
	void SetBoundary(const TCHAR* InBoundary);
	void SetupHttpRequest(const FHttpRequestRef& HttpRequest);

	void AddStringPart(const TCHAR* Name, const TCHAR* Data);
	void AddJsonPart(const TCHAR* Name, const FString& JsonString);
	void AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray);
	void AddFilePart(const TCHAR* Name, const FHttpFileInput& File);

private:
	void AppendString(const TCHAR* Str);
	const FString& GetBoundary() const;

	mutable FString Boundary;
	TArray<uint8> FormData;

	static const TCHAR* Delimiter;
	static const TCHAR* Newline;
};

//////////////////////////////////////////////////////////////////////////

// Decodes Base64Url encoded strings, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
bool Base64UrlDecode(const FString& Base64String, T& Value)
{
	FString TmpCopy(Base64String);
	TmpCopy.ReplaceInline(TEXT("-"), TEXT("+"));
	TmpCopy.ReplaceInline(TEXT("_"), TEXT("/"));

	return FBase64::Decode(TmpCopy, Value);
}

// Encodes strings in Base64Url, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
FString Base64UrlEncode(const T& Value)
{
	FString Base64String = FBase64::Encode(Value);
	Base64String.ReplaceInline(TEXT("+"), TEXT("-"));
	Base64String.ReplaceInline(TEXT("/"), TEXT("_"));
	return Base64String;
}

template<typename T>
inline FStringFormatArg ToStringFormatArg(const T& Value)
{
	return FStringFormatArg(Value);
}

inline FStringFormatArg ToStringFormatArg(const FDateTime& Value)
{
	return FStringFormatArg(Value.ToIso8601());
}

inline FStringFormatArg ToStringFormatArg(const FGuid& Value)
{
	return FStringFormatArg(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline FStringFormatArg ToStringFormatArg(const TArray<uint8>& Value)
{
	return FStringFormatArg(Base64UrlEncode(Value));
}

template<typename T, typename std::enable_if<!std::is_base_of<{{unrealModelPrefix}}Model, T>::value, int>::type = 0>
inline FString ToString(const T& Value)
{
	return FString::Format(TEXT("{0}"), { ToStringFormatArg(Value) });
}

inline FString ToString(const FString& Value)
{
	return Value;
}

inline FString ToString(bool Value)
{
	return Value ? TEXT("true") : TEXT("false");
}

inline FStringFormatArg ToStringFormatArg(bool Value)
{
	return FStringFormatArg(ToString(Value));
}

template<typename T, typename U>
inline FStringFormatArg ToStringFormatArg(const TVariant<T,U>& Value)
{
	if (Value.template IsType<T>())
	{
		return ToStringFormatArg(Value.template Get<T>());
	}
	else
	{
		return ToStringFormatArg(Value.template Get<U>());
	}
}

inline FString ToString(const TArray<uint8>& Value)
{
	return Base64UrlEncode(Value);
}

inline FString ToString(const {{unrealModelPrefix}}Model& Value)
{
	FString String;
    TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&String);
	Value.WriteJson(Writer);
	Writer->Close();
	return String;
}

template<typename T>
inline FString ToUrlString(const T& Value)
{
	return FPlatformHttp::UrlEncode(ToString(Value));
}

template<typename T>
inline FString CollectionToUrlString(const TArray<T>& Collection, const TCHAR* Separator)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("{0}{1}"), { Separator, *ToUrlString(Collection[i]) });
	}
	return Output;
}

template<typename T>
inline FString CollectionToUrlString_csv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(","));
}

template<typename T>
inline FString CollectionToUrlString_ssv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(" "));
}

template<typename T>
inline FString CollectionToUrlString_tsv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("\t"));
}

template<typename T>
inline FString CollectionToUrlString_pipes(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("|"));
}

template<typename T>
inline FString CollectionToUrlString_multi(const TArray<T>& Collection, const TCHAR* BaseName)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	// Since this function is used to print a value string, the initial key has already been printed, so do not print it again
	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
	}
	return Output;
}

//////////////////////////////////////////////////////////////////////////

template<typename T>
inline T FromHeaderString(const FString& Value)
{
	return Value;
}

template<>
inline int32 FromHeaderString<int32>(const FString& Value)
{
	return FCString::Atoi(*Value);
}

template<>
inline int64 FromHeaderString<int64>(const FString& Value)
{
	return FCString::Atoi64(*Value);
}

template<>
inline float FromHeaderString<float>(const FString& Value)
{
	return FCString::Atof(*Value);
}

template<>
inline double FromHeaderString<double>(const FString& Value)
{
	return FCString::Atod(*Value);
}

//////////////////////////////////////////////////////////////////////////

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonValue>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), "", Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const {{unrealModelPrefix}}JsonValue& Value)
{
	WriteJsonValue(Writer, Value.GetValue());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSharedPtr<FJsonObject>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const {{unrealModelPrefix}}JsonObject& Value)
{
	WriteJsonValue(Writer, Value.GetObject());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<uint8>& Value)
{
	Writer->WriteValue(ToString(Value));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FDateTime& Value)
{
	Writer->WriteValue(Value.ToIso8601());
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const FGuid& Value)
{
	Writer->WriteValue(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const {{unrealModelPrefix}}Model& Value)
{
	Value.WriteJson(Writer);
}

template<typename T, typename std::enable_if<!TIsVariant<T>::Value && !std::is_base_of<{{unrealModelPrefix}}Model, T>::value, int>::type = 0>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const T& Value)
{
	Writer->WriteValue(Value);
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TArray<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TSet<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TMap<FString, T>& Value)
{
	Writer->WriteObjectStart();
	for (const auto& It : Value)
	{
		Writer->WriteIdentifierPrefix(It.Key);
		WriteJsonValue(Writer, It.Value);
	}
	Writer->WriteObjectEnd();
}

template<typename T, typename U>
inline void WriteJsonValue(TSharedRef<TJsonWriter<>>& Writer, const TVariant<T, U>& Value)
{
	if (Value.template IsType<T>())
	{
		return WriteJsonValue(Writer, Value.template Get<T>());
	}
	else
	{
		return WriteJsonValue(Writer, Value.template Get<U>());
	}
}


//////////////////////////////////////////////////////////////////////////

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, {{unrealModelPrefix}}JsonValue& Value)
{
	Value.SetValue(JsonValue);
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, {{unrealModelPrefix}}JsonObject& Value)
{
	const TSharedPtr<FJsonObject>* TmpValue;
	if (JsonValue->TryGetObject(TmpValue))
	{
		Value.SetObject(*TmpValue);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FString& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

{{dllapi}} bool ParseDateTime(const FString& DateTimeString, FDateTime& OutDateTime);

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FDateTime& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return ParseDateTime(TmpValue, Value);
	}
	else
		return false;
}

template<typename T, typename U>
inline bool TryGetJsonValueTVariant(const TSharedPtr<FJsonObject>& JsonObject, TVariant<T, U>& Value)
{
	for (const auto& It : (*JsonObject).Values)
	{
		T TmpValue;
		if (TryGetJsonValue(It.Value, TmpValue))
		{
			Value.template Set<T>(TmpValue);
			return true;
		}

		U TmpValue2;
		if (TryGetJsonValue(It.Value, TmpValue2))
		{
			Value.template Set<U>(TmpValue2);
			return true;
		}
	}
	return false;
}

template<typename T, typename U>
inline bool TryGetJsonValueTVariant(const TSharedPtr<FJsonValue>& JsonValue, TVariant<T, U>& Value)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		return (TryGetJsonValueTVariant(*Object, Value));
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FGuid& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return FGuid::Parse(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, bool& Value)
{
	bool TmpValue;
	if (JsonValue->TryGetBool(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonValue>& JsonObjectValue)
{
	JsonObjectValue = JsonValue;
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonObject>& JsonObjectValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		JsonObjectValue = *Object;
		return true;
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<uint8>& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Base64UrlDecode(TmpValue, Value);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, {{unrealModelPrefix}}Model& Value)
{
	return Value.FromJson(JsonValue);
}

template<typename T, typename std::enable_if<TIsVariant<T>::Value, bool>::type = true>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, T& Value)
{
	return TryGetJsonValueTVariant(JsonObject, Value);
}

template<typename T, typename std::enable_if<TIsVariant<T>::Value, bool>::type = true>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	return TryGetJsonValueTVariant(JsonValue, Value);
}

template<typename T, typename std::enable_if<!TIsVariant<T>::Value && !std::is_base_of<{{unrealModelPrefix}}Model, T>::value, int>::type = 0>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	T TmpValue;
	if (JsonValue->TryGetNumber(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<T>& ArrayValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		ArrayValue.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			ArrayValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSet<T>& SetValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		SetValue.Reset();
		SetValue.Reserve(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			SetValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TMap<FString, T>& MapValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		MapValue.Reset();
		bool ParseSuccess = true;
		for (const auto& It : (*Object)->Values)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue(It.Value, TmpValue);
			MapValue.Emplace(It.Key, MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TOptional<T>& OptionalValue)
{
	if (JsonObject->HasField(Key))
	{
		T Value;
		const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
		if (JsonValue.IsValid() && !JsonValue->IsNull())
		{
			if (TryGetJsonValue(JsonValue, Value))
			{
				OptionalValue = Value;
				return true;
			}
		}

		return false;
	}
	return true; // Absence of optional value is not a parsing error
}

template<typename T, typename U>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TVariant<T, U>& Value)
{
	for (const auto& It : JsonObject->Values)
	{
		T TmpValue;
		if (TryGetJsonValue(It.Value, TmpValue))
		{
			Value.template Set<T>(TmpValue);
			return true;
		}

		U TmpValue2;
		if (TryGetJsonValue(It.Value, TmpValue2))
		{
			Value.template Set<U>(TmpValue2);
			return true;
		}
	}
	return false;
}

{{#cppNamespaceDeclarations}}
}
{{/cppNamespaceDeclarations}}
